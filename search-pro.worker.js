const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":64,\"nextId\":64,\"documentIds\":{\"0\":\"1\",\"1\":\"1#写在前面-prologue\",\"2\":\"1#缘由-reason\",\"3\":\"1#我-myself\",\"4\":\"1#指南-navigation\",\"5\":\"2\",\"6\":\"2#heading-2\",\"7\":\"2#heading-3\",\"8\":\"2@0\",\"9\":\"2@1\",\"10\":\"3\",\"11\":\"3#定义-definition\",\"12\":\"3#元胞-cell\",\"13\":\"3#元胞空间-space\",\"14\":\"3#元胞邻居-neighbour\",\"15\":\"3#边界条件-boundary\",\"16\":\"3#元胞规则-rule\",\"17\":\"3#生命游戏-the-game-of-life\",\"18\":\"3#应用-application\",\"19\":\"3@0\",\"20\":\"4\",\"21\":\"4#heading-2\",\"22\":\"4#heading-3\",\"23\":\"4@0\",\"24\":\"4@1\",\"25\":\"5\",\"26\":\"5#heading-2\",\"27\":\"5#heading-3\",\"28\":\"5@0\",\"29\":\"5@1\",\"30\":\"6\",\"31\":\"6#heading-2\",\"32\":\"6#heading-3\",\"33\":\"6@0\",\"34\":\"6@1\",\"35\":\"7\",\"36\":\"7#heading-2\",\"37\":\"7#heading-3\",\"38\":\"7@0\",\"39\":\"7@1\",\"40\":\"8\",\"41\":\"8#概述\",\"42\":\"8#问题描述\",\"43\":\"8#模型设置\",\"44\":\"8#基本设置\",\"45\":\"8#更新规则\",\"46\":\"8#部分代码解释\",\"47\":\"8#参数设置\",\"48\":\"8#参数计算\",\"49\":\"8#结果\",\"50\":\"8@0\",\"51\":\"8@1\",\"52\":\"9\",\"53\":\"9#heading-2\",\"54\":\"9#heading-3\",\"55\":\"9@0\",\"56\":\"9@1\",\"57\":\"10\",\"58\":\"10#heading-2\",\"59\":\"10#heading-3\",\"60\":\"10@0\",\"61\":\"10@1\",\"62\":\"11\",\"63\":\"12\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,3],\"1\":[1,27],\"2\":[1,19],\"3\":[1,58],\"4\":[1,20],\"5\":[2],\"6\":[2,5],\"7\":[2,5],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[3,6],\"11\":[1,28],\"12\":[1,12],\"13\":[1,10],\"14\":[1,26],\"15\":[1,17],\"16\":[1,22],\"17\":[1,40],\"18\":[1,63],\"19\":[null,null,1],\"20\":[2],\"21\":[2,5],\"22\":[2,5],\"23\":[null,null,1],\"24\":[null,null,1],\"25\":[1],\"26\":[2,5],\"27\":[2,5],\"28\":[null,null,1],\"29\":[null,null,1],\"30\":[1],\"31\":[2,5],\"32\":[2,5],\"33\":[null,null,1],\"34\":[null,null,1],\"35\":[1],\"36\":[2,5],\"37\":[2,5],\"38\":[null,null,1],\"39\":[null,null,1],\"40\":[3,7],\"41\":[1,78],\"42\":[1,21],\"43\":[1],\"44\":[1,15],\"45\":[1,64],\"46\":[1,3],\"47\":[1,111],\"48\":[1,138],\"49\":[1,6],\"50\":[null,null,1],\"51\":[null,null,1],\"52\":[2],\"53\":[2,5],\"54\":[2,5],\"55\":[null,null,1],\"56\":[null,null,1],\"57\":[2],\"58\":[2,5],\"59\":[2,5],\"60\":[null,null,1],\"61\":[null,null,1],\"62\":[1,3],\"63\":[1]},\"averageFieldLength\":[1.4851643537517885,22.1982486631526,0.47516625310173705],\"storedFields\":{\"0\":{\"h\":\"简介    Introduction\",\"t\":[\"👋 欢迎来到我的博客！\"]},\"1\":{\"h\":\"写在前面\",\"t\":[\"其实很早就萌生过写blog的想法，但总感觉很难，很麻烦，不想走出舒适圈，所以迟迟不肯行动。\",\"但痛定思痛，觉得还是要尝试些新东西，所以便有了现在这个页面。\",\"刚开始的过程确实很难，很多新东西从未见过，一时难以消化吸收，过程中还遇到很多莫名其妙的小bug。\",\"但还好有dream-oyh的帮助，让我顺利解决了很多问题，在此表示十分感谢！💖\",\"目前还是处于入门小白阶段，还有很多排版、布局、内容方面有待优化，我会逐步去完善。\",\"下面来 talk about myself。\"]},\"2\":{\"h\":\"缘由\",\"t\":[\"👐 决定写 blog 原因大致有以下几点：\",\"很早就有的想法（想当一个知识区博主、音乐区up主），目前先尝试一个。\",\"准备夏令营过程中，发现自己之前做过的很多小项目、写过的很多代码、学过的知识都记不清了，如果之前有所记录就很便于回忆，而且复习过程中也苦于没有地方整理，blog就显得非常合适。\",\"周边盆友的影响👬。\",\"走出舒适圈，尝试新的记录生活的方式。\"]},\"3\":{\"h\":\"我\",\"t\":[\"职业： 一名在读CSUer 🏫，对，就是那个California State University(bushi)。\",\"星座： 水瓶座 \",\"成分： Swiftie 🍓 一枚。\",\"人格： INFJ绿老头一枚。\",\"爱好： LOL、听歌 🎧、唱歌 🎤、吉他 🎸、足球 ⚽。\",\"自我评价：自我感觉是一个矛盾体，看待问题十分的现实，但同时也是一个理想的完美主义者；绝对的宿命论主义倾向；梦想很多，却也逐渐看清了生活的本质，但还是希望自己未来能成为一个有用之人，探究生命的意义，世界之本质 💭 。\",\"📝 目前小小的愿望清单\",\" 进入到梦中情组\",\" 现场看一场LOL比赛(S赛/MSI/EDG比赛)\",\" 看一次霉妈的演唱会\",\" 现场看一次球赛（世界杯/国家队比赛/亚冠/欧冠/欧洲杯......）\",\" 冰岛/欧洲游\",\"twin flame who？\",\" 统一\",\" 国足进世界杯\"]},\"4\":{\"h\":\"指南\",\"t\":[\"目前博客内容主要为过去做过的一些项目、小研究、自学内容的整理等，有时间也会加入书评、乐评、随笔等其他内容。\",\"交通 主要记录本专业一些基础模型的代码实现。\",\"机器学习 主要为自学ML笔记及代码。\",\"数模 总结自己参加数模比赛过程中，常见的模型、算法整理。\",\"英语 记录自我英语学习过程。\",\"Blog 记录博主更新历程及计划。\",\"❤️ 感谢你看到这里 ❤️\"]},\"5\":{\"h\":\"A*算法\"},\"6\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"7\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"8\":{\"c\":[\"交通\"]},\"9\":{\"c\":[\"traffic\"]},\"10\":{\"h\":\"元胞自动机 Cellular Automata\",\"t\":[\"本节简单介绍一下元胞自动机模型，包括其定义、基本概念、应用等方面，具体讲解可以看这篇文章与这篇文章。\"]},\"11\":{\"h\":\"定义\",\"t\":[\"元胞自动机（Cellular Automata, CA）是自动机理论（Theory of automata）中的一种离散计算模型，最初由Stanislaw Ulam和John von Neumann 于 20 世纪 40 年代在洛斯阿拉莫斯国家实验室同时提出[1]。一个完整的元胞自动机模型包含 元胞、元胞空间、元胞邻居、元胞边界、元胞规则 五大部分，下面将分别做进一步阐述。\"]},\"12\":{\"h\":\"元胞\",\"t\":[\"元胞是 CA 模型的基本单元，是模型迭代的直接参与者，从概念上就可以理解元胞就好似生物体的细胞。每一个元胞都有一个状态,一般为二维（如 0-1），复杂情况下也有多维。\"]},\"13\":{\"h\":\"元胞空间\",\"t\":[\"元胞空间为空间内元胞的集合，即按一定方式对空间划分，元胞呈一定形状。元胞空间划分方式大致有 正方形（类似栅格化）、三角形、正六边形 等类型。\"]},\"14\":{\"h\":\"元胞邻居\",\"t\":[\"元胞邻居是某一元胞周围的元胞，是否为邻居，取决于元胞状态更新时所要搜索的空间域，在二维空间下，最常用的邻居类型是 Moore 型和 Von Neumann 型，如图一所示：\",\"图1 元胞类型\",\"Moore 邻居定义为下式：\",\"NM​(x0​,y0​)={(x,y):∣x−x0​∣<=r,∣y−y0​∣<=r}\",\"Von Neumann 邻居定义为：\",\"NV​(x0​,y0​)={(x,y):∣x−x0​∣+∣y−y0​∣<=r}\"]},\"15\":{\"h\":\"边界条件\",\"t\":[\"边界条件是元胞空间外的部分，是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞。常用的邻居边界条件类型有：固定型，周期型，绝热型和映射型这四种，常用为固定型和周期型。\",\"注\",\"固定型：在外围补上固定不变的、虚拟的元胞。\",\"周期型：每个维度的第一个元胞与最后一个元胞互为边界。\",\"绝热型：边界元胞与自己相同。\",\"映射型：边界元胞为元胞每个维度内侧邻近元胞。 一般常用为固定型和周期型边界条件。\"]},\"16\":{\"h\":\"元胞规则\",\"t\":[\"元胞规则即每次迭代，每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态，每个元胞按照该规则进行状态更新，相互作用，由局部到整体，从而引起全局的变化。元胞规则是整个 CA 模型最为关键的部分。\",\"相关信息\",\"元胞自动机更新规则特征[2]：\",\"离散型：空间、时间及状态都是离散的;\",\"同质性：服从相同的规律分布方式相同；\",\"并行性：元胞的状态更新规则变化是同步进行的；\",\"高维度：元胞自动机是一类无穷维动力系统。\"]},\"17\":{\"h\":\"生命游戏\",\"t\":[\"生命游戏是最著名的二维元胞自动机生命游戏，由John Conway于 1970 年设计。它由二维元胞网格组成，其状态可能是死亡 (0) 或活着 (1)。该游戏采用标准 Moore 邻居，其元胞规则为：\",\"对于“活着”的格子，若它的 8 个 Moore 邻居中有 2-3 个为“活着”，则该格继续保持“活着”，否则就变为“死亡”。 对于“死亡”的格子，若它的 8 个邻居中有 3 个“生”，则该格变为“生”，否则继续保持“死”。\",\"用函数表示如下：\",\"vt+1(α)=⎩⎨⎧​0,νt(α),1,​S<2∨S>3S=2S=3​\",\"图2 生命游戏\"]},\"18\":{\"h\":\"应用\",\"t\":[\"元胞自动机的应用大致有以下几类：\",\"作为物理、化学、生物过程的基础模型\",\"计算单元\",\"模拟现实复杂动态系统\",\"英文总结\",\"Cellular automaton is a discrete computing model in the Theory of automata. A complete cellular automaton model includes five parts: cell, cell space, cell neighbor, cell boundary, and cell rules. Each cell has a state which can be 0 or 1, alive or dead. Each cell follows a set of rules and updates the state at every time step based on the current state and their neighbors' state, thereby triggering global changes. It has many applications in computing and simulation.\"]},\"19\":{\"c\":[\"交通\"]},\"20\":{\"h\":\"改进A*算法\"},\"21\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"22\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"23\":{\"c\":[\"交通\"]},\"24\":{\"c\":[\"traffic\"]},\"25\":{\"h\":\"迪杰斯特拉算法\"},\"26\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"27\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"28\":{\"c\":[\"交通\"]},\"29\":{\"c\":[\"traffic\"]},\"30\":{\"h\":\"佛洛依德算法\"},\"31\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"32\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"33\":{\"c\":[\"交通\"]},\"34\":{\"c\":[\"traffic\"]},\"35\":{\"h\":\"NS模型\"},\"36\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"37\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"38\":{\"c\":[\"交通\"]},\"39\":{\"c\":[\"traffic\"]},\"40\":{\"h\":\"行人流仿真 Pedestrian Simulation\",\"t\":[\"本文探讨基于 CA 模型的行人流仿真，如果你还不了解 CA 模型，请先移步这篇文章。\"]},\"41\":{\"h\":\"概述\",\"t\":[\"行人流仿真是通过模拟人群在不同环境下的移动，研究行人行为及心理的特点的研究，其在城市规划、交通管理、疏散计划、建筑平面设计等方面有着广泛的应用。\",\"Pedestrian simulation studies pedestrians' behavioral patterns and psychological aspects by modeling and simulating the movement of crowds in various scnarios. It finds extensive applications in urban planning, traffic management, evacuation planning, and architectural layout design.\",\"分类\",\"行人流仿真按仿真规模可以大致分为三种，即 宏观(macroscopic) 、 微观(microscopic) 、介于宏微观之间(mesoscopic) 这三种。\",\"宏观：以整个人群为研究对象，研究整体移动特征如速度、密度、流向等，每个个体没有行为特征，最为常见方法为流体动力学模型(fluid dynamic model)。\",\"微观：以个体为研究对象，研究个体行为，每个个体有着独特的行为特征，常见模型是社会力模型（social force model）。\",\"介观：介于宏微观之间，人群中每个个体有着相同的行为特征，既研究整体特征也研究个体特征，常见是元胞自动机模型（cellular automata, CA）。\",\"⏩ 不同方法并非只适用于一个规模，如 CA 模型也可以在微观层面研究。此外，其他方法还有网络模型、自然模型、格子气模型以及基于机器学习的模型等，对行人流仿真进一步了解可以移步此篇论文\"]},\"42\":{\"h\":\"问题描述\",\"t\":[\"模拟行人穿过以平台\",\"相关信息\",\"平台基本信息：\",\"平台 16×30，左三个入口，大小分别为 1×1,1×4,1×1，右四个出口，均为为 1×1，中间设有障碍，行人不得通过障碍。\",\"行人每秒走一格，每个行人占一格。\",\"行人随机从各个入口进入。\",\"规定仿真时间为 960s\",\"图1 平面示意图 \"]},\"43\":{\"h\":\"模型设置\"},\"44\":{\"h\":\"基本设置\",\"t\":[\"元胞：状态设置为占有（0）与不占有（1）\",\"元胞空间：划分为方格形。\",\"元胞邻居：采用基本 Moore 型（r=1）\",\"边界条件：采用固定型。\"]},\"45\":{\"h\":\"更新规则\",\"t\":[\"更新规则即行人如何选择下一步走到哪里一个方格，这里引入元胞潜能，其定义如下：\",\"Ni,j​=Ei,j​exp(kS​Si,j​+kD​Di,j​)\",\"其中，Ei,j​ 代表位置(i, j)处元胞状态，0 代表占有，1 代表不占有，Ni,j​ 代表位置(i, j)处的元胞潜能，可以发现，当元胞占有时 Ei,j​=0 ，即该处元胞潜能为 0，反应了元胞有人占据，就无法选择。Si,j​ 为元胞静态势能，Di,j​ 为元胞动态势能， kS​ 和 kD​ 分别为对应系数。\",\"元胞静态势能反应了行人在选择下一步时，环境中静止物体的影响，这里主要考虑为出口与障碍物，定义为：\",\"Si,j​=kL​Li,j​+kO​Oi,j​\",\"其中，Li,j​ 为位置为(i, j)的元胞距出口的距离，Oi,j​ 为位置为(i, j)的元胞周边的障碍数目。\",\"元胞动态势能反应行人在选择下一步时，环境的动态影响，这里以位置为(i, j)的元胞周围空元胞数目 Di,j​ 为指标。\",\"所以最后，元胞潜能可以写为：\",\"Ni,j​=Ei,j​exp(k1​Li,j​+k2​Oi,j​+k3​Di,j​)\",\"最后对 9 个位置进行标号、对元胞潜能进行归一化，即可得到选择 9 个位置的选择概率 Pi,j​。\",\"图2 Moore邻居选择示意图\"]},\"46\":{\"h\":\"部分代码解释\",\"t\":[\"代码整体思路如下：\",\"图3 代码流程图\"]},\"47\":{\"h\":\"参数设置\",\"t\":[\"clc,clear format short; n=16; %平台宽度 h=30; %平台长度 star_x = ones(1,6); % 入口横坐标 star_y = [4,7:10,13]; % 入口纵坐标 hurdle_x = repelem(14:16,2); % 障碍 hurdle_x = cat(2,hurdle_x,[20 20]); hurdle_y = repmat(8:9,1,3); hurdle_y = cat(2,hurdle_y,[5 12]); final_x = ones(1,4)\\\\*h; % 出口 final_y = [3,6,11,14]; x=n+2; % 边界矩阵宽 y=h+2; % 边界矩阵长 platform=ones(n,h); %初始化平台 obstacle_map=ones(n+4,h+4); %设置非障碍矩阵 obstacle_map(1:2,:)=0; obstacle_map(end-1:end,:)=0; obstacle_map(:,1:2)=0; obstacle_map(:,end-1:end); border=ones(x,y); %边界矩阵 border(1,:)=0; border(end,:)=0; border(:,1)=0; border(:,end)=0; Sm=ones(n+4,h+4); % 图 Sm(1:2,:)=0; Sm(end-1:end,:)=0; Sm(:,1:2)=0; Sm(:,end-1:end); for i = 1:size(hurdle_y,2) Sm(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 obstacle_map(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 end step=1; %初始迭代次数 po=1:1:9; %位置矩阵 pp = zeros(1,9); neigh = [-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1]; L=zeros(n,h,size(final_y,2)); % 不含边界距离矩阵 N=zeros(n+2,h+2,size(final_y,2)); % 元胞潜力 N_choose=zeros(n+2,h+2); % 最终选择 P=zeros(n+2,h+2); %预留内存 prob=zeros(1,9); %概率矩阵、预留内存 go=0; % 出发人数 arrive=0; % 到达终点人数 total=960; % 迭代时间 time_people_star = zeros(n,h,total); % 记录时刻平台信息 \",\"这里设置了 4 个 map：\",\"platform：反应平台实时状态\",\"border：在 platform 外加了一圈障碍，表示边界条件。\",\"Sm 与 obstacle：在 platform 外加了两圈障碍，分别用计算 $ O*{i, j} $ 与 $ D_{i, j} $。\"]},\"48\":{\"h\":\"参数计算\",\"t\":[\"$ L*{i,j} $ 的计算：\",\"Dis = zeros(n+2,h+2,size(final_y,2)); Dis = Dis + inf; % 分别计算边界内每个原胞到出口的距离 for f=1:size(final_y,2) for i=1:n for j=1:h L(i,j,f)=sqrt((i-final_y(f))^2+(j-final_x(f))^2); %不含边界的距离矩阵 Lij end end end Dis(2:n+1,2:h+1,:)=L; for i = 1:size(hurdle_y,2) Dis(hurdle_y(i)+1,hurdle_x(i)+1,:)=inf; %障碍视为距离无穷 end \",\"Oi,j​ 与 Di,j​ 的计算：\",\"O=obstacle_map(1:x,2:y+1)+obstacle_map(3:x+2,2:y+1)+obstacle_map(2:x+1,1:y)+obstacle_map(2:x+1,3:y+2)+obstacle_map(1:x,1:y)+obstacle_map(3:x+2,1:y)+obstacle_map(1:x,3:y+2)+obstacle_map(3:x+2,3:y+2); D=Sm(1:x,2:y+1)+Sm(3:x+2,2:y+1)+Sm(2:x+1,1:y)+Sm(2:x+1,3:y+2)+Sm(1:x,1:y)+Sm(3:x+2,1:y)+Sm(1:x,3:y+2)+Sm(3:x+2,3:y+2); \",\"这段代码思想为用一个 n-2×n-2 大小的滑动窗口在 n×n 的平台上，依次从需要计算的 8 个周边位置滑动，最后得到所求，可以自己手动画一个图验证一下。\",\"计算元胞潜力：\",\"% 计算原胞潜力 N for f = 1:size(final_y,2) for i=1:x for j=1:y N(i,j,f)=border(i,j)*exp(-5*Dis(i,j,f)+D(i,j)+O(i,j)); end end end for i = 1:size(final_y,2) N(final_y(i)+1,final_x(i)+1)=1e10; % 设置出口原胞潜力为 1e10，可视为无穷大 end N_1 = max(N(:,:,1),N(:,:,2)); %最大作为原胞潜力 N N_2 = max(N(:,:,3),N(:,:,4)); N_choose = max(N_1,N_2); \",\"这里因为有四个入口，所以需要分别计算四个出口的元胞潜力大小，最后取最大。\",\"位置更新：\",\"for j=h+1:-1:2 for i=2:n+1 if(border(i,j)==0) %如果位置（即原胞）有人，计算所有邻居原胞的原胞潜力N % 计算位置1到9各原胞潜力大小，并进行归一化处理 for xy = po pp(1,xy) = N_choose(i+neigh(xy,2),j+neigh(xy,1)); end prob = pp/sum(pp); if sum([pp(2),pp(3),pp(6),pp(8),pp(9)]~=0) % 上下前三个方向不全都有人 S=randsrc(1,1,[po;prob]); %依原胞潜力N，选择下一位置，即进行位置更新 else S = 5; end k = i + neigh(S,2); t = j + neigh(S,1); if platform(k-1,t-1)==0 % 选择新位置已占，则选回原位置 S = 5; k = i + neigh(S,2); t = j + neigh(S,1); end platform(i-1,j-1)=1; % 位置更新，原来原胞更新为空状态 platform(k-1,t-1)=0; % 位置更新，新选择原胞更新为占有状态 end end end \",\"这里用 border 矩阵进行计算，然后在 platform 上进行更新，最后把再 border = platform ，从而实现每一次迭代的整体更新。此外，代码设定，如果上下和前面三个位置共 5 个位置没有人的话才进行选择，否则就待在原地，贴近现实中人是向前走的；如果选择的位置被占，则待在原地。代码从离平台近的位置向远处开始遍历，反应人流变化的方向与源头。\"]},\"49\":{\"h\":\"结果\",\"t\":[\"图4 动态演示\",\"图5 热力图（迭代周期960s）\",\"完整代码\"]},\"50\":{\"c\":[\"交通\"]},\"51\":{\"c\":[\"traffic\"]},\"52\":{\"h\":\"0-1规划模型最短路\"},\"53\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"54\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"55\":{\"c\":[\"交通\"]},\"56\":{\"c\":[\"traffic\"]},\"57\":{\"h\":\"增长系数法 GUI\"},\"58\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"59\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"60\":{\"c\":[\"交通\"]},\"61\":{\"c\":[\"traffic\"]},\"62\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"63\":{\"h\":\"Traffic\"}},\"dirtCount\":0,\"index\":[[\"增长系数法\",{\"0\":{\"57\":1}}],[\"完整代码\",{\"1\":{\"49\":1}}],[\"迭代周期960s\",{\"1\":{\"49\":1}}],[\"迭代时间\",{\"1\":{\"47\":1}}],[\"热力图\",{\"1\":{\"49\":1}}],[\"动态演示\",{\"1\":{\"49\":1}}],[\"结果\",{\"0\":{\"49\":1}}],[\"贴近现实中人是向前走的\",{\"1\":{\"48\":1}}],[\"上进行更新\",{\"1\":{\"48\":1}}],[\"上下前三个方向不全都有人\",{\"1\":{\"48\":1}}],[\"然后在\",{\"1\":{\"48\":1}}],[\"矩阵进行计算\",{\"1\":{\"48\":1}}],[\"新选择原胞更新为占有状态\",{\"1\":{\"48\":1}}],[\"原来原胞更新为空状态\",{\"1\":{\"48\":1}}],[\"原因大致有以下几点\",{\"1\":{\"2\":1}}],[\"则待在原地\",{\"1\":{\"48\":1}}],[\"则选回原位置\",{\"1\":{\"48\":1}}],[\"则该格变为\",{\"1\":{\"17\":1}}],[\"则该格继续保持\",{\"1\":{\"17\":1}}],[\"选择新位置已占\",{\"1\":{\"48\":1}}],[\"选择下一位置\",{\"1\":{\"48\":1}}],[\"依原胞潜力n\",{\"1\":{\"48\":1}}],[\"依次从需要计算的\",{\"1\":{\"48\":1}}],[\"~=0\",{\"1\":{\"48\":1}}],[\"并进行归一化处理\",{\"1\":{\"48\":1}}],[\"并行性\",{\"1\":{\"16\":1}}],[\"有人\",{\"1\":{\"48\":1}}],[\"有时间也会加入书评\",{\"1\":{\"4\":1}}],[\"位置更新\",{\"1\":{\"48\":3}}],[\"位置矩阵\",{\"1\":{\"47\":1}}],[\"可视为无穷大\",{\"1\":{\"48\":1}}],[\"可以自己手动画一个图验证一下\",{\"1\":{\"48\":1}}],[\"可以发现\",{\"1\":{\"45\":1}}],[\"计算位置1到9各原胞潜力大小\",{\"1\":{\"48\":1}}],[\"计算所有邻居原胞的原胞潜力n\",{\"1\":{\"48\":1}}],[\"计算原胞潜力\",{\"1\":{\"48\":1}}],[\"计算元胞潜力\",{\"1\":{\"48\":1}}],[\"计算单元\",{\"1\":{\"18\":1}}],[\"大小的滑动窗口在\",{\"1\":{\"48\":1}}],[\"大小分别为\",{\"1\":{\"42\":1}}],[\"^2\",{\"1\":{\"48\":1}}],[\"^2+\",{\"1\":{\"48\":1}}],[\"+o\",{\"1\":{\"48\":1}}],[\"+obstacle\",{\"1\":{\"48\":7}}],[\"+d\",{\"1\":{\"48\":1}}],[\"+sm\",{\"1\":{\"48\":7}}],[\"+1\",{\"1\":{\"48\":4}}],[\"+\",{\"1\":{\"48\":5}}],[\"+2\",{\"1\":{\"47\":4}}],[\"参数计算\",{\"0\":{\"48\":1}}],[\"参数设置\",{\"0\":{\"47\":1}}],[\"$\",{\"1\":{\"47\":4,\"48\":2}}],[\"外加了两圈障碍\",{\"1\":{\"47\":1}}],[\"外加了一圈障碍\",{\"1\":{\"47\":1}}],[\"与\",{\"1\":{\"47\":2,\"48\":1}}],[\"与不占有\",{\"1\":{\"44\":1}}],[\"表示边界条件\",{\"1\":{\"47\":1}}],[\"反应人流变化的方向与源头\",{\"1\":{\"48\":1}}],[\"反应平台实时状态\",{\"1\":{\"47\":1}}],[\"反应了元胞有人占据\",{\"1\":{\"45\":1}}],[\"到达终点人数\",{\"1\":{\"47\":1}}],[\"出发人数\",{\"1\":{\"47\":1}}],[\"出口\",{\"1\":{\"47\":1}}],[\"gui\",{\"0\":{\"57\":1}}],[\"go=0\",{\"1\":{\"47\":1}}],[\"global\",{\"1\":{\"18\":1}}],[\"概率矩阵\",{\"1\":{\"47\":1}}],[\"概述\",{\"0\":{\"41\":1}}],[\"预留内存\",{\"1\":{\"47\":2}}],[\"zeros\",{\"1\":{\"47\":2,\"48\":1}}],[\"初始迭代次数\",{\"1\":{\"47\":1}}],[\"初始化平台\",{\"1\":{\"47\":1}}],[\"设置出口原胞潜力为\",{\"1\":{\"48\":1}}],[\"设置障碍\",{\"1\":{\"47\":2}}],[\"设置非障碍矩阵\",{\"1\":{\"47\":1}}],[\"5\",{\"1\":{\"47\":1,\"48\":4}}],[\"障碍视为距离无穷\",{\"1\":{\"48\":1}}],[\"障碍\",{\"1\":{\"47\":1}}],[\"入口纵坐标\",{\"1\":{\"47\":1}}],[\"入口横坐标\",{\"1\":{\"47\":1}}],[\"7\",{\"1\":{\"47\":1}}],[\"4\",{\"1\":{\"47\":3,\"48\":1}}],[\"404\",{\"1\":{\"62\":1}}],[\"40\",{\"1\":{\"11\":1}}],[\"6\",{\"1\":{\"47\":2,\"48\":1}}],[\"代码从离平台近的位置向远处开始遍历\",{\"1\":{\"48\":1}}],[\"代码设定\",{\"1\":{\"48\":1}}],[\"代码流程图\",{\"1\":{\"46\":1}}],[\"代码整体思路如下\",{\"1\":{\"46\":1}}],[\"代表不占有\",{\"1\":{\"45\":1}}],[\"代表占有\",{\"1\":{\"45\":1}}],[\"代表位置\",{\"1\":{\"45\":2}}],[\"部分代码解释\",{\"0\":{\"46\":1}}],[\"9\",{\"1\":{\"45\":2,\"47\":4,\"48\":1}}],[\"960s\",{\"1\":{\"42\":1}}],[\"环境的动态影响\",{\"1\":{\"45\":1}}],[\"环境中静止物体的影响\",{\"1\":{\"45\":1}}],[\"的平台上\",{\"1\":{\"48\":1}}],[\"的计算\",{\"1\":{\"48\":2}}],[\"的元胞周围空元胞数目\",{\"1\":{\"45\":1}}],[\"的元胞周边的障碍数目\",{\"1\":{\"45\":1}}],[\"的元胞距出口的距离\",{\"1\":{\"45\":1}}],[\"的格子\",{\"1\":{\"17\":2}}],[\"为指标\",{\"1\":{\"45\":1}}],[\"为位置为\",{\"1\":{\"45\":2}}],[\"为元胞动态势能\",{\"1\":{\"45\":1}}],[\"为元胞静态势能\",{\"1\":{\"45\":1}}],[\"分别计算边界内每个原胞到出口的距离\",{\"1\":{\"48\":1}}],[\"分别用计算\",{\"1\":{\"47\":1}}],[\"分别为对应系数\",{\"1\":{\"45\":1}}],[\"分类\",{\"1\":{\"41\":1}}],[\"k\",{\"1\":{\"48\":4}}],[\"k1​li\",{\"1\":{\"45\":1}}],[\"kd​\",{\"1\":{\"45\":1}}],[\"ks​\",{\"1\":{\"45\":1}}],[\"ks​si\",{\"1\":{\"45\":1}}],[\"和\",{\"1\":{\"45\":1}}],[\"就无法选择\",{\"1\":{\"45\":1}}],[\"就是那个california\",{\"1\":{\"3\":1}}],[\"当元胞占有时\",{\"1\":{\"45\":1}}],[\"处的元胞潜能\",{\"1\":{\"45\":1}}],[\"处元胞状态\",{\"1\":{\"45\":1}}],[\"j+neigh\",{\"1\":{\"48\":1}}],[\"j=h+1\",{\"1\":{\"48\":1}}],[\"j=1\",{\"1\":{\"48\":2}}],[\"j\",{\"1\":{\"45\":5,\"47\":2,\"48\":12}}],[\"j​+k3​di\",{\"1\":{\"45\":1}}],[\"j​+k2​oi\",{\"1\":{\"45\":1}}],[\"j​+ko​oi\",{\"1\":{\"45\":1}}],[\"j​+kd​di\",{\"1\":{\"45\":1}}],[\"j​=kl​li\",{\"1\":{\"45\":1}}],[\"j​=0\",{\"1\":{\"45\":1}}],[\"j​=ei\",{\"1\":{\"45\":2}}],[\"j​\",{\"1\":{\"45\":11,\"48\":2}}],[\"j​exp\",{\"1\":{\"45\":2}}],[\"这段代码思想为用一个\",{\"1\":{\"48\":1}}],[\"这里用\",{\"1\":{\"48\":1}}],[\"这里因为有四个入口\",{\"1\":{\"48\":1}}],[\"这里设置了\",{\"1\":{\"47\":1}}],[\"这里以位置为\",{\"1\":{\"45\":1}}],[\"这里主要考虑为出口与障碍物\",{\"1\":{\"45\":1}}],[\"这里引入元胞潜能\",{\"1\":{\"45\":1}}],[\"这三种\",{\"1\":{\"41\":1}}],[\"更新规则即行人如何选择下一步走到哪里一个方格\",{\"1\":{\"45\":1}}],[\"更新规则\",{\"0\":{\"45\":1}}],[\"采用固定型\",{\"1\":{\"44\":1}}],[\"采用基本\",{\"1\":{\"44\":1}}],[\"repmat\",{\"1\":{\"47\":1}}],[\"repelem\",{\"1\":{\"47\":1}}],[\"r=1\",{\"1\":{\"44\":1}}],[\"rules\",{\"1\":{\"18\":2}}],[\"划分为方格形\",{\"1\":{\"44\":1}}],[\"状态设置为占有\",{\"1\":{\"44\":1}}],[\"基本设置\",{\"0\":{\"44\":1}}],[\"基本概念\",{\"1\":{\"10\":1}}],[\"平面示意图\",{\"1\":{\"42\":1}}],[\"平台长度\",{\"1\":{\"47\":1}}],[\"平台宽度\",{\"1\":{\"47\":1}}],[\"平台\",{\"1\":{\"42\":1}}],[\"平台基本信息\",{\"1\":{\"42\":1}}],[\"规定仿真时间为\",{\"1\":{\"42\":1}}],[\"行人随机从各个入口进入\",{\"1\":{\"42\":1}}],[\"行人每秒走一格\",{\"1\":{\"42\":1}}],[\"行人不得通过障碍\",{\"1\":{\"42\":1}}],[\"行人流仿真按仿真规模可以大致分为三种\",{\"1\":{\"41\":1}}],[\"行人流仿真是通过模拟人群在不同环境下的移动\",{\"1\":{\"41\":1}}],[\"行人流仿真\",{\"0\":{\"40\":1}}],[\"中间设有障碍\",{\"1\":{\"42\":1}}],[\"中的一种离散计算模型\",{\"1\":{\"11\":1}}],[\"均为为\",{\"1\":{\"42\":1}}],[\"右四个出口\",{\"1\":{\"42\":1}}],[\"左三个入口\",{\"1\":{\"42\":1}}],[\"问题描述\",{\"0\":{\"42\":1}}],[\"格子气模型以及基于机器学习的模型等\",{\"1\":{\"41\":1}}],[\"此外\",{\"1\":{\"41\":1,\"48\":1}}],[\"不含边界的距离矩阵\",{\"1\":{\"48\":1}}],[\"不含边界距离矩阵\",{\"1\":{\"47\":1}}],[\"不同方法并非只适用于一个规模\",{\"1\":{\"41\":1}}],[\"不想走出舒适圈\",{\"1\":{\"1\":1}}],[\"⏩\",{\"1\":{\"41\":1}}],[\"既研究整体特征也研究个体特征\",{\"1\":{\"41\":1}}],[\"人群中每个个体有着相同的行为特征\",{\"1\":{\"41\":1}}],[\"人格\",{\"1\":{\"3\":1}}],[\"介观\",{\"1\":{\"41\":1}}],[\"介于宏微观之间\",{\"1\":{\"41\":2}}],[\"以个体为研究对象\",{\"1\":{\"41\":1}}],[\"以整个人群为研究对象\",{\"1\":{\"41\":1}}],[\"流向等\",{\"1\":{\"41\":1}}],[\"密度\",{\"1\":{\"41\":1}}],[\"研究个体行为\",{\"1\":{\"41\":1}}],[\"研究整体移动特征如速度\",{\"1\":{\"41\":1}}],[\"研究行人行为及心理的特点的研究\",{\"1\":{\"41\":1}}],[\"微观\",{\"1\":{\"41\":2}}],[\"宏观\",{\"1\":{\"41\":2}}],[\"即进行位置更新\",{\"1\":{\"48\":1}}],[\"即原胞\",{\"1\":{\"48\":1}}],[\"即可得到选择\",{\"1\":{\"45\":1}}],[\"即该处元胞潜能为\",{\"1\":{\"45\":1}}],[\"即\",{\"1\":{\"41\":1}}],[\"即按一定方式对空间划分\",{\"1\":{\"13\":1}}],[\"l\",{\"1\":{\"48\":2}}],[\"l=zeros\",{\"1\":{\"47\":1}}],[\"lij\",{\"1\":{\"48\":1}}],[\"li\",{\"1\":{\"45\":1}}],[\"layout\",{\"1\":{\"41\":1}}],[\"lol\",{\"1\":{\"3\":1}}],[\"建筑平面设计等方面有着广泛的应用\",{\"1\":{\"41\":1}}],[\"疏散计划\",{\"1\":{\"41\":1}}],[\"请先移步这篇文章\",{\"1\":{\"40\":1}}],[\"本文探讨基于\",{\"1\":{\"40\":1}}],[\"本节简单介绍一下元胞自动机模型\",{\"1\":{\"10\":1}}],[\"prob\",{\"1\":{\"48\":2}}],[\"prob=zeros\",{\"1\":{\"47\":1}}],[\"po\",{\"1\":{\"48\":2}}],[\"po=1\",{\"1\":{\"47\":1}}],[\"people\",{\"1\":{\"47\":1}}],[\"pedestrians\",{\"1\":{\"41\":1}}],[\"pedestrian\",{\"0\":{\"40\":1},\"1\":{\"41\":1}}],[\"p=zeros\",{\"1\":{\"47\":1}}],[\"pp\",{\"1\":{\"47\":1,\"48\":8}}],[\"platform\",{\"1\":{\"47\":3,\"48\":5}}],[\"platform=ones\",{\"1\":{\"47\":1}}],[\"planning\",{\"1\":{\"41\":2}}],[\"pi\",{\"1\":{\"45\":1}}],[\"psychological\",{\"1\":{\"41\":1}}],[\"patterns\",{\"1\":{\"41\":1}}],[\"parts\",{\"1\":{\"18\":1}}],[\"佛洛依德算法\",{\"0\":{\"30\":1}}],[\"迪杰斯特拉算法\",{\"0\":{\"25\":1}}],[\"改进a\",{\"0\":{\"20\":1}}],[\"d=sm\",{\"1\":{\"48\":1}}],[\"d\",{\"1\":{\"47\":1}}],[\"dis\",{\"1\":{\"48\":6}}],[\"discrete\",{\"1\":{\"18\":1}}],[\"di\",{\"1\":{\"45\":2,\"48\":1}}],[\"dynamic\",{\"1\":{\"41\":1}}],[\"design\",{\"1\":{\"41\":1}}],[\"dead\",{\"1\":{\"18\":1}}],[\"which\",{\"1\":{\"18\":1}}],[\"who\",{\"1\":{\"3\":1}}],[\"h+1\",{\"1\":{\"48\":1}}],[\"h+2\",{\"1\":{\"47\":3,\"48\":1}}],[\"h+4\",{\"1\":{\"47\":2}}],[\"h\",{\"1\":{\"47\":4,\"48\":1}}],[\"hurdle\",{\"1\":{\"47\":11,\"48\":3}}],[\"h=30\",{\"1\":{\"47\":1}}],[\"has\",{\"1\":{\"18\":2}}],[\"here\",{\"1\":{\"6\":1,\"7\":1,\"21\":1,\"22\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"53\":1,\"54\":1,\"58\":1,\"59\":1}}],[\"heading\",{\"0\":{\"6\":1,\"7\":1,\"21\":1,\"22\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"53\":1,\"54\":1,\"58\":1,\"59\":1}}],[\"else\",{\"1\":{\"48\":1}}],[\"exp\",{\"1\":{\"48\":1}}],[\"extensive\",{\"1\":{\"41\":1}}],[\"end\",{\"1\":{\"47\":11,\"48\":14}}],[\"ei\",{\"1\":{\"45\":2}}],[\"evacuation\",{\"1\":{\"41\":1}}],[\"every\",{\"1\":{\"18\":1}}],[\"each\",{\"1\":{\"18\":2}}],[\"edg比赛\",{\"1\":{\"3\":1}}],[\"f\",{\"1\":{\"48\":6}}],[\"f=1\",{\"1\":{\"48\":1}}],[\"found\",{\"1\":{\"62\":1}}],[\"for\",{\"1\":{\"47\":1,\"48\":11}}],[\"format\",{\"1\":{\"47\":1}}],[\"force\",{\"1\":{\"41\":1}}],[\"follows\",{\"1\":{\"18\":1}}],[\"fluid\",{\"1\":{\"41\":1}}],[\"flame\",{\"1\":{\"3\":1}}],[\"final\",{\"1\":{\"47\":4,\"48\":8}}],[\"finds\",{\"1\":{\"41\":1}}],[\"five\",{\"1\":{\"18\":1}}],[\"英文总结\",{\"1\":{\"18\":1}}],[\"英语\",{\"1\":{\"4\":1}}],[\"模拟行人穿过以平台\",{\"1\":{\"42\":1}}],[\"模拟现实复杂动态系统\",{\"1\":{\"18\":1}}],[\"模型设置\",{\"0\":{\"43\":1}}],[\"模型也可以在微观层面研究\",{\"1\":{\"41\":1}}],[\"模型\",{\"1\":{\"40\":1}}],[\"模型的行人流仿真\",{\"1\":{\"40\":1}}],[\"模型的基本单元\",{\"1\":{\"12\":1}}],[\"模型最为关键的部分\",{\"1\":{\"16\":1}}],[\"化学\",{\"1\":{\"18\":1}}],[\"作为物理\",{\"1\":{\"18\":1}}],[\"应用\",{\"0\":{\"18\":1}}],[\"应用等方面\",{\"1\":{\"10\":1}}],[\"图5\",{\"1\":{\"49\":1}}],[\"图4\",{\"1\":{\"49\":1}}],[\"图\",{\"1\":{\"47\":1}}],[\"图3\",{\"1\":{\"46\":1}}],[\"图2\",{\"1\":{\"17\":1,\"45\":1}}],[\"图1\",{\"1\":{\"14\":1,\"42\":1}}],[\"​s<2∨s>3s=2s=3​\",{\"1\":{\"17\":1}}],[\"νt\",{\"1\":{\"17\":1}}],[\"α\",{\"1\":{\"17\":2}}],[\"various\",{\"1\":{\"41\":1}}],[\"vt+1\",{\"1\":{\"17\":1}}],[\"von\",{\"1\":{\"11\":1,\"14\":2}}],[\"用函数表示如下\",{\"1\":{\"17\":1}}],[\"死\",{\"1\":{\"17\":1}}],[\"死亡\",{\"1\":{\"17\":2}}],[\"否则就待在原地\",{\"1\":{\"48\":1}}],[\"否则就变为\",{\"1\":{\"17\":1}}],[\"否则继续保持\",{\"1\":{\"17\":1}}],[\"生物过程的基础模型\",{\"1\":{\"18\":1}}],[\"生\",{\"1\":{\"17\":2}}],[\"生命游戏是最著名的二维元胞自动机生命游戏\",{\"1\":{\"17\":1}}],[\"生命游戏\",{\"0\":{\"17\":1},\"1\":{\"17\":1}}],[\"个周边位置滑动\",{\"1\":{\"48\":1}}],[\"个位置没有人的话才进行选择\",{\"1\":{\"48\":1}}],[\"个位置的选择概率\",{\"1\":{\"45\":1}}],[\"个位置进行标号\",{\"1\":{\"45\":1}}],[\"个邻居中有\",{\"1\":{\"17\":1}}],[\"个为\",{\"1\":{\"17\":1}}],[\"个\",{\"1\":{\"17\":2,\"47\":1}}],[\"8\",{\"1\":{\"17\":2,\"47\":1,\"48\":2}}],[\"若它的\",{\"1\":{\"17\":2}}],[\"活着\",{\"1\":{\"17\":3}}],[\"邻居中有\",{\"1\":{\"17\":1}}],[\"邻居\",{\"1\":{\"17\":1}}],[\"邻居定义为\",{\"1\":{\"14\":1}}],[\"邻居定义为下式\",{\"1\":{\"14\":1}}],[\"该游戏采用标准\",{\"1\":{\"17\":1}}],[\"或活着\",{\"1\":{\"17\":1}}],[\"其中\",{\"1\":{\"45\":2}}],[\"其定义如下\",{\"1\":{\"45\":1}}],[\"其他方法还有网络模型\",{\"1\":{\"41\":1}}],[\"其在城市规划\",{\"1\":{\"41\":1}}],[\"其元胞规则为\",{\"1\":{\"17\":1}}],[\"其状态可能是死亡\",{\"1\":{\"17\":1}}],[\"其实很早就萌生过写blog的想法\",{\"1\":{\"1\":1}}],[\"它由二维元胞网格组成\",{\"1\":{\"17\":1}}],[\"年设计\",{\"1\":{\"17\":1}}],[\"年代在洛斯阿拉莫斯国家实验室同时提出\",{\"1\":{\"11\":1}}],[\"由john\",{\"1\":{\"17\":1}}],[\"由局部到整体\",{\"1\":{\"16\":1}}],[\"高维度\",{\"1\":{\"16\":1}}],[\"服从相同的规律分布方式相同\",{\"1\":{\"16\":1}}],[\"同质性\",{\"1\":{\"16\":1}}],[\"时间及状态都是离散的\",{\"1\":{\"16\":1}}],[\"空间\",{\"1\":{\"16\":1}}],[\"离散型\",{\"1\":{\"16\":1}}],[\"相关信息\",{\"1\":{\"16\":1,\"42\":1}}],[\"相互作用\",{\"1\":{\"16\":1}}],[\"从而实现每一次迭代的整体更新\",{\"1\":{\"48\":1}}],[\"从而引起全局的变化\",{\"1\":{\"16\":1}}],[\"从概念上就可以理解元胞就好似生物体的细胞\",{\"1\":{\"12\":1}}],[\"映射型\",{\"1\":{\"15\":1}}],[\"边界矩阵\",{\"1\":{\"47\":1}}],[\"边界矩阵长\",{\"1\":{\"47\":1}}],[\"边界矩阵宽\",{\"1\":{\"47\":1}}],[\"边界元胞为元胞每个维度内侧邻近元胞\",{\"1\":{\"15\":1}}],[\"边界元胞与自己相同\",{\"1\":{\"15\":1}}],[\"边界条件是元胞空间外的部分\",{\"1\":{\"15\":1}}],[\"边界条件\",{\"0\":{\"15\":1},\"1\":{\"44\":1}}],[\"每个行人占一格\",{\"1\":{\"42\":1}}],[\"每个个体有着独特的行为特征\",{\"1\":{\"41\":1}}],[\"每个个体没有行为特征\",{\"1\":{\"41\":1}}],[\"每个元胞按照该规则进行状态更新\",{\"1\":{\"16\":1}}],[\"每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态\",{\"1\":{\"16\":1}}],[\"每个维度的第一个元胞与最后一个元胞互为边界\",{\"1\":{\"15\":1}}],[\"每一个元胞都有一个状态\",{\"1\":{\"12\":1}}],[\"虚拟的元胞\",{\"1\":{\"15\":1}}],[\"注\",{\"1\":{\"15\":1}}],[\"绝热型\",{\"1\":{\"15\":1}}],[\"绝热型和映射型这四种\",{\"1\":{\"15\":1}}],[\"绝对的宿命论主义倾向\",{\"1\":{\"3\":1}}],[\"周期型\",{\"1\":{\"15\":2}}],[\"周边盆友的影响👬\",{\"1\":{\"2\":1}}],[\"固定型\",{\"1\":{\"15\":2}}],[\"常见是元胞自动机模型\",{\"1\":{\"41\":1}}],[\"常见模型是社会力模型\",{\"1\":{\"41\":1}}],[\"常见的模型\",{\"1\":{\"4\":1}}],[\"常用为固定型和周期型\",{\"1\":{\"15\":1}}],[\"常用的邻居边界条件类型有\",{\"1\":{\"15\":1}}],[\"∣x−x0​∣+∣y−y0​∣<=r\",{\"1\":{\"14\":1}}],[\"∣x−x0​∣<=r\",{\"1\":{\"14\":1}}],[\"∣y−y0​∣<=r\",{\"1\":{\"14\":1}}],[\"y+2\",{\"1\":{\"48\":6}}],[\"y+1\",{\"1\":{\"48\":4}}],[\"y=h+2\",{\"1\":{\"47\":1}}],[\"y\",{\"1\":{\"14\":2,\"47\":11,\"48\":15}}],[\"y0​\",{\"1\":{\"14\":2}}],[\"xy\",{\"1\":{\"48\":4}}],[\"x+1\",{\"1\":{\"48\":4}}],[\"x+2\",{\"1\":{\"48\":6}}],[\"x=n+2\",{\"1\":{\"47\":1}}],[\"x\",{\"1\":{\"14\":2,\"47\":8,\"48\":10}}],[\"x0​\",{\"1\":{\"14\":2}}],[\"=1\",{\"1\":{\"48\":1}}],[\"=1e10\",{\"1\":{\"48\":1}}],[\"==0\",{\"1\":{\"48\":2}}],[\"=border\",{\"1\":{\"48\":1}}],[\"=inf\",{\"1\":{\"48\":1}}],[\"=l\",{\"1\":{\"48\":1}}],[\"=sqrt\",{\"1\":{\"48\":1}}],[\"=0\",{\"1\":{\"47\":12,\"48\":1}}],[\"=⎩⎨⎧​0\",{\"1\":{\"17\":1}}],[\"=\",{\"1\":{\"14\":2,\"47\":12,\"48\":18}}],[\"not\",{\"1\":{\"62\":1}}],[\"n×n\",{\"1\":{\"48\":1}}],[\"n+1\",{\"1\":{\"48\":2}}],[\"n+2\",{\"1\":{\"47\":3,\"48\":1}}],[\"n+4\",{\"1\":{\"47\":2}}],[\"n=zeros\",{\"1\":{\"47\":1}}],[\"n=16\",{\"1\":{\"47\":1}}],[\"n\",{\"1\":{\"47\":4,\"48\":16}}],[\"ni\",{\"1\":{\"45\":3}}],[\"ns模型\",{\"0\":{\"35\":1}}],[\"neigh\",{\"1\":{\"47\":1,\"48\":4}}],[\"neighbors\",{\"1\":{\"18\":1}}],[\"neighbor\",{\"1\":{\"18\":1}}],[\"neumann\",{\"1\":{\"11\":1,\"14\":2}}],[\"nv​\",{\"1\":{\"14\":1}}],[\"nm​\",{\"1\":{\"14\":1}}],[\"型\",{\"1\":{\"14\":1,\"44\":1}}],[\"型和\",{\"1\":{\"14\":1}}],[\"最大作为原胞潜力\",{\"1\":{\"48\":1}}],[\"最后把再\",{\"1\":{\"48\":1}}],[\"最后取最大\",{\"1\":{\"48\":1}}],[\"最后得到所求\",{\"1\":{\"48\":1}}],[\"最后对\",{\"1\":{\"45\":1}}],[\"最终选择\",{\"1\":{\"47\":1}}],[\"最为常见方法为流体动力学模型\",{\"1\":{\"41\":1}}],[\"最常用的邻居类型是\",{\"1\":{\"14\":1}}],[\"最初由stanislaw\",{\"1\":{\"11\":1}}],[\"在\",{\"1\":{\"47\":2}}],[\"在外围补上固定不变的\",{\"1\":{\"15\":1}}],[\"在二维空间下\",{\"1\":{\"14\":1}}],[\"在此表示十分感谢\",{\"1\":{\"1\":1}}],[\"取决于元胞状态更新时所要搜索的空间域\",{\"1\":{\"14\":1}}],[\"等类型\",{\"1\":{\"13\":1}}],[\"正六边形\",{\"1\":{\"13\":1}}],[\"正方形\",{\"1\":{\"13\":1}}],[\"三角形\",{\"1\":{\"13\":1}}],[\"类似栅格化\",{\"1\":{\"13\":1}}],[\"复杂情况下也有多维\",{\"1\":{\"12\":1}}],[\"0\",{\"0\":{\"52\":1},\"1\":{\"12\":1,\"17\":1,\"18\":1,\"44\":1,\"45\":2,\"47\":6}}],[\"如果选择的位置被占\",{\"1\":{\"48\":1}}],[\"如果上下和前面三个位置共\",{\"1\":{\"48\":1}}],[\"如果位置\",{\"1\":{\"48\":1}}],[\"如果你还不了解\",{\"1\":{\"40\":1}}],[\"如果之前有所记录就很便于回忆\",{\"1\":{\"2\":1}}],[\"如图一所示\",{\"1\":{\"14\":1}}],[\"如\",{\"1\":{\"12\":1,\"41\":1}}],[\"是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞\",{\"1\":{\"15\":1}}],[\"是否为邻居\",{\"1\":{\"14\":1}}],[\"是模型迭代的直接参与者\",{\"1\":{\"12\":1}}],[\"是自动机理论\",{\"1\":{\"11\":1}}],[\"下面将分别做进一步阐述\",{\"1\":{\"11\":1}}],[\"下面来\",{\"1\":{\"1\":1}}],[\"五大部分\",{\"1\":{\"11\":1}}],[\"元胞潜力\",{\"1\":{\"47\":1}}],[\"元胞潜能可以写为\",{\"1\":{\"45\":1}}],[\"元胞动态势能反应行人在选择下一步时\",{\"1\":{\"45\":1}}],[\"元胞静态势能反应了行人在选择下一步时\",{\"1\":{\"45\":1}}],[\"元胞的状态更新规则变化是同步进行的\",{\"1\":{\"16\":1}}],[\"元胞类型\",{\"1\":{\"14\":1}}],[\"元胞呈一定形状\",{\"1\":{\"13\":1}}],[\"元胞是\",{\"1\":{\"12\":1}}],[\"元胞规则是整个\",{\"1\":{\"16\":1}}],[\"元胞规则即每次迭代\",{\"1\":{\"16\":1}}],[\"元胞规则\",{\"0\":{\"16\":1},\"1\":{\"11\":1}}],[\"元胞边界\",{\"1\":{\"11\":1}}],[\"元胞邻居是某一元胞周围的元胞\",{\"1\":{\"14\":1}}],[\"元胞邻居\",{\"0\":{\"14\":1},\"1\":{\"11\":1,\"44\":1}}],[\"元胞空间划分方式大致有\",{\"1\":{\"13\":1}}],[\"元胞空间为空间内元胞的集合\",{\"1\":{\"13\":1}}],[\"元胞空间\",{\"0\":{\"13\":1},\"1\":{\"11\":1,\"44\":1}}],[\"元胞\",{\"0\":{\"12\":1},\"1\":{\"11\":1,\"44\":1}}],[\"元胞自动机的应用大致有以下几类\",{\"1\":{\"18\":1}}],[\"元胞自动机是一类无穷维动力系统\",{\"1\":{\"16\":1}}],[\"元胞自动机更新规则特征\",{\"1\":{\"16\":1}}],[\"元胞自动机\",{\"0\":{\"10\":1},\"1\":{\"11\":1}}],[\"1规划模型最短路\",{\"0\":{\"52\":1}}],[\"1e10\",{\"1\":{\"48\":1}}],[\"11\",{\"1\":{\"47\":1}}],[\"12\",{\"1\":{\"47\":1}}],[\"16\",{\"1\":{\"47\":1}}],[\"16×30\",{\"1\":{\"42\":1}}],[\"14\",{\"1\":{\"47\":2}}],[\"13\",{\"1\":{\"47\":1}}],[\"10\",{\"1\":{\"47\":1}}],[\"1×4\",{\"1\":{\"42\":1}}],[\"1×1\",{\"1\":{\"42\":3}}],[\"1970\",{\"1\":{\"17\":1}}],[\"1\",{\"1\":{\"11\":1,\"12\":1,\"17\":2,\"18\":1,\"44\":1,\"45\":1,\"47\":29,\"48\":31}}],[\"世纪\",{\"1\":{\"11\":1}}],[\"世界杯\",{\"1\":{\"3\":1}}],[\"世界之本质\",{\"1\":{\"3\":1}}],[\"于\",{\"1\":{\"11\":1}}],[\"urban\",{\"1\":{\"41\":1}}],[\"updates\",{\"1\":{\"18\":1}}],[\"ulam和john\",{\"1\":{\"11\":1}}],[\"university\",{\"1\":{\"3\":1}}],[\"o=obstacle\",{\"1\":{\"48\":1}}],[\"o\",{\"1\":{\"47\":1}}],[\"obstacle\",{\"1\":{\"47\":7}}],[\"oi\",{\"1\":{\"45\":1,\"48\":1}}],[\"ones\",{\"1\":{\"47\":2}}],[\"on\",{\"1\":{\"18\":1}}],[\"or\",{\"1\":{\"18\":2}}],[\"of\",{\"1\":{\"11\":1,\"18\":2,\"41\":1}}],[\"oyh的帮助\",{\"1\":{\"1\":1}}],[\"定义为\",{\"1\":{\"45\":1}}],[\"定义\",{\"0\":{\"11\":1}}],[\"具体讲解可以看这篇文章与这篇文章\",{\"1\":{\"10\":1}}],[\"包括其定义\",{\"1\":{\"10\":1}}],[\"choose\",{\"1\":{\"48\":2}}],[\"choose=zeros\",{\"1\":{\"47\":1}}],[\"changes\",{\"1\":{\"18\":1}}],[\"clear\",{\"1\":{\"47\":1}}],[\"clc\",{\"1\":{\"47\":1}}],[\"crowds\",{\"1\":{\"41\":1}}],[\"current\",{\"1\":{\"18\":1}}],[\"cell\",{\"1\":{\"18\":7}}],[\"cellular\",{\"0\":{\"10\":1},\"1\":{\"11\":1,\"18\":2,\"41\":1}}],[\"complete\",{\"1\":{\"18\":1}}],[\"computing\",{\"1\":{\"18\":2}}],[\"conway于\",{\"1\":{\"17\":1}}],[\"content\",{\"1\":{\"6\":1,\"7\":1,\"21\":1,\"22\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"53\":1,\"54\":1,\"58\":1,\"59\":1}}],[\"cat\",{\"1\":{\"47\":2}}],[\"can\",{\"1\":{\"18\":1}}],[\"ca\",{\"1\":{\"11\":1,\"12\":1,\"16\":1,\"40\":2,\"41\":2}}],[\"3\",{\"0\":{\"7\":1,\"22\":1,\"27\":1,\"32\":1,\"37\":1,\"54\":1,\"59\":1},\"1\":{\"17\":2,\"47\":2,\"48\":14}}],[\"i+neigh\",{\"1\":{\"48\":1}}],[\"if\",{\"1\":{\"48\":3}}],[\"i=2\",{\"1\":{\"48\":1}}],[\"i=1\",{\"1\":{\"48\":2}}],[\"i\",{\"1\":{\"45\":5,\"47\":7,\"48\":18}}],[\"it\",{\"1\":{\"18\":1,\"41\":1}}],[\"is\",{\"1\":{\"6\":1,\"7\":1,\"18\":1,\"21\":1,\"22\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"53\":1,\"54\":1,\"58\":1,\"59\":1}}],[\"inf\",{\"1\":{\"48\":1}}],[\"infj绿老头一枚\",{\"1\":{\"3\":1}}],[\"includes\",{\"1\":{\"18\":1}}],[\"in\",{\"1\":{\"18\":2,\"41\":2}}],[\"introduction\",{\"0\":{\"0\":1}}],[\"2×n\",{\"1\":{\"48\":1}}],[\"20\",{\"1\":{\"11\":1,\"47\":2}}],[\"2\",{\"0\":{\"6\":1,\"21\":1,\"26\":1,\"31\":1,\"36\":1,\"53\":1,\"58\":1},\"1\":{\"16\":1,\"17\":1,\"47\":10,\"48\":24}}],[\"算法\",{\"0\":{\"5\":1,\"20\":1}}],[\"算法整理\",{\"1\":{\"4\":1}}],[\"arrive=0\",{\"1\":{\"47\":1}}],[\"architectural\",{\"1\":{\"41\":1}}],[\"aspects\",{\"1\":{\"41\":1}}],[\"applications\",{\"1\":{\"18\":1,\"41\":1}}],[\"at\",{\"1\":{\"18\":1}}],[\"alive\",{\"1\":{\"18\":1}}],[\"and\",{\"1\":{\"18\":4,\"41\":3}}],[\"automaton\",{\"1\":{\"18\":2}}],[\"automata\",{\"0\":{\"10\":1},\"1\":{\"11\":2,\"18\":1,\"41\":1}}],[\"a\",{\"0\":{\"5\":1},\"1\":{\"18\":4}}],[\"about\",{\"1\":{\"1\":1}}],[\"感谢你看到这里\",{\"1\":{\"4\":1}}],[\"❤️\",{\"1\":{\"4\":2}}],[\"记录时刻平台信息\",{\"1\":{\"47\":1}}],[\"记录博主更新历程及计划\",{\"1\":{\"4\":1}}],[\"记录自我英语学习过程\",{\"1\":{\"4\":1}}],[\"总结自己参加数模比赛过程中\",{\"1\":{\"4\":1}}],[\"数模\",{\"1\":{\"4\":1}}],[\"主要为自学ml笔记及代码\",{\"1\":{\"4\":1}}],[\"主要记录本专业一些基础模型的代码实现\",{\"1\":{\"4\":1}}],[\"机器学习\",{\"1\":{\"4\":1}}],[\"交通管理\",{\"1\":{\"41\":1}}],[\"交通\",{\"1\":{\"4\":1},\"2\":{\"8\":1,\"19\":1,\"23\":1,\"28\":1,\"33\":1,\"38\":1,\"50\":1,\"55\":1,\"60\":1}}],[\"随笔等其他内容\",{\"1\":{\"4\":1}}],[\"乐评\",{\"1\":{\"4\":1}}],[\"自然模型\",{\"1\":{\"41\":1}}],[\"自学内容的整理等\",{\"1\":{\"4\":1}}],[\"自我感觉是一个矛盾体\",{\"1\":{\"3\":1}}],[\"自我评价\",{\"1\":{\"3\":1}}],[\"小研究\",{\"1\":{\"4\":1}}],[\"指南\",{\"0\":{\"4\":1}}],[\"国足进世界杯\",{\"1\":{\"3\":1}}],[\"国家队比赛\",{\"1\":{\"3\":1}}],[\"统一\",{\"1\":{\"3\":1}}],[\"t\",{\"1\":{\"48\":4}}],[\"total\",{\"1\":{\"47\":1}}],[\"total=960\",{\"1\":{\"47\":1}}],[\"triggering\",{\"1\":{\"18\":1}}],[\"traffic\",{\"0\":{\"63\":1},\"1\":{\"41\":1},\"2\":{\"9\":1,\"24\":1,\"29\":1,\"34\":1,\"39\":1,\"51\":1,\"56\":1,\"61\":1}}],[\"time\",{\"1\":{\"18\":1,\"47\":1}}],[\"thereby\",{\"1\":{\"18\":1}}],[\"their\",{\"1\":{\"18\":1}}],[\"theory\",{\"1\":{\"11\":1,\"18\":1}}],[\"the\",{\"1\":{\"6\":1,\"7\":1,\"18\":3,\"21\":1,\"22\":1,\"26\":1,\"27\":1,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"41\":1,\"53\":1,\"54\":1,\"58\":1,\"59\":1}}],[\"twin\",{\"1\":{\"3\":1}}],[\"talk\",{\"1\":{\"1\":1}}],[\"冰岛\",{\"1\":{\"3\":1}}],[\"欧洲游\",{\"1\":{\"3\":1}}],[\"欧洲杯\",{\"1\":{\"3\":1}}],[\"欧冠\",{\"1\":{\"3\":1}}],[\"亚冠\",{\"1\":{\"3\":1}}],[\"现场看一次球赛\",{\"1\":{\"3\":1}}],[\"现场看一场lol比赛\",{\"1\":{\"3\":1}}],[\"看一次霉妈的演唱会\",{\"1\":{\"3\":1}}],[\"看待问题十分的现实\",{\"1\":{\"3\":1}}],[\"mesoscopic\",{\"1\":{\"41\":1}}],[\"microscopic\",{\"1\":{\"41\":1}}],[\"max\",{\"1\":{\"48\":3}}],[\"map\",{\"1\":{\"47\":6,\"48\":8}}],[\"map=ones\",{\"1\":{\"47\":1}}],[\"macroscopic\",{\"1\":{\"41\":1}}],[\"management\",{\"1\":{\"41\":1}}],[\"many\",{\"1\":{\"18\":1}}],[\"movement\",{\"1\":{\"41\":1}}],[\"modeling\",{\"1\":{\"41\":1}}],[\"model\",{\"1\":{\"18\":2,\"41\":2}}],[\"moore邻居选择示意图\",{\"1\":{\"45\":1}}],[\"moore\",{\"1\":{\"14\":2,\"17\":2,\"44\":1}}],[\"msi\",{\"1\":{\"3\":1}}],[\"myself\",{\"1\":{\"1\":1}}],[\"进入到梦中情组\",{\"1\":{\"3\":1}}],[\"探究生命的意义\",{\"1\":{\"3\":1}}],[\"却也逐渐看清了生活的本质\",{\"1\":{\"3\":1}}],[\"梦想很多\",{\"1\":{\"3\":1}}],[\"⚽\",{\"1\":{\"3\":1}}],[\"足球\",{\"1\":{\"3\":1}}],[\"吉他\",{\"1\":{\"3\":1}}],[\"唱歌\",{\"1\":{\"3\":1}}],[\"听歌\",{\"1\":{\"3\":1}}],[\"爱好\",{\"1\":{\"3\":1}}],[\"🎸\",{\"1\":{\"3\":1}}],[\"🎤\",{\"1\":{\"3\":1}}],[\"🎧\",{\"1\":{\"3\":1}}],[\"🍓\",{\"1\":{\"3\":1}}],[\"🏫\",{\"1\":{\"3\":1}}],[\"s\",{\"1\":{\"48\":6}}],[\"s=randsrc\",{\"1\":{\"48\":1}}],[\"sum\",{\"1\":{\"48\":2}}],[\"sm\",{\"1\":{\"47\":6}}],[\"sm=ones\",{\"1\":{\"47\":1}}],[\"short\",{\"1\":{\"47\":1}}],[\"size\",{\"1\":{\"47\":3,\"48\":5}}],[\"si\",{\"1\":{\"45\":2}}],[\"simulating\",{\"1\":{\"41\":1}}],[\"simulation\",{\"0\":{\"40\":1},\"1\":{\"18\":1,\"41\":1}}],[\"social\",{\"1\":{\"41\":1}}],[\"scnarios\",{\"1\":{\"41\":1}}],[\"star\",{\"1\":{\"47\":3}}],[\"state\",{\"1\":{\"3\":1,\"18\":4}}],[\"studies\",{\"1\":{\"41\":1}}],[\"step=1\",{\"1\":{\"47\":1}}],[\"step\",{\"1\":{\"18\":1}}],[\"set\",{\"1\":{\"18\":1}}],[\"space\",{\"1\":{\"18\":1}}],[\"s赛\",{\"1\":{\"3\":1}}],[\"swiftie\",{\"1\":{\"3\":1}}],[\"成分\",{\"1\":{\"3\":1}}],[\"水瓶座\",{\"1\":{\"3\":1}}],[\"星座\",{\"1\":{\"3\":1}}],[\"border\",{\"1\":{\"47\":5,\"48\":3}}],[\"border=ones\",{\"1\":{\"47\":1}}],[\"boundary\",{\"1\":{\"18\":1}}],[\"by\",{\"1\":{\"41\":1}}],[\"based\",{\"1\":{\"18\":1}}],[\"behavioral\",{\"1\":{\"41\":1}}],[\"be\",{\"1\":{\"18\":1}}],[\"bushi\",{\"1\":{\"3\":1}}],[\"blog就显得非常合适\",{\"1\":{\"2\":1}}],[\"blog\",{\"1\":{\"2\":1,\"4\":1}}],[\"对元胞潜能进行归一化\",{\"1\":{\"45\":1}}],[\"对行人流仿真进一步了解可以移步此篇论文\",{\"1\":{\"41\":1}}],[\"对于\",{\"1\":{\"17\":2}}],[\"对\",{\"1\":{\"3\":1}}],[\"一般常用为固定型和周期型边界条件\",{\"1\":{\"15\":1}}],[\"一般为二维\",{\"1\":{\"12\":1}}],[\"一个完整的元胞自动机模型包含\",{\"1\":{\"11\":1}}],[\"一枚\",{\"1\":{\"3\":1}}],[\"一名在读csuer\",{\"1\":{\"3\":1}}],[\"一时难以消化吸收\",{\"1\":{\"1\":1}}],[\"职业\",{\"1\":{\"3\":1}}],[\"我\",{\"0\":{\"3\":1}}],[\"我会逐步去完善\",{\"1\":{\"1\":1}}],[\"尝试新的记录生活的方式\",{\"1\":{\"2\":1}}],[\"走出舒适圈\",{\"1\":{\"2\":1}}],[\"而且复习过程中也苦于没有地方整理\",{\"1\":{\"2\":1}}],[\"学过的知识都记不清了\",{\"1\":{\"2\":1}}],[\"写过的很多代码\",{\"1\":{\"2\":1}}],[\"写在前面\",{\"0\":{\"1\":1}}],[\"发现自己之前做过的很多小项目\",{\"1\":{\"2\":1}}],[\"准备夏令营过程中\",{\"1\":{\"2\":1}}],[\"目前博客内容主要为过去做过的一些项目\",{\"1\":{\"4\":1}}],[\"目前小小的愿望清单\",{\"1\":{\"3\":1}}],[\"目前先尝试一个\",{\"1\":{\"2\":1}}],[\"目前还是处于入门小白阶段\",{\"1\":{\"1\":1}}],[\"音乐区up主\",{\"1\":{\"2\":1}}],[\"想当一个知识区博主\",{\"1\":{\"2\":1}}],[\"决定写\",{\"1\":{\"2\":1}}],[\"缘由\",{\"0\":{\"2\":1}}],[\"内容方面有待优化\",{\"1\":{\"1\":1}}],[\"布局\",{\"1\":{\"1\":1}}],[\"还有很多排版\",{\"1\":{\"1\":1}}],[\"📝\",{\"1\":{\"3\":1}}],[\"💭\",{\"1\":{\"3\":1}}],[\"👐\",{\"1\":{\"2\":1}}],[\"💖\",{\"1\":{\"1\":1}}],[\"👋\",{\"1\":{\"0\":1}}],[\"让我顺利解决了很多问题\",{\"1\":{\"1\":1}}],[\"过程中还遇到很多莫名其妙的小bug\",{\"1\":{\"1\":1}}],[\"很早就有的想法\",{\"1\":{\"2\":1}}],[\"很多新东西从未见过\",{\"1\":{\"1\":1}}],[\"很麻烦\",{\"1\":{\"1\":1}}],[\"刚开始的过程确实很难\",{\"1\":{\"1\":1}}],[\"所以需要分别计算四个出口的元胞潜力大小\",{\"1\":{\"48\":1}}],[\"所以最后\",{\"1\":{\"45\":1}}],[\"所以便有了现在这个页面\",{\"1\":{\"1\":1}}],[\"所以迟迟不肯行动\",{\"1\":{\"1\":1}}],[\"觉得还是要尝试些新东西\",{\"1\":{\"1\":1}}],[\"但还是希望自己未来能成为一个有用之人\",{\"1\":{\"3\":1}}],[\"但还好有dream\",{\"1\":{\"1\":1}}],[\"但同时也是一个理想的完美主义者\",{\"1\":{\"3\":1}}],[\"但痛定思痛\",{\"1\":{\"1\":1}}],[\"但总感觉很难\",{\"1\":{\"1\":1}}],[\"欢迎来到我的博客\",{\"1\":{\"0\":1}}],[\"简介\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
