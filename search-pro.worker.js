const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":96,\"nextId\":96,\"documentIds\":{\"0\":\"1\",\"1\":\"1#写在前面-prologue\",\"2\":\"1#缘由-reason\",\"3\":\"1#我-myself\",\"4\":\"1#指南-navigation\",\"5\":\"2\",\"6\":\"2#基本概念\",\"7\":\"2@0\",\"8\":\"3\",\"9\":\"3#基本概念\",\"10\":\"3#一、绪论\",\"11\":\"3#二、模型评估与选择\",\"12\":\"3#三、线型模型\",\"13\":\"3#四、决策树\",\"14\":\"3#五、神经网络\",\"15\":\"3#六、支持向量机-svm\",\"16\":\"3#七、聚类-cluster\",\"17\":\"3#八、降维\",\"18\":\"3#_1-what-is-regularization\",\"19\":\"3#_2-what-is-cross-validation\",\"20\":\"3#_3-pca-principle\",\"21\":\"3#_4-k-means-principle\",\"22\":\"3#_5-support-vector-machine-principle\",\"23\":\"3#_6-decision-tree-principle\",\"24\":\"3@0\",\"25\":\"4\",\"26\":\"4#大语言模型-foudation-model\",\"27\":\"4#sora-模型对于交通行业影响\",\"28\":\"5\",\"29\":\"6\",\"30\":\"6#_1-1-what-is-planning\",\"31\":\"6#_1-2-basic-ingredients-of-planning\",\"32\":\"6#_1-3-organization-of-this-book\",\"33\":\"6@0\",\"34\":\"7\",\"35\":\"7#_2-1-introduction-to-discrete-feasible-planning\",\"36\":\"7#_2-1-1-problem-formulation\",\"37\":\"7#_2-1-2-examples-of-discrete-planning\",\"38\":\"7#_2-2-searching-for-feasible-plans\",\"39\":\"7#_2-2-1-general-forward-search\",\"40\":\"7#_2-2-2-particular-forward-search-methods\",\"41\":\"7#_2-2-3-other-general-search-schemes\",\"42\":\"7#_2-2-4-a-unified-view-of-the-search-methods\",\"43\":\"7#_2-3-discrete-optimal-planning\",\"44\":\"7#_2-3-1-optimal-fixed-length-plans\",\"45\":\"7#_2-3-1-1-backward-value-iteration\",\"46\":\"7#_2-3-1-2-forward-value-iteration\",\"47\":\"7#_2-3-2-optimal-plans-of-unspecified-lengths\",\"48\":\"7#_2-3-3-dijkstra-revisited\",\"49\":\"7#_2-4-using-logic-to-formulate-discrete-planning\",\"50\":\"7#_2-4-1-a-strips-like-representation\",\"51\":\"7@0\",\"52\":\"8\",\"53\":\"8#定义-definition\",\"54\":\"8#元胞-cell\",\"55\":\"8#元胞空间-space\",\"56\":\"8#元胞邻居-neighbour\",\"57\":\"8#边界条件-boundary\",\"58\":\"8#元胞规则-rule\",\"59\":\"8#生命游戏-the-game-of-life\",\"60\":\"8#应用-application\",\"61\":\"8@0\",\"62\":\"9\",\"63\":\"9#_1-基本概念\",\"64\":\"9#_1-1-nagel–schreckenberg-model-ns模型\",\"65\":\"9#_1-2-rule-184\",\"66\":\"9#_1-3-phantom-traffic-jam-幽灵拥堵\",\"67\":\"9#_1-4-基本图-fundamental-diagram\",\"68\":\"9#_2-model-description-模型描述\",\"69\":\"9#_2-1-model-information-模型说明\",\"70\":\"9#_2-2-model-step-更新规则\",\"71\":\"9#_3-改进ns模型-ns-model-for-inhomogenous-traffic-flow-in-a-single-lane\",\"72\":\"9#_3-1-改进点\",\"73\":\"9#_3-2-模型信息\",\"74\":\"9#_3-3-结果\",\"75\":\"9#_3-4-代码\",\"76\":\"9#_3-5-进一步的改进点\",\"77\":\"9@0\",\"78\":\"9@1\",\"79\":\"10\",\"80\":\"10#概述\",\"81\":\"10#问题描述\",\"82\":\"10#模型设置\",\"83\":\"10#基本设置\",\"84\":\"10#更新规则\",\"85\":\"10#部分代码解释\",\"86\":\"10#参数设置\",\"87\":\"10#参数计算\",\"88\":\"10#结果\",\"89\":\"10@0\",\"90\":\"10@1\",\"91\":\"11\",\"92\":\"12\",\"93\":\"13\",\"94\":\"14\",\"95\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,3],\"1\":[1,30],\"2\":[1,21],\"3\":[1,65],\"4\":[1,20],\"5\":[1,1],\"6\":[1,152],\"7\":[null,null,1],\"8\":[1,1],\"9\":[1,21],\"10\":[2,213],\"11\":[2,181],\"12\":[2,34],\"13\":[2,30],\"14\":[2,54],\"15\":[3,123],\"16\":[3,83],\"17\":[2,26],\"18\":[5,55],\"19\":[6,62],\"20\":[3,64],\"21\":[4,62],\"22\":[5,67],\"23\":[4,76],\"24\":[null,null,1],\"25\":[4,2],\"26\":[1,59],\"27\":[2,76],\"28\":[4,80],\"29\":[3,23],\"30\":[5,23],\"31\":[6,204],\"32\":[6,20],\"33\":[null,null,1],\"34\":[4],\"35\":[7],\"36\":[4,33],\"37\":[6,121],\"38\":[5,43],\"39\":[5,123],\"40\":[5,143],\"41\":[6,94],\"42\":[9,108],\"43\":[5,123],\"44\":[7,42],\"45\":[6,198],\"46\":[6,142],\"47\":[7,276],\"48\":[4,239],\"49\":[8,50],\"50\":[7,278],\"51\":[null,null,1],\"52\":[3,6],\"53\":[1,28],\"54\":[1,12],\"55\":[1,10],\"56\":[1,26],\"57\":[1,17],\"58\":[1,22],\"59\":[1,40],\"60\":[1,63],\"61\":[null,null,1],\"62\":[1,3],\"63\":[2],\"64\":[5,26],\"65\":[4,9],\"66\":[6,78],\"67\":[5,21],\"68\":[4],\"69\":[5,55],\"70\":[4,127],\"71\":[12],\"72\":[4,43],\"73\":[3,8],\"74\":[2,100],\"75\":[3,3],\"76\":[3,43],\"77\":[null,null,1],\"78\":[null,null,1],\"79\":[3,7],\"80\":[1,160],\"81\":[1,21],\"82\":[1],\"83\":[1,15],\"84\":[1,69],\"85\":[1,3],\"86\":[1,111],\"87\":[1,138],\"88\":[1,6],\"89\":[null,null,1],\"90\":[null,null,1],\"91\":[1,3],\"92\":[1],\"93\":[1],\"94\":[1],\"95\":[1]},\"averageFieldLength\":[3.1782743926887385,67.64650817487835,0.2500513372201188],\"storedFields\":{\"0\":{\"h\":\"简介 Introduction\",\"t\":[\"👋 欢迎来到我的博客！\"]},\"1\":{\"h\":\"写在前面\",\"t\":[\"其实很早就萌生过写 blog 的想法，但总感觉很难，很麻烦，不想走出舒适圈，所以迟迟不肯行动。\",\"但痛定思痛，觉得还是要尝试些新东西，所以便有了现在这个页面。\",\"刚开始的过程确实很难，很多新东西从未见过，一时难以消化吸收，过程中还遇到很多莫名其妙的小 bug。\",\"但还好有dream-oyh的帮助，让我顺利解决了很多问题，在此表示十分感谢！💖\",\"目前还是处于入门小白阶段，还有很多排版、布局、内容方面有待优化，我会逐步去完善。\",\"下面来 talk about myself。\"]},\"2\":{\"h\":\"缘由\",\"t\":[\"👐 决定写 blog 原因大致有以下几点：\",\"很早就有的想法（想当一个知识区博主、音乐区 up 主），目前先尝试一个。\",\"准备夏令营过程中，发现自己之前做过的很多小项目、写过的很多代码、学过的知识都记不清了，如果之前有所记录就很便于回忆，而且复习过程中也苦于没有地方整理，blog 就显得非常合适。\",\"周边盆友的影响👬。\",\"走出舒适圈，尝试新的记录生活的方式。\"]},\"3\":{\"h\":\"我\",\"t\":[\"职业： 一名在读 CSUer 🏫，对，就是那个California State University(bushi)。即将变为SJTUer.\",\"星座： 水瓶座 \",\"成分： Swiftie 🍓 一枚。\",\"人格： INFJ 绿老头一枚。(有点变化)\",\"爱好： LOL、听歌 🎧、唱歌 🎤、吉他 🎸、足球 ⚽。\",\"自我评价：自我感觉是一个矛盾体，看待问题十分的现实，但同时也是一个理想的完美主义者；绝对的宿命论主义倾向；梦想很多，却也逐渐看清了生活的本质，但还是希望自己未来能成为一个有用之人，探究生命的意义，世界之本质 💭 。\",\"📝 目前小小的愿望清单\",\"[✓] 进入到梦中情组\",\" 现场看一场 LOL 比赛(S 赛/MSI/EDG 比赛)\",\" 看一次霉妈的演唱会\",\" 现场看一次球赛（世界杯/国家队比赛/亚冠/欧冠/欧洲杯......）\",\" 冰岛/欧洲游\",\"twin flame who？\",\" 统一\",\" 国足进世界杯\"]},\"4\":{\"h\":\"指南\",\"t\":[\"目前博客内容主要为过去做过的一些项目、小研究、自学内容的整理等，有时间也会加入书评、乐评、随笔等其他内容。\",\"交通 主要记录本科专业一些相关学习内容。\",\"机器学习 主要为自学 ML 笔记及代码。\",\"路径规划 纪录读研阶段学习内容。\",\"英语 读研期间英语学习的纪录。\",\"Myself 博主的自我介绍。\",\"❤️ 感谢你看到这里 ❤️\"]},\"5\":{\"h\":\"卷积\",\"t\":[\"本节整理卷积方面基本概念\"]},\"6\":{\"h\":\"基本概念\",\"t\":[\"卷积：卷积就是用一个可移动的窗口（卷积核），按一定步长，与图像对应元素进行点乘相加的操作。卷积本质上也是一种对数据维度的变换，提取图像的特征，相较于全连接层直接把图像展开成一个行向量，其能更好地捕获图像的空间特征，当然通过改变参数的形状，任何全连接层都能被转换为一个等价卷积层。\",\"Convolution: Convolution is to use a movable window (convolution kernel) to perform a dot multiplication and addition operation with the corresponding elements of the image at a certain step size. Convolution is essentially a transformation of the data dimension to extract the features of the image. Compared with the fully connected layer that directly expands the image into a row vector, it can better capture the spatial features of the image. Of course, by changing the shape of the parameters, any fully connected layer can be converted into an equivalent convolution layer.\",\"池化：一种下采样方式，池化层的引入是仿照人的视觉系统对视觉输入对象进行降维（reduce demention）和抽象（abstract）。主要有三个功效：\",\"特征不变性：池化操作是模型更加关注是否存在某些特征而不是特征具体的位置。其中不变形性包括，平移不变性、旋转不变性和尺度不变性。平移不变性是指输出结果对输入对小量平移基本保持不变，例如，输入为(1, 5, 3), 最大池化将会取 5，如果将输入右移一位得到(0, 1, 5)，输出的结果仍将为 5。对伸缩的不变形，如果原先的神经元在最大池化操作后输出 5，那么经过伸缩（尺度变换）后，最大池化操作在该神经元上很大概率的输出仍是 5；\",\"特征降维（下采样）：池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。\",\"在一定程度上防止过拟合，更方便优化。\",\"实现非线性（类似 relu）。\",\"扩大感受野。\",\"上采样：放大图像，反卷积/转置卷积。\",\"下采样：缩小图像，如池化与步长为 2 的卷积。\",\"relu 激活函数：负为 0，正 y=x\",\"采用原因：\",\"第一，采用 sigmoid 等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用 Relu 激活函数，整个过程的计算量节省很多。\",\"第二，对于深层网络，sigmoid 函数反向传播时，很容易就会出现梯度消失的情况（在 sigmoid 接近饱和区时，变换太缓慢，导数趋于 0，这种情况会造成信息丢失），从而无法完成深层网络的训练。\",\"第三，ReLu 会使一部分神经元的输出为 0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。\"]},\"7\":{\"c\":[\"ML\"]},\"8\":{\"h\":\"机器学习\",\"t\":[\"本节整理机器学习的基本问题\"]},\"9\":{\"h\":\"基本概念\",\"t\":[\"magnitude: 幅度 order of magnitude：数量级 converge: 收敛 oscillate: 振荡 fit: 拟合 fine-tune: 调参 generalization ability：泛化能力 dimension: 量纲 deviation：偏离\"]},\"10\":{\"h\":\"一、绪论\",\"t\":[\"什么是机器学习和深度学习？ 机器学习是一种实现人工智能的方法。人工智能是想要达成的目标，而机器学习是想要达成目标的手段：希望机器通过学习的手段，可以跟人一样聪明。机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使不断改善自身的性能。而深度学习，就是机器学习的其中一种方法。\",\"机器学习流程？ **表示 represent：**将数据对象进行特征(feature)化表示\",\"**训练 train：**给定一个数据样本集，从中学习出规律（模型），目标：该规律不仅适用于训练数据，也适用于未知数据(称为泛化能力)\",\"**测试 test：**对于一个新的数据样本，利用学到的模型进行预测\",\"在机器学习中，学习率这种参数叫什么？学习率太大和太小的可能影响？\",\"学习率(learning rate)也叫步长，指更新参数步幅。表征了参数每次更新的幅度（represent the magnitude of parameter update）\",\"If the learning rate is too large, the gradient descent algorithm will not converge and will diverge or oscillate; if the learning rate is too small, the gradient descent algorithm will converge very slowly.\",\"根据学习方式的划分，机器学习三个主要分类是什么？请简要说明他们之间的关系。 划分为三个主要分类：监督学习、非监督学习、强化学习。关系见下\",\"简述监督学习，非监督学习以及强化学习的定义和区别？ 定义：\",\"（1）监督学习：是一种通过使用已知输出来训练模型的学习方式。在监督学习中，训练数据包括输入数据和对应的输出数据（也称为标签或目标），算法通过学习这些数据，建立输入和输出之间的映射关系，以预测新的输入数据的输出。监督学习通常用于分类（分类器）和回归（回归器）问题。\",\"（2）非监督学习：是一种在没有标签或目标的情况下，从数据中发现模式或结构的学习方式。在非监督学习中，算法只能使用输入数据进行学习，目标是找到输入数据之间的相似性和区别，以便对数据进行聚类、降维、异常检测等操作。\",\"（3）强化学习：又称为再励学习，是指从环境状态到行为映射的学习，使系统行为从环境中获得的累积奖励值最大的一种机器学习方法。\",\"区别：\",\"（1）监督学习有反馈，无监督学习无反馈，强化学习执行多步后反馈；\",\"（2）强化学习的目标与监督学习目标不同，强化学习看重行为序列下的长期收益，监督学习关注与标签或已知输出的误差；\",\"（3）强化学习的奖惩概念没有正确和错误之分，而监督学习的标签是正确的。 强化学习是一个学习+决策的过程，有和环境交互的能力，监督学习不具备。\",\"简要说明监督学习和非监督学习之间的区别，并分别给出监督和非监督学习的两种算法。\",\"区别\",\"监督学习和非监督学习是机器学习中两种不同的学习方式。监督学习需要已知的输入和输出数据，目标是学习输入 和输出之间的映射关系。非监督学习只需要输入数据，目标是从数据中发现模式和结构，而不需要预先定义的目标 变量。在实际应用中，监督学习和非监督学习常常结合使用，以提高机器学习的效果和性能。\",\"举例\",\"常见的监督学习算法包括线性回归（linear regression）、逻辑回归(logistic regression)、决策树(decision tree)、支持向量机(support vector machine)、朴素贝叶斯、神经网络等。\",\"常见的非监督学习算法包括聚类、主成分分析（Principle Component Analysis）、独立成分分析（ICA）、自编码器、变分自编码器等。\",\"训练集、测试集、验证集区别联系？\",\"训练集:用于模型拟合的数据样本,即用于训练的样本集合,主要用来训练神经网络中的参数; train\",\"验证集：模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估; tuning\",\"测试集：用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。 evaluate\",\"各数据集的作用\",\"训练集的作用\",\"拟合模型，调整网络权重。\",\"验证集的作用\",\"作用 1：快速调参，也就是通过验证集我们可以选择超参数（网络层数、网络节点数、迭代次数 epoch、学习率 learning rate、优化器）等。\",\"作用 2：选择超参数，为了让我们的模型在测试集表现得更好，调参是不可避免地一部分，如果把测试集当验证集，调参去拟合测试集合，是不可行地，这相当于作弊。\",\"作用 3：监控模型是否正常\",\"验证集的重要性\",\"如果没有设置验证集，我们通常得等到测试集才可以知道我们模型真正得实力，然后再来调整参数，这样子时间代价较高，通过验证集我们可以训练几个 epoch 后查看模型的训练效果及我们的网络是否出现异常，然后决定怎么调整我们的超参数。\",\"测试集的作用\",\"仅仅用来评估模最终模型的泛化能力，确认网络的实际预测能力。\",\"什么是泛化性能？（generalization ability） 是指机器学习算法对新鲜样本的适应能力。 学习的目的是学到隐含在数据背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。\",\"在数据处理时，为什么通常要进行标准化处理 在实际问题中，我们使用的样本通常是多维数据，每一维对应一个特征，这些特征的量纲和数量级都是不一样的 这时需要对数据进行标准化处理，使得所有的特征具有同样的尺度。\"]},\"11\":{\"h\":\"二、模型评估与选择\",\"t\":[\"过拟合、欠拟合定义、原因、解决办法？\",\"（1）定义：\",\"过拟合：学习器把训练样本学习的“太好”，将训练样本本身的特点当做所有（潜在）样本（都会具有）的一般性质，导致泛化性能下降。\",\"欠拟合：训练样本的一般性质尚未学好，在训练样本上都存在较大的经验误差。\",\"（2）原因：\",\"过拟合原因： 1）模型复杂度过低 2）特征量过少 3）训练样本过少\",\"欠拟合原因： 1）训练集的数量级 N 与模型复杂度 M 不匹配 2）训练集与测试集的特征分布不一致 3）样本噪声过多，模型过分记住了噪声，忽略了真实的输入输出 4）权值学习迭代次数过多，拟合了不具代表性的特征\",\"（3）解决办法：\",\"过拟合: 1）清洗数据 2）减小模型复杂度 3）增广训练集 4）交叉验证 5）正则化 regularization，约束模型特征 6）early stopping 迭代次数截断 7）dropout，让一些神经元以一定的概率不工作.\",\"欠拟合应对： 1）增加新特征 2）增加模型复杂度，如决策树的扩展分支，神经网络的训练轮数等 3）扩大训练集。\",\"错误率及误差概念？\",\"错误率 & 误差：\",\"（1）错误率：错分样本的占比\",\"（2）误差：样本真实输出与预测输出之间的差异\",\"（3）训练(经验)误差： 训练集上\",\"（4）测试误差： 测试集上\",\"（5）泛化误差： 除训练集外所有样本\",\"评估方法\",\"留出法、交叉验证法（k=m 时是留一法）、自助法等。\",\"交叉验证法和自助法异同？\",\"相同点\",\"交叉验证法和自助法都是随机采样法。它们作为人工智能中评估模型的方法，根据一定规则从数据集 D 中划分训练集和测试（验证）集，从而评价模型在数据集上的表现，便于我们选择合适的模型。\",\"不同点\",\"这两种方法最大的不同点在于每次划分过程中每个样本点是否只有一次被划入训练集或测试集的机会。下面将针对这方面详细展开论述：\",\"交叉验证法采用的是无放回的随机采样方式，这种方式可以保持数据分布的一致性条件，并严格划分训练集与测试集的界限，从而增强测试评估的稳定性和可靠性。\",\"自助法主要面向数据集同规模的划分问题。其采用的是有放回的随机抽样方法，可以使得得到的模型更为稳健，解决了交叉验证法中模型选择阶段和最终模型训练阶段的训练集规模差异问题；但训练集 T 和原始数据集 D 中数据的分布未必相一致，因此对一些对数据分布敏感的模型选择并不适用。\",\"偏差、方差、噪声含义？\",\"偏差度量了学习算法期望预测与真实结果的偏离程度: 即刻画了学习法本身的拟合能力;\",\"方差度量了同样大小训练集的变动所导致的学习性能的变化: 即刻画了数据扰动所造成的影响;\",\"噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界即刻画了学习问题本身的难度。\",\"Bias measures the degree of deviation between the expected prediction of the learning algorithm and the actual result: it depicts the fitting ability of the learning method itself;\",\"Variance measures the change in learning performance caused by changes in the same size training set: it depicts the impact of data perturbations;\",\"Noise expresses the lower bound of the expected generalization error that any learning algorithm can achieve on the current task, which depicts the difficulty of the learning problem itself.\",\"偏差-方差分解角度解释泛化性能 泛化性能是出学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务为了取得好的泛化性能，需要使偏差小(充分拟合数据)而且方差较小(减少数据扰动产生的影响)。\",\"偏差方差冲突 PPT P9\",\"8．请给出你对泛化误差的理解\",\"泛化误差 = 偏差+方差+噪声\",\"偏差：度量了学习算法的期望预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力\",\"方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响\",\"噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度\"]},\"12\":{\"h\":\"三、线型模型\",\"t\":[\"线型模型优势与不足？ 优势：第三章 3.1.2 P1 不足： 第三章 3.2.7 P10\",\"什么是回归（分析）？ 第三章 3.2 P2\",\"简述 LDA 算法的基本思想及算法流程。\",\"基本思想是将高维的模式样本投影到最佳鉴别矢量空间，以达到抽取分类信息和压缩特征空间维数的效果，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离,即模式在该空间中有最佳的可分离性。 流程：\",\"逻辑回归和线性回归的异同\",\"不同之处：\",\"（1）逻辑回归解决的是分类问题，因此因变量是离散的；而线性回归解决的是回归问题，因此因变量是连续的。这是两者最本质的区别；\",\"（2）在自变量和超参数确定的情况下逻辑回归可看作广义的线性模型在因变量下服从二元分布的一个特殊情况\",\"（3）使用最小二乘法求解线性回归时我们认为因变量服从正态分布。\",\"相同之处：\",\"（1）二者在求解超参数的过程中都使用梯度下降的方法 ；\",\"（2）二者都使用了极大似然估计对训练样本进行建模。\"]},\"13\":{\"h\":\"四、决策树\",\"t\":[\"决策树三种导致递归返回的情况\",\"PPT 第四章 4.1 P1\",\"决策树中剪枝方式分为哪两种？请简述这两种方式的优缺点？\",\"预剪枝（prepruning）和后剪枝(postpruning)。\",\"预剪枝\",\"优点：降低过拟合风险，显著降低训练时间和测试时间的开销。\",\"缺点：有些分支当前划分虽然不能提升泛化性能，但在其基础上进行的后续划分有可能使得性能显著提高，预剪枝基于“贪心”，禁止这些分支展开，有欠拟合风险。\",\"后剪枝\",\"优点：比预剪枝保留了更多分支，欠拟合风险小，泛化性能更好。\",\"缺点：训练时间开销大，后剪枝过程是在生成完全的决策树之后，自底向上对所有非叶节点逐一考察。\"]},\"14\":{\"h\":\"五、神经网络\",\"t\":[\"在神经网络中，非线性激活函数的主要作用是什么？请给出常用的几种非线性激活函数及其导数；\",\"激活函数（activation function）可以加入非线性因素，解决线性模型所不能解决的问题。激活函数是神经网络的一个重要组成部分。如果不使用激活函数，则无论该神经网络有多少层，最终的输出都是输入的线性组合，与没有隐藏层的效果相当，这种情况就是最原始的感知机（perceptron），无法解决线性不可分问题。\",\"神经网络分类\",\"神经网络根据是否存在网络回路（联接方式），可以分为：前向型和反馈型。 按学习方式：有导师的学习（监督学习）、无导师的学习（无监督学习）、再励学习（强化学习），具体解释： PPT 第五章 P6-7\",\"神经网络与人脑相比计算特能力特点： PPT 第五章 P5\",\"简述神经网络的学习过程 PPT 第五章 P5\",\"简要介绍卷积概念及其作用、池化的作用是什么？卷积前后图像尺寸之间的关系是什么？\",\"简述神经网络中梯度下降方法的原理和作用（作用请从机器学习训练阶段的三个步骤的角度来阐述）。 梯度下降方法的原理：梯度下降方法通过求出损失函数在某点对于参数 θ 的微分值，并以负梯度方向为搜索方向，沿着梯度下降的方向求解极小值；作用是在训练阶段的第三个步骤中，通过梯度下降来寻找更优的学习参数 b 和 w，达到优化模型的效果。\"]},\"15\":{\"h\":\"六、支持向量机 SVM\",\"t\":[\"试述硬间隔、软间隔、基于核函数的 SVM 的原理、优缺点、三者最终计算方式以及限制条件。 硬间隔 SVM：\",\"原理：硬间隔 SVM 假设数据本身是线性可分的，即存在一个超平面可以将不同类别的样本完全分开。这个超平面需要满足离其最近的点到其的距离最大化。\",\"优点：简单明了，适用于线性可分的数据集。\",\"缺点：对于非线性可分的数据集，硬间隔 SVM 无法找到一个有效的超平面。此外，硬间隔 SVM 对异常点非常敏感，因为异常点可能导致无法找到一个满足所有约束条件的超平面。\",\"软间隔 SVM：\",\"原理：软间隔 SVM 放松了对数据线性可分的假设，允许在某些情况下出现分类错误。软间隔 SVM 通过引入松弛变量来处理噪声和异常点。通过调整这些变量，可以控制对分类错误的容忍程度。\",\"优点：能够处理非线性可分的数据集和噪声数据。\",\"缺点：需要调整松弛变量和惩罚参数，以找到最佳的分类效果。\",\"基于核函数的 SVM：\",\"原理：对于非线性可分的数据集，基于核函数的 SVM 通过使用核函数将输入空间映射到高维特征空间，使得在高维特征空间中数据变得线性可分。常用的核函数有线性核、多项式核和 RBF 核（高斯核）。\",\"优点：能够处理非线性可分的数据集。\",\"缺点：选择合适的核函数和参数是一个挑战，同时计算复杂度可能会较高。\",\"SVM 与 logistic 回归区别联系\",\"相同点:\",\"都是分类算法 如果不考虑核函数，LR 和 SVM 都是线性分类算法 LR 和 SVM 都是监督学习算法。 LR 和 SVM 都是判别模型.\",\"不同点:\",\"本质上是其 loss function 不同 支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局. 在解决非线性问题时，支持向量机采用核函数的机制，而 LR 通常不采用核函数的方法 线性 SVM 依赖数据表达的距离测度，所以需要对数据先做 normalization，LR 不受其影响。 SVM 的损失函数就自带正则。\",\"SVM、logistic 回归、决策树各自优缺点\",\"逻辑回归\",\"逻辑回归的优点：\",\"（1）便利的观测样本概率分数；\",\"（2）已有工具的高效实现；\",\"（3）对逻辑回归而言，多重共线性并不是问题，它可以结合 L2 正则化来解决；\",\"（4）逻辑回归广泛的应用于工业问题上（这一点很重要）。\",\"逻辑回归的缺点： （1）当特征空间很大时，逻辑回归的性能不是很好；\",\"（2）不能很好地处理大量多类特征或变量；\",\"（3）对于非线性特征，需要进行转换；\",\"（4）依赖于全部的数据（个人觉得这并不是一个很严重的缺点）。\",\"决策树\",\"（1）直观的决策规则\",\"（2）可以处理非线性特征\",\"（3）考虑了变量之间的相互作用\",\"（4）训练集上的效果高度优于测试集，即过拟合[随机森林克服了此缺点\",\"（5）没有将排名分数作为直接结果\",\"SVM\",\"SVM 的优点：\",\"（1）能够处理大型特征空间\",\"（2）能够处理非线性特征之间的相互作用\",\"（3）无需依赖整个数据\",\"SVM 的缺点：\",\"（1）当观测样本很多时，效率并不是很高\",\"（2）有时候很难找到一个合适的核函数\",\"为什么要引入对偶问题? （1）对偶问题将原始问题中的约束转为了对偶问题中的等式约束。\",\"（2）改变了问题的复杂度。由求特征向量转化为求比例系数。在原始问题下，求解的复杂度与样本的维度有关即 w 的维度。在对偶问题下，求解的是 a，复杂度只与样本数量有关。\",\"（3）可以自然地引入核函数，从而推广到非线性分类问题\"]},\"16\":{\"h\":\"七、聚类 Cluster\",\"t\":[\"聚类方法分类？\",\"无监督学习方法主要有两大类：基于概率密度函数的估计方法和基于样本间相似性度量的间接聚类方法。\",\"K-means、层次聚类、DBSCAN 聚类方法原理、区别、优缺点\",\"K-means 聚类\",\"工作原理： K-means 算法将数据划分为 K 个簇，每个簇包含最接近其质心的数据点。它通过迭代地将数据点分配给最近的质心并更新质心来执行聚类。\",\"优点： 简单且高效，适用于大型数据集。它的结果易于解释和可视化。\",\"缺点：需要事先指定簇数 K。对于非球形簇或具有不同密度的簇效果较差。\",\"层次聚类\",\"工作原理： 层次聚类将数据集逐渐分割或合并成不同的层次簇。它可以是自底向上的聚合聚类（凝聚型）或自顶向下的分裂聚类（分裂型）。\",\"优点： 不需要预先指定簇数，可视化结果以树状结构呈现，对不同形状的簇和噪声具有较好的鲁棒性。\",\"缺点：不具有很好的可伸缩性: 时间复杂性至少是 0(n^2)，其中 n 对象总数。合并或分裂的决定需要检查和估算大量的对象或簇。不能撤消已做的处理，聚类之间不能交换对象。如果某一步没有很好地选择合并或分裂的决定，可能会导致低质量的聚类结果\",\"DBSCAN（密度聚类）\",\"工作原理： DBSCAN 根据数据点的密度将它们分为核心点、边界点和噪声点。核心点是在指定半径范围内有足够多邻居的点，它们被用于扩展簇。\",\"优点： 可以对任意形状的稠密数据集进行聚类。可以在聚类的同时发现异常点，对数据集异常点不敏感。聚类结果没有偏倚。\",\"缺点： 对参数的选择敏感，可能需要调整半径参数和最小邻居数。对高维数据和不均匀密度数据的处理相对困难。样本集较大时，聚类收敛时间较长。\",\"区别：\",\"（1）簇数的预先指定： K-means 需要提前指定簇数 K，而层次聚类和 DBSCAN 不需要。层次聚类会生成层次结构，可以根据需要切割簇。DBSCAN 通过密度自动确定簇的数量。\",\"（2）对簇形状和密度的适应性： K-means 假定簇是球形且密度均匀，不适合不规则形状和不同密度的簇。层次聚类和 DBSCAN 能够发现各种形状和密度的簇。\",\"（3）计算复杂度： K-means 通常是最快的，DBSCAN 次之，而层次聚类较慢，特别是在大型数据集上。\",\"（4）噪声处理： DBSCAN 在处理噪声点时比较鲁棒，可以将它们识别为噪声。K-means 和层次聚类通常需要额外的后处理步骤来处理噪声点。\"]},\"17\":{\"h\":\"八、降维\",\"t\":[\"请简要说明主成分分析（PCA）和线性判别分析（LDA）之间的区别和联系\",\"相同点：\",\"（1）两者均可以对数据进行降维。\",\"（2）两者在降维时均使用了矩阵特征分解的思想。\",\"（3）两者都假设数据符合高斯分布。\",\"不同点：\",\"（1）LDA 是有监督的降维方法，而 PCA 是无监督的降维方法\",\"（2）LDA 降维最多降到类别数 k-1 的维数，而 PCA 没有这个限制。\",\"（3）LDA 除了可以用于降维，还可以用于分类。\",\"（4）LDA 选择分类性能最好的投影方向，而 PCA 选择样本点投影具有最大方差的方向。\"]},\"18\":{\"h\":\"1. What is Regularization?\",\"t\":[\"Regularization is a technique used in machine learning to prevent overfitting by adding a penalty（惩罚项） to the model's complexity. It works by incorporating additional terms to the loss function, such as L1 (Lasso)（L1 正则化） or L2 (Ridge)（L2 正则化） penalties, which constrain the magnitude of the model parameters. This helps in reducing the variance without substantially increasing the bias, leading to better generalization on unseen data.\"]},\"19\":{\"h\":\"2. What is Cross Validation?\",\"t\":[\"Cross validation is a technique for assessing the performance and robustness of a machine learning model. It involves partitioning the dataset into training and validation sets multiple times to ensure that the model's performance is evaluated on different subsets of data. The most common method is k-fold cross validation（k 折交叉验证）, where the dataset is divided into k equally sized folds, and the model is trained and validated k times, each time using a different fold as the validation set and the remaining folds as the training set. This helps in obtaining a more reliable estimate of model performance.\"]},\"20\":{\"h\":\"3. PCA Principle\",\"t\":[\"Principal Component Analysis (PCA)（主成分分析） is a dimensionality reduction technique that transforms the data into a new coordinate system such that the greatest variances by any projection of the data come to lie on the first coordinates (called principal components（主成分）). It achieves this by calculating the eigenvectors（特征向量） and eigenvalues（特征值） of the data's covariance matrix. The principal components are orthogonal to each other, and by selecting the top k principal components, we can reduce the dimensionality of the data while preserving most of its variance.\"]},\"21\":{\"h\":\"4. K-Means Principle\",\"t\":[\"K-Means（K 均值） is a clustering algorithm that partitions a dataset into k distinct, non-overlapping subgroups (clusters（簇）). It works by initializing k centroids（质心） randomly, assigning each data point to the nearest centroid, and then updating the centroids to be the mean of the data points assigned to them. This process iterates until the centroids no longer change significantly. The goal is to minimize the within-cluster variance, resulting in compact and well-separated clusters.\"]},\"22\":{\"h\":\"5. Support Vector Machine Principle\",\"t\":[\"Support Vector Machine (SVM)（支持向量机） is a supervised learning algorithm used for classification and regression tasks. The principle of SVM is to find the optimal hyperplane（超平面） that best separates the data into different classes. This hyperplane is defined by support vectors（支持向量）, which are the data points closest to the hyperplane. SVM aims to maximize the margin（间隔）, which is the distance between the hyperplane and the support vectors. For non-linearly separable data, SVM uses kernel functions（核函数） to transform the data into a higher-dimensional space where a linear separator can be found.\"]},\"23\":{\"h\":\"6. Decision Tree Principle\",\"t\":[\"A Decision Tree（决策树） is a supervised learning algorithm used for both classification and regression tasks. It works by recursively splitting the data based on feature values to create a tree structure, where each internal node represents a decision based on a feature, each branch represents the outcome of the decision, and each leaf node represents a class label or a continuous value. The splits are chosen to maximize the reduction in impurity（杂质）, commonly measured by metrics like Gini impurity（基尼杂质） or information gain (entropy)（信息增益或熵）. The resulting model is a tree that predicts the target variable by traversing from the root to a leaf node based on the feature values of the input data.\"]},\"24\":{\"c\":[\"ML\"]},\"25\":{\"h\":\"Cutting-edge Technology 前沿科技\",\"t\":[\"本文不定期更新前沿科技简介.\"]},\"26\":{\"h\":\"\",\"t\":[\"大语言模型是利用深度学习技术，如预训练、微调、Transformer 架构等，通过海量多样化数据训练，得到的具有 数以亿计参数的，具有学习、理解、适应能力的，能够处理多任务如自然语言处理、计算机视觉、语音识别等任务的机器学习模型。\",\"Foudation models are machine learning models, trained on massive and diverse datasets using deep learning techniques such as pre-training, fine-tuning, and Transformer architectures, which possess billions of parameters. These models are capable of learning, understanding, and adapting, enabling them to handle various tasks, including natural language processing, computer vision, and speech recognition.\",\"!Foudation Model\"]},\"27\":{\"h\":\"Sora 模型对于交通行业影响\",\"t\":[\"Sora结合了GPT技术，能够理解和生成高质量的文本提示（prompts），这些提示用于指导视频内容的生成。\",\"Sora integrates GPT, enabling it to understand and produce high-quality text prompts that guide the creation of videos.\",\"1.对于自动驾驶\",\"提供高质量的真实数据用于训练与模拟 Provide high-quality datasets including real scnarios for training and simulating.\",\"提供新的开发算法思路、帮助开发更为智能的决策方案（自动驾驶系统所需具良好的泛化能力，在复杂环境中做出快速决策的，目前的系统往往在特定场景下表现良好，但在新环境中可能无法适应。Sora生成的视频可以模拟各种决策场景，以帮助开发更为智能的决策制定算法。）Offer more adaptive algorithms to better handle the complex issues in real-world scenarios.\",\"提供虚拟测试的平台 Offer platforms for virtual test\",\"2.对交通规划\",\"交通规划模拟与分析（通过生成不同交通规划方案，模拟拟不同的交通规划方案，帮助规划者评估其对交通流量、拥堵和行人安全的影响。通过模拟特定时间段的交通流，Sora可以帮助预测和分析交通模式，为交通规划提供数据支持）\",\"提供应急响应与安全管理案例（在应急响应规划中，Sora可以用来模拟自然灾害、事故等紧急情况下的交通状况，帮助制定有效的应急响应策略。通过模拟不同紧急情况下的交通流动，Sora有助于提高交通管理系统的准备性和响应能力）\\n*Generating videos of traffic fomular\"]},\"28\":{\"h\":\"Vocabulary in Planning Algorithms\",\"t\":[\"recurring：反复出现，经常的 One recurring theme is that\",\"increment：增长 decrement：减少 The robot takes discrete steps in one of four directions (up, down, left, right), each of which increments or decrements one coordinate.、\",\"redundant：冗余的，重复因而不必要的 1.recurring：反复出现，经常的 One recurring theme is that\",\"increment：增长 decrement：减少 The robot takes discrete steps in one of four directions (up, down, left, right), each of which increments or decrements one coordinate.、\",\"omit：省略，忽略，遗忘 Figure 2.4 omits several details that...\",\"monotonicity：单调性\",\"asymptotic：渐进的\",\"trivial：不重要的 unimportant\",\"cumbersome: 笨重的，沉重的，难以去做的 however, the notation and explanation can become more cumbersome because\",\"superficial: 表面的，表皮的，肤浅的\",\"recurrence: 重复出现\",\"preclude：阻止，防止（人/事） prevent\",\"onward：向前的/地\"]},\"29\":{\"h\":\"Chapter 1 Introduction\",\"t\":[\"PLANNING ALGORITHMS\",\"Steven M. LaValle\",\"University of Illinois\",\"Copyright Steven M. LaValle 2006\",\"Available for downloading at [http://planning.cs.uiuc.edu/]\",\"Published by Cambridge University Press\"]},\"30\":{\"h\":\"1.1 What is planning?\",\"t\":[\"Planning is a branch of algorithms.\",\"The user of the plan can be referred as robot or decision maker (robot, agent, controller are interchangeable)\"]},\"31\":{\"h\":\"1.2 Basic Ingredients of Planning\",\"t\":[\"State\",\"State can represent the position and orientation of a robot, the locations of tiles in a puzzle, or the position and velocity of a helicopter.\",\"The collection of state: state space.\",\"Can be both discrete (finite, or countably infinite) and continuous (uncountably infinite).\",\"Can be explicitly represented or implicitly.\",\"Time\",\"All planning problems involve a sequence of decisions that must be applied over time.\",\"Can be explicitly modeled or implicitly.\",\"Action\",\"A plan generates actions that manipulate the state.\",\"States changes when actions applied (through state-valued function under discrete time or differential equation under continuous time)\",\"Initial and goal states\",\"Planning problems involve starting from the initial state, finally arriving at the goal states (a set of)\",\"Criterion\",\"Feasiblity or Optimality\",\"Plan\",\"A plan can specify a sequence of actions to be taken or specify actions as a function of state.\",\"相关信息\",\"Once a plan is determined, there are three ways to use it.\",\"Execution: Execute it either in simulation or in a mechanical device (robot) connected to the physical world.\",\"Refinement: Refine it into a better plan. The new plan may take more problem aspects into account, or it may simply be more efficient (see at the following picture). Refinement can be executed repeatedly until the final one.\",\"A refinement approach that has been used for decades in robotics\",\"The first plan yields a collision-free path through the building. The second plan transforms the route into one that satisfies differential constraints based on wheel motions (recall Figure 1.11). The third plan considers how to move the robot along the path at various speeds while satisfying momentum considerations. The fourth plan incorporates feedback to ensure that the robot stays as close as possible to the planned path in spite of unpredictable behavior.\",\"Hierarchical inclusion: Under hierarchical inclusion, a plan is incorporated as an action in a larger plan. The original plan can be imagined as a subroutine in the larger plan.Hierarchical inclusion can be performed any number of times, resulting in a rooted tree of plans. This leads to a general model of hierarchical planning. Each vertex in the tree is a plan. The root vertex represents the master plan. The children of any vertex are plans that are incorporated as actions in the plan of the vertex. There is no limit to the tree depth or number of children per vertex.\"]},\"32\":{\"h\":\"1.3 Organization of this book\",\"t\":[\"PART 1 Intro: Chapter 1-2\",\"PART 2 Motion planning: Chapter 3-8\",\"PART 3 Decision-Theoretic Planning: Chapter 9-12\",\"PART 4 Planning Under Differential Constraint: Chapter 13-15\"]},\"33\":{\"c\":[\"PR\"]},\"34\":{\"h\":\"Chapter 2 Discrete Planning\"},\"35\":{\"h\":\"2.1 Introduction to Discrete Feasible Planning\"},\"36\":{\"h\":\"2.1.1 Problem Formulation\",\"t\":[\"Formulation 2.1\",\"State: x\",\"State space: X, nonempty, finite or infinite.\",\"Action: u\",\"Action space: U(x) , x∈X\",\"State transition fuction: x′=f(x,u). Each current state x, when applied with each action u, produces a new state x'.\",\"Initial state: xI​∈X\",\"Goal state: XG​∈X\"]},\"37\":{\"h\":\"2.1.2 Examples of Discrete Planning\",\"t\":[\"Moving on a 2D gird\",\"Suppose that a robot moves on a grid in which each grid point has integer coordinates of the form (i, j). The robot takes discrete steps in one of four directions (up, down, left, right), each of which increments or decrements one coordinate. The motions and corresponding state transition graph are shown in Figure 2.1, which can be imagined as stepping from tile to tile on an infinite tile floor. This will be expressed using Formulation 2.1. Let X be the set of all integer pairs of the form (i,j), in which i,j∈Z (Z denotes the set of all integers). Let U={(0,1),(0,−1),(1,0),(−1,0)} . Let U(x)=Uforallx∈X. The state transition equation is f(x,u)=x+u, in which x∈X and u∈U are treated as two-dimensional vectors for the purpose of addition. For example, if x = (3, 4) and u = (0, 1), then f (x, u) = (3, 5). Suppose for convenience that the initial state is xI=(0,0). Many interesting goal sets are possible. Suppose, for example, that xG={(100,100)}. It is easy to find a sequence of actions that transforms the state from (0, 0) to (100, 100).\",\"Rubik's Cube Puzzle\"]},\"38\":{\"h\":\"2.2 Searching for Feasible Plans\",\"t\":[\"The methods presented in this section are just graph search algorithms, but with the understanding that the state transition graph is revealed incrementally through the application of actions, instead of being fully specified in advance.\",\"An important point is that the search algorithms must be systematic, that is, the algorithm must keep track of states already visited.\"]},\"39\":{\"h\":\"2.2.1 General Forward Search\",\"t\":[\"The following figure gives a general template of search algorithms. At any point during the search, there will be three kinds of states:\",\"Unvisited: States that have not been visited yet. Initially, this is every state except xI.\",\"Dead: States that have been visited, and for which every possible next state has also been visited. A next state of x is a state x′ for which there exists a u∈U(x) such that x′=f(x,u) In a sense, these states are dead because there is nothing more that they can contribute to the search. In some circumstances, of course, dead state can become alive again.\",\"Alive: States that have been encountered, but possibly have unvisited next states. These are considered alive. Initially, the only alive state is xI​.\",\"Forward Search\",\"Q.insert(x_I) and mark x_I as visited. while Q not empty do: x = Q.GetFirst() if x in x_G: return SUCCESS for all u in U(x): x' = f(x,u) if x' not visited: Q.insert(x') mark x' visited else: Resolve duplicate x' Return FAILURE \",\"The above is a general template of forward search algorithm. Two focuses are presented here: How efficient is the test to determine whether x∈XG​ in line 4? How can one tell whether x′ has been visited in line 8 and line 9?\"]},\"40\":{\"h\":\"2.2.2 Particular Forward Search Methods\",\"t\":[\"This section presents several search algorithms, each of which constructs a search tree. Each search algorithm is a special case of the algorithm of the forward search algorithm template demonstrated before, obtained by defining a different sorting function for Q. Most of these are just classical graph search algorithms.\",\"Breath First: Specify Q as a First-In First-Out (FIFO) queue. All plans that have k steps are exhausted before plans with k + 1 steps are investigated. Therefore, breadth first guarantees that the first solution found will use the smallest number of steps. The asymptotic running time of breadth-first search is O(∣V∣+∣E∣).\",\"Depth First: Specify Q as a First-In Last-Out (FILO) stack. The running time of depth first search is also O(∣V∣+∣E∣).\",\"Dijkstra’s algorithm: Use cost-to-come (distance between initial state and current state), short for Function C，C(x) to sort Q.\",\"A*: Incorporate a heuristic estimate of the cost called cost-to-go (distance between current state and goal state), short for G(x) with C(x).\",\"Best first: Only use G(x) to sort Q.\",\"Iterative deepening: An approach integrates Breath first and Depth first method. That means performs Depth first search at i depth (i=1, 2, 3....max depth). Initially, i is equal to 1 and will increase with step going on. For example, if i = 1, the algorithm cannot find XG​. Then i will be 2, perform the same operation. If we still cannot find the solution, i will be 3 until we reach XG​.\"]},\"41\":{\"h\":\"2.2.3 Other General Search Schemes\",\"t\":[\"Backward search: For many planning problems, it might be the case that the branching factor is large when starting from xI. In this case, it might be more efficient to start the search at a goal state and work backward until the initial state is encountered.\",\"BACKWARD SEARCH\",\"Q.insert(x_G) and mark x_G as visited. while Q not empty do: x = Q.GetFirst() if x in xI: return SUCCESS for all u^-1 in U(x)^-1: x' = f^-1(x,u^-1) if x' not visited: Q.insert(x') mark x' visited else: Resolve duplicate x' Return FAILURE \",\"Bidirectional search: One tree is grown from the initial state, and the other is grown from the goal state. The search terminates with success when the two trees meet. Failure occurs if either priority queue has been exhausted.\",\"BIDIRECTIONAL SEARCH\",\"Q_G.insert(X_G) and mark x_G as visited. Q_I.insert(X_I) and mark x_I as visited. while Q_G and Q_I not empty do: x = Q_I.GetFirst() if x already visited from x_G return SUCCESS for all u in U(x): x' = f(x,u) if x' not visited: Q_I.insert(x') mark x' visited else: Resolve duplicate x' x = Q_G.GetFirst() if x already visited from x_I return SUCCESS for all u^-1 in U(x)^-1: x' = f^-1(x,u^-1) if x' not visited: x_G.insert(x') mark x' visited else: Resolve duplicate x' Return FAILURE \"]},\"42\":{\"h\":\"2.2.4 A Unified View of the Search Methods\",\"t\":[\"For all search methods, there usually involves the following 6 steps:\",\"Initialization: Initial graph G(V, E) and include some starting states in empty V, which could be XG​ or XI​ (Bidirectional search or backward search)\",\"Select Vertex: Select states in priority queue Q sorted with some rules.\",\"Apply an Action: Obtain a new state x' from f(x, u).\",\"Insert a Directed Edge into the Graph: If certain algorithm-specific tests are passed, then generate an edge from x to x' for the forward case or an edge from xnew to x for the backward case. If x' is not yet in V , it will be inserted into V.\",\"Check for Solution: Determine whether G encodes a path from XI​ to XG​. If there is a single search tree, then this is trivial. If there are two or more search trees, then this step could be expensive.\",\"Return to Step 2: Iterate unless a solution has been found or an early termination condition is satisfied, in which case the algorithm reports failure.\"]},\"43\":{\"h\":\"2.3 Discrete Optimal Planning\",\"t\":[\"This section discusses optimal planning problems involving optimizing time, distance, energy consumed.\",\"Formulation 2.2(Discrete Fixed-Length Optimal Planning)\",\"All of the components from Formulation 2.1 will be inherited in this section like X,U(x),f,xI​,xG​. Notably, here X is finite.\",\"The number of the stages, K, is defined, which is the exact length of the plan. It can be measured as the number of the actions. xk+1​ is obtained after uk​ is applied.\",\"Introduce cost functional:\",\"L(πK​)=sumk=1K​l(xk​,uk​)+LF​(xF​)\",\"L denote a stage-additive cost (or loss) functional, which is applied to a K-step plan, πK​. This means that the sequence (u1​,......,uK​) of actions and the sequence (x1​,......,xK+1​) of states may appear in an expression of L.\",\"For convenience, let F denote the final stage, F=K+1 (the application of uK​ advances the stage to K+1)\",\"The cost term l(xk​,uk​) yields a real value for every xk​∈Xanduk​∈U(xk​).\",\"The final term lF​(xF​) is outside of the sum and is defined as lF​(xF​)=0 if xF​∈XG​, and lF​(xF​)=∞ otherwise.\",\"Distinguish\",\"l(xk​,uk​) is the cost term after applying uk​ at xk​ while f(xk​,uk​) is the state transition fuction to obtain xk+1​\"]},\"44\":{\"h\":\"2.3.1 Optimal Fixed-Length Plans\",\"t\":[\"This section will mainly discuss the value iteration algorithm, which is to iteratively compute optimal cost-to-go (or cost-to-come) functions over the state space. In some conditions, it can be reduced to Dijkstra algorithm. There are mainly two versions of this algorithm, namely backward value iteration and forward value iteration.\"]},\"45\":{\"h\":\"2.3.1.1 Backward value iteration\",\"t\":[\"Firstly, we will introduce a new cost fuctional called Gk∗​, which represents the cost-to-go fuction accumulated through stage k to F. It can be written as the following equation:\",\"Gk∗​(xk​)=uk...uKmin​sumi=kK​l(xk​,uk​)+lF​(xF​)\",\"(1)\",\"This can be converted to the following equation (the proof process is omitted here as the formula will be well understood from its definition):\",\"Gk∗​(xk​)=ukmin​l(xk​,uk​)+Gk+1∗​(xk+1​)\",\"(2)\",\"This produces the recurrence, which can be used to obtain Gk∗​(xk​) iteratively from Gk+1∗​(xk+1​). It's like:\",\"GF∗​(xF​)→GK∗​(xK​)→GK−1∗​(xK−1​)→...→Gk∗​(xk​)→...→G1∗​(x1​)\",\"x1​ may contain the xI​.\",\"Example 1\",\"Figure 1 A five-state example. Each vertex represents a state, and each edge represents an input that can be applied to the state transition equation to change the state. The weights on the edges represent l(xk, uk) (xk is the originating vertex of the edge).\",\"Suppose that K=4,xI​=a,xG​=d. Hence, there will be four iterations by constructing G4∗​(x4​),G3∗​(x3​),G2∗​(x2​),G1∗​(x1​).\",\"Firstly, G5∗​(x5​)=xF​, For state a, b, c, e, they are not in xG​, so each value of them is ∞. For state d, the value is 0.\",\"K=4,G4∗​(x4​)=u4min​l(x4​,u4​)+G5∗​(x5​), x5​ can be a, b, c, d, e. Let's assume a as the current state(x4​) for instance. G5∗​(c)=∞, the equation goes to G4∗​(a)=u4​min​l(a,u4​)+G5∗​(x5​). Here, x5​ can be a, b, c, d, e. u4​ is the edge from a to x5​. We need to find out the smallest of the five combinations of a and x5​(a,b,c,d,e). Obviously, all of them is ∞.\",\"Let's take b, c as the x4​, respectively. You can see that G4∗​(b)=l(b,ub​d)+G5∗​(d)=4+0=4. G4∗​(c)=l(c,uc​d)+G5∗​(d)=1+0=1.\",\"K=3, the potential options of x4​=b,c. You need to take a,b,c,d,e as x3​ to calculate their optimal value G3∗​(x3​). For example, d as x3​. There are five circumstances, in which 3 of them are ∞(a, d, e). So the left two are G3∗​(d)=l(d,ud​c)+G3∗​(c)=1+1=2. G3∗​(d)=l(d,ud​b)+G3∗​(b)=∞+0=∞ So G3∗​(d)=2.\",\"In this way can you easily obtain G2∗​(x2​),G1∗​(x1​). The results are shown in the following table.\",\"a\",\"b\",\"c\",\"d\",\"e\",\"G₅*\",\"∞\",\"∞\",\"∞\",\"0\",\"∞\",\"G₄*\",\"∞\",\"4\",\"1\",\"∞\",\"∞\",\"G₃*\",\"6\",\"2\",\"∞\",\"2\",\"∞\",\"G₂*\",\"4\",\"6\",\"3\",\"∞\",\"∞\",\"G₁*\",\"6\",\"4\",\"5\",\"4\",\"∞\"]},\"46\":{\"h\":\"2.3.1.2 Forward value iteration\",\"t\":[\"The ideas from Section 2.3.1.1 may be recycled to yield a symmetrically equivalent method that computes optimal cost-to-come functions from the initial stage.\",\"In the backward case, xG​ must be fixed, and in the forward case, xI​ must be fixed.\",\"Symmetrically, here we introduce Ck∗​, which denotes the optimal cost-to-come value from stage 1 to k. lI​ serves as the same role of lF​. That is\",\"Ck∗​(x1​)=lI​(x1​)\",\"in which lI​ is a new function that yields lI​(xI​)=0, and lI​(x)=∞ for all x=xI​. Thus, any plans that try to start from a state other than xI​ will immediately receive infinite cost.\",\"Likewise, we can get the same equation:\",\"Ck∗​(xk​)=u1...uk−1min​sumi=1k−1​l(xk​,uk​)+lI​(xI​)\",\"(3)\",\"Also the recurrence:\",\"Ck∗​(xk​)=uk−1min​l(xk​,uk​)+Ck−1∗​(xk−1​)\",\"(4)\",\"Example 2\",\"We can still use the net in Figure 1, perform the forward iteration:\",\"Suppose K=4, we need to calculate C4∗​ for a, b, c, d, e. Each has 5 options of Ck−1∗​(xk−1​). For instance, C4∗​(xc​), there exsits a-c, b-c, c-c, d-c, e-c. C3∗​(xe​)=∞, la−c​,lc−c​=∞. Thus we only need to compare lb−c​+C3∗​(xb​) and ld−c​+C3∗​(xd​). The former is smaller, which equals to 5 while the latter is 7.\",\"a\",\"b\",\"c\",\"d\",\"e\",\"C₁*\",\"0\",\"∞\",\"∞\",\"∞\",\"∞\",\"C₂*\",\"2\",\"2\",\"∞\",\"∞\",\"∞\",\"C₃*\",\"4\",\"4\",\"3\",\"6\",\"∞\",\"C₄*\",\"4\",\"6\",\"5\",\"4\",\"7\",\"C₅*\",\"6\",\"6\",\"5\",\"6\",\"5\"]},\"47\":{\"h\":\"2.3.2 Optimal Plans of Unspecified Lengths\",\"t\":[\"In section 2.3.1 we learn algorithm solving optimal fixed-length plans. However, it is obviously unreasonable. To begin with, we don't know the exact length of the solution. We need to set it in advance, which can be inappropriate. In example 1, we can obtain the optimal path from G2​(a). But we repeat another redundant iteration in G1​.\",\"So how to address this issue? That is variable-length plan.\",\"The value-iteration method, originally used for fixed-length plans, is generalized for plans of different lengths. There is no upper limit to how long a plan can be, making this approach a true generalization of earlier fixed-length formulations.\",\"How to accomplish this? Here we introduce a special \\\"termination\\\" action, denoted as uT​. This action allows a plan to stop at any state, effectively saying, \\\"We are done.\\\" Once this action is applied, the state no longer changes, and no additional costs are incurred. This enables plans of different lengths to be handled uniformly. For example, a two-step plan (u1​,u2​) that reaches the goal can be extended to a longer plan by simply repeating the termination action without changing the cost like (u1​,u2​,uT​,uT​,uT​).\",\"The termination action is applied when the system has reached a goal state, meaning the current state x∈xG​.\",\"Once the goal is achieved, further actions are unnecessary, and the cost will not increase. So, the system applies the termination action to \\\"stop\\\" further planning or changes in the state.\",\"For iteration going on, we introduce two similar formulas.\",\"For backward value iteration:\",\"This formula calculates the optimal action (u∗) at a given state x:\",\"u∗=argu∈U(x)min​(l(x,u)+G∗(f(x,u)))\",\"(5)\",\"l(x,u): Represents the cost incurred by taking action u in state x.\",\"G∗(f(x,u)): The optimal cost-to-go function, which estimates the remaining cost to the goal from the next state f(x,u), the state that results from applying action $u $ to state x.\",\"The formula minimizes the total cost, which is the sum of the immediate cost l(x,u) and the cost-to-go from the resulting state. The argmin part means we are selecting the action u∗ that yields the lowest total cost.\",\"For forward value iteration:\",\"u=argu−1∈U−1(x)min​(C∗(f−1(x,u−1))+l(f−1(x,u−1),u′))\",\"(6)\",\"f−1(x,u−1): Refers to the state from which action u−1 would bring the system into state x.\",\"C∗: The optimal cost-to-come function, analogous to G∗, but in a forward direction. It tells us the best cost incurred to reach x from some previous state.\",\"l(f−1(x,u−1),u′): Represents the cost of the action leading from the predecessor state to x.\",\"In this way can we not rely on the specified k. Since we select the action u∗ that yields the lowest total cost every iteration.\",\"Distinguish\",\"Key Differences between (2) (4) in fixed-length planning and (5) (6) in variable-length planning\",\"Fixed vs. Variable Length:\",\"(2)(4) is used in the context of fixed-length planning, where the number of stages is known and the goal is to minimize the cost over a set number of steps.\",\"(5)(6) is for variable-length planning, where the number of stages is unspecified, and you want to minimize the overall cost-to-go/cost-to-come, with no constraint on the number of steps.\",\"Stage Dependency:\",\"(2)(4) depends on the stage index k (since the cost-to-go depends on the specific stage).\",\"(5)(6) is independent of any stage index because it is used for unspecified-length plans, where the focus is on minimizing the total cost regardless of how long the plan takes.\",\"Similarity\",\"Both formulas aim to minimize the total cost by selecting the optimal action at each state based on a cost function that combines immediate cost and the future cost-to-go/past cost-to-come. The mechanism for selecting actions is the same—iteratively finding the action that leads to the least total cost.\",\"Example 1 will be changed into:\",\"a\",\"b\",\"c\",\"d\",\"e\",\"G₀*\",\"∞\",\"∞\",\"∞\",\"0\",\"∞\",\"G₋₁*\",\"∞\",\"4\",\"1\",\"0\",\"∞\",\"G₋₂*\",\"6\",\"2\",\"1\",\"0\",\"∞\",\"G₋₃*\",\"4\",\"2\",\"1\",\"0\",\"∞\",\"G₋₄*\",\"4\",\"2\",\"1\",\"0\",\"∞\",\"G*\",\"4\",\"2\",\"1\",\"0\",\"∞\"]},\"48\":{\"h\":\"2.3.3 Dijkstra Revisited\",\"t\":[\"The key differences between Dijkstra algorithm and forward value iteration algorithm are shown as below:\",\"Feature\",\"Dijkstra's Algorithm\",\"Forward Value Iteration\",\"Cost Metric\",\"Minimizes cost-to-come (from start to current state)\",\"Propagates cost-to-come in forward iteration\",\"Approach\",\"Greedy, explores states with minimum cost-to-come\",\"Dynamic programming, iterates over all states simultaneously\",\"Exploration Strategy\",\"Expands one state at a time based on smallest cost-to-come\",\"Updates all states simultaneously in each iteration\",\"Priority\",\"Uses a priority queue to expand least-cost states first\",\"Does not prioritize; updates globally\",\"Set of Alive States\",\"Yes, maintains a set of \\\"alive\\\" states (states yet to be finalized)\",\"No, updates all states without maintaining alive states\",\"Best Use Case\",\"Finding the shortest path to a goal state\",\"Computing global cost-to-come for all states\",\"Efficiency\",\"More efficient for single-goal problems\",\"Less efficient; explores the entire state space\",\"If Dijkstra’s algorithm seems so clever, then why have we spent time covering the value-iteration method? For some problems it may become too expensive to maintain the sorted queue, and value iteration could provide a more efficient alternative. A more important reason is that value iteration extends easily to a much broader class of problems. Examples include optimal planning over continuous state spaces (Sections 8.5.2 and 14.5), stochastic optimal planning (Section 10.2), and computing dynamic game equilibria (Section 10.5).\",\"Dijkstra’s algorithm belongs to a broader family of label-correcting algorithms, which all produce optimal plans by making small modifications to the general forward-search algorithm.\",\"FORWARD LABEL CORRECTING(xG​)\",\"1 Set C(x) = ∞ for all x(except xI), and set C(xI) = 0. 2 Q.Insert(xI) 3 while Q not empty do: 4 x ← GetFirst(Q) 5 for all u in U(x) 6 x' ← f(x, u) 7 if C(x) + l(x, u) < min{C(x'), C(xG)} 8 C(x') ← C(x) + l(x, u) 9 if x' is not xG 10 Q.Insert(x') \",\"Notably, the label-correcting approach uses the cost at the goal state to prune away many candidate paths; this is shown in line 7. Thus, it is only formulated to work for a single goal state; it can be adapted to work for multiple goal states, but performance degrades. The motivation for including C(xG​) in line 7 is that there is no need to worry about improving costs at some state, x′, if its new cost-to-come would be higher than C(xG​); there is no way it could be along a path that improves the cost to go to xG​.\"]},\"49\":{\"h\":\"2.4 Using Logic to Formulate Discrete Planning\",\"t\":[\"For many discrete planning problems that we would like a computer to solve, the state space is enormous (e.g., 10100 states). Therefore, substantial effort has been invested in constructing implicit encodings of problems in hopes that the entire state space does not have to be explored by the algorithm to solve the problem.\",\"Pros and Cons of logic-based representations:\"]},\"50\":{\"h\":\"2.4.1 A STRIPS-Like Representation\",\"t\":[\"STRIPS-like representations have been the most common logic-based representations for discrete planning problems. This refers to the STRIPS system, which is considered one of the first planning algorithms and representations; its name is derived from the STanford Research Institute Problem Solver. There are many variations of STRIPS-like representations. Here is one formulation:\",\"A finite, nonempty set I of instances. Instances are just the object existing in the world like books or trees.\",\"A finite, nonempty set P of predicates, which are binary-valued (partial) functions of one of more instances. Each application of a predicate to a specific set of instances is called a positive literal. A logically negated positive literal is called a negative literal.\",\"The predicates can form the basic properties or statements of certain instances. For example, a predicate called Under might be used to indicate things like Under(Book, T able) (the book is under the table) or Under(Dirt, Rug).\",\"A predicate can be interpreted as a kind of function that yields true or false values;\",\"however, it is important to note that it is only a partial function because it might not be desirable to allow any instance to be inserted as an argument to the predicate.(In other words, some combinations of predicates and instance are obviously true or false.)\",\"Summary: instances + predicates = positive/negative literal\",\"A finite, nonempty set O of operators, each of which has: 1) preconditions, which are positive or negative literals that must hold for the operator to apply, and 2) effects, which are positive or negative literals that are the result of applying the operator.\",\"An initial setS which is expressed as a set of positive literals. Negative literals are implied. For any positive literal that does not appear in S, its corresponding negative literal is assumed to hold initially.\",\"A goal setG which is expressed as a set of both positive and negative literals.\",\"Summary: preconditions, effects, initial sets and goal sets are all made up of literals.\",\"The process involves:\",\"Initially, we have several instances and define several predicates so as to form literals. We set the initial sets and goal sets. Based on corresponding preconditions, we need to find the operators that prodces the effects we want (reach the destination).\",\"Example 3\",\"An example that involves putting batteries into a flashlight\",\"Imagine a planning problem that involves putting two batteries into a flashlight, as shown in the following figure. The set of instances are\",\"I={Battery1,Battery2,Cap,Flashlight}\",\"Two different predicates will be defined, On and In, each of which is a partial function on I. The predicate On may only be applied to evaluate whether the Cap is On the Flashlight and is written as On(Cap, Flashlight). The predicate In may be applied in the following two ways: In(Battery1, Flashlight), In(Battery2, F lashlight), to indicate whether either battery is in the flashlight.\",\"Recall that predicates are only partial functions in general. For the predicate In, it is not desirable to apply any instance to any argument. For example, it is meaningless to define In(Battery1, Battery1) and In(F lashlight, Battery2) (they could be included in the model, always retaining a negative value, but it is inefficient).\",\"The initial set is\",\"S={On(Cap,Flashlight)}.\",\"Based on S, both ¬In(Battery1, F lashlight) and ¬In(Battery2, Flashlight) are assumed to hold. Thus, S indicates that the cap is on the flashlight, but the batteries are outside. The goal state is\",\"G=On(Cap,Flashlight),In(Battery1,Flashlight),In(Battery2,Flashlight)\",\"which means that both batteries must be in the flashlight, and the cap must be on. The set O consists of the four operators, which are\",\"Name\",\"Preconditions\",\"Effects\",\"PlaceCap\",\"RemoveCap\",\"Insert(i)\",\"Here is a plan that reaches the goal state in the smallest number of steps:\",\"(Remove(Cap),Insert(Battery1),Insert(Battery2),Place(Cap))\",\"In words, the plan simply says to take the cap off, put the batteries in, and place the cap back on.\",\"This example appears quite simple, and one would expect a planning algorithm to easily find such a solution. It can be made more challenging by adding many more instances to I, such as more batteries, more flashlights, and a bunch of objects that are irrelevant to achieving the goal. Also, many other predicates and operators can be added so that the different combinations of operators become overwhelming.\"]},\"51\":{\"c\":[\"PR\"]},\"52\":{\"h\":\"元胞自动机 Cellular Automata\",\"t\":[\"本节简单介绍一下元胞自动机模型，包括其定义、基本概念、应用等方面，具体讲解可以看这篇文章与这篇文章。\"]},\"53\":{\"h\":\"定义\",\"t\":[\"元胞自动机（Cellular Automata, CA）是自动机理论（Theory of automata）中的一种离散计算模型，最初由Stanislaw Ulam和John von Neumann 于 20 世纪 40 年代在洛斯阿拉莫斯国家实验室同时提出[1]。一个完整的元胞自动机模型包含 元胞、元胞空间、元胞邻居、元胞边界、元胞规则 五大部分，下面将分别做进一步阐述。\"]},\"54\":{\"h\":\"元胞\",\"t\":[\"元胞是 CA 模型的基本单元，是模型迭代的直接参与者，从概念上就可以理解元胞就好似生物体的细胞。每一个元胞都有一个状态,一般为二维（如 0-1），复杂情况下也有多维。\"]},\"55\":{\"h\":\"元胞空间\",\"t\":[\"元胞空间为空间内元胞的集合，即按一定方式对空间划分，元胞呈一定形状。元胞空间划分方式大致有 正方形（类似栅格化）、三角形、正六边形 等类型。\"]},\"56\":{\"h\":\"元胞邻居\",\"t\":[\"元胞邻居是某一元胞周围的元胞，是否为邻居，取决于元胞状态更新时所要搜索的空间域，在二维空间下，最常用的邻居类型是 Moore 型和 Von Neumann 型，如图一所示：\",\"图1 元胞类型\",\"Moore 邻居定义为下式：\",\"NM​(x0​,y0​)={(x,y):∣x−x0​∣<=r,∣y−y0​∣<=r}\",\"Von Neumann 邻居定义为：\",\"NV​(x0​,y0​)={(x,y):∣x−x0​∣+∣y−y0​∣<=r}\"]},\"57\":{\"h\":\"边界条件\",\"t\":[\"边界条件是元胞空间外的部分，是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞。常用的邻居边界条件类型有：固定型，周期型，绝热型和映射型这四种，常用为固定型和周期型。\",\"注\",\"固定型：在外围补上固定不变的、虚拟的元胞。\",\"周期型：每个维度的第一个元胞与最后一个元胞互为边界。\",\"绝热型：边界元胞与自己相同。\",\"映射型：边界元胞为元胞每个维度内侧邻近元胞。 一般常用为固定型和周期型边界条件。\"]},\"58\":{\"h\":\"元胞规则\",\"t\":[\"元胞规则即每次迭代，每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态，每个元胞按照该规则进行状态更新，相互作用，由局部到整体，从而引起全局的变化。元胞规则是整个 CA 模型最为关键的部分。\",\"相关信息\",\"元胞自动机更新规则特征[2]：\",\"离散型：空间、时间及状态都是离散的;\",\"同质性：服从相同的规律分布方式相同；\",\"并行性：元胞的状态更新规则变化是同步进行的；\",\"高维度：元胞自动机是一类无穷维动力系统。\"]},\"59\":{\"h\":\"生命游戏\",\"t\":[\"生命游戏是最著名的二维元胞自动机生命游戏，由John Conway于 1970 年设计。它由二维元胞网格组成，其状态可能是死亡 (0) 或活着 (1)。该游戏采用标准 Moore 邻居，其元胞规则为：\",\"对于“活着”的格子，若它的 8 个 Moore 邻居中有 2-3 个为“活着”，则该格继续保持“活着”，否则就变为“死亡”。 对于“死亡”的格子，若它的 8 个邻居中有 3 个“生”，则该格变为“生”，否则继续保持“死”。\",\"用函数表示如下：\",\"vt+1(α)=⎩⎨⎧​0,νt(α),1,​S<2∨S>3S=2S=3​\",\"图2 生命游戏\"]},\"60\":{\"h\":\"应用\",\"t\":[\"元胞自动机的应用大致有以下几类：\",\"作为物理、化学、生物过程的基础模型\",\"计算单元\",\"模拟现实复杂动态系统\",\"英文总结\",\"Cellular automaton is a discrete computing model in the Theory of automata. A complete cellular automaton model includes five parts: cell, cell space, cell neighbor, cell boundary, and cell rules. Each cell has a state which can be 0 or 1, alive or dead. Each cell follows a set of rules and updates the state at every time step based on the current state and their neighbors' state, thereby triggering global changes. It has many applications in computing and simulation.\"]},\"61\":{\"c\":[\"交通\"]},\"62\":{\"h\":\"改进NS模型\",\"t\":[\"本节介绍NS模型基本内容、改进NS模型以及对应代码的实现。\"]},\"63\":{\"h\":\"1 基本概念\"},\"64\":{\"h\":\"1.1 Nagel–Schreckenberg model NS模型\",\"t\":[\"Nagel–Schreckenberg model，简称NS model，最初由德国物理学家Kai Nagel and Michael Schreckenberg,是一种基于CA模型的用于交通仿真的理论模型。\",\"Nagel–Schreckenberg model, short for NS model, first develped by German physicists Kai Nagel and Michael Schreckenberg, is a theoretical Cellular Automata-based model for traffic simulation.\"]},\"65\":{\"h\":\"1.2 Rule 184\",\"t\":[\"补充一下基于CA交通仿真中最常见的规则，即 Rule 184，即对于一条道路上连续的三个cell，他们的状态有以下8种（用0代表空，用1代表有车占有）,如下图所示：\",\"Rule 184\"]},\"66\":{\"h\":\"1.3 Phantom traffic jam 幽灵拥堵\",\"t\":[\"定义：莫名发生的交通拥堵 traffic jam without clear reasons\",\"原因：在拥堵（heavy）交通流中，微小的交通扰动（small disturbances），如司机过度刹车或者与其他车里的太近，都会被放大形成(be amplified into)内生性的交通拥堵。 Small disturbances, such as overreations of braking or getting too close to another vehicle, in heavy traffic can be amplified into a self-sustained traffic jam.\",\"结果：形成stop-and-go wave\",\"Stop-And-Go Wave\",\"字面意是停走波\",\"形成原因：\",\"微观（从driver角度）：vehicle slowly move → decelerate → stop → accelerate →\",\"宏观，如下图Time-Space Diagram所示：\",\"Time-Space Diagram 时空图\",\"由上图可以看到stop-and-go wave沿车流末端传播的速度，即wave speed以及波次间隔时间wave period。\",\"这样的stop-and-go wave会造成以下危害：\",\"更费油与更多排放 more fuels and emmisions.\",\"更加危险 more dangerous.\"]},\"67\":{\"h\":\"1.4 基本图 Fundamental Diagram\",\"t\":[\"Fundamental Diagram 基本图\",\"Capacity/Maximum Flow 极大流率：qk曲线极值\",\"Free Flow Speed 畅行速度：k=0对应的速度\",\"Critical Density 临界密度：极大流率对应的密度\",\"Critical Speed 临界速度：极大流率对应的速度\",\"Jam Density 堵塞密度：v=0时的密度\"]},\"68\":{\"h\":\"2 Model Description 模型描述\"},\"69\":{\"h\":\"2.1 Model Information 模型说明\",\"t\":[\"空间时间上均离散化。 Discrete in space and time\",\"所有车辆同步更新。 Each vehicle is updated parallel\",\"每个元胞长7.5m（包括了车长+距离前车的安全距离）。 Lane is divided into cells of length 7.5 m, which includes the vehicle length and the safe distance to the preceeding/leading vehicle.\",\"每个元胞为空或仅被一辆车占据。 Each cell can either be empty or occupied by only one vehicle.\",\"每个车辆拥有坐标、速度属性，车辆有最大速度限制。 Each vehicle is characterized by its velocity and coordinates. The velocity has a limit.\"]},\"70\":{\"h\":\"2.2 Model Step 更新规则\",\"t\":[\"Step 1：加速 Acceleration：对于未到达最大速度的车辆，以一个单位加速。 For vehicle not reaching speed limit, it accelerates with 1 unit.\",\"v(i)→minv(i)+1,Vmax​\",\"这反应了司机希望开得越快越好 reflect the desire of drivers to drive as fast as possible.\",\"Step 2: 减速 Safe Distance Judgment：当汽车当前速度大于与前车的距离（前方的空元胞数），则汽车减速为安全距离，否则维持原速。 If vehicle speed is larger than the number of empty cells in front of it, it velocity reduces to that empty cell amount. Otherwise, it keeps its speed.\",\"v(i)→minv(i),d(i)\",\"It encodes the interaction between the vehicle. In this simple model, interactions only occur to avoid collision.\",\"Step 3：随机慢化 Randomization：车辆以p的概率随机减速一个单位，p称为随机慢化概率。 The speed of vehicle reduces by one unit with slowdown probability p.\",\"v(i)→maxv(i)−1,0\",\"反映驾驶员的不完美驾驶行为（imperfect behavior of drivers），比如在步骤2减速时刹车踩的过大。在现实场景，驾驶员不可能总是按照一定速度(constant speed)行驶，总会有一定的波动(fluctuations)。当车流量足够大，驾驶员的这一行为会引起交通系统的一系列反应，最终形成拥堵现象。这也是反映了拥堵总是在没有任何外部原因（external reasons ，如事故）就会发生的，因此称为幽灵拥堵（phantom jam）。\",\"Randomization reflects the imperfect behavior of drivers like the overreations of braking in Step 2. In real-world scenario, drivers cannot always drive at a constant speed. There always has fluctuations of the velocity.\",\"Step 4: 位置更新 Driving：每个车辆前进当前速度的格数。 Every vehicle forward by v(i) cells.\"]},\"71\":{\"h\":\"3 改进NS模型 NS Model for Inhomogenous Traffic Flow in a Single Lane\"},\"72\":{\"h\":\"3.1 改进点：\",\"t\":[\"车辆以最大加速度 amax​ 加减速而不是以1 Vehicle accelerates/decelerates with maximum acceleration not 1.\",\"引入慢启动系数s（反应静止车辆启动较慢） Introduce the Slow Start probability(short for s) to reflect the difficuty of stationary vehicles to start up.\",\"考虑异质(inhomogeneous)车流（反映在车长，最大速度，最大加速度） Consider the inhomogeneous flow like the vehicle length, maximum velocity and maximum acceleration.\"]},\"73\":{\"h\":\"3.2 模型信息\",\"t\":[\"单车道 周期边界 Single Lane with Periodic Boundary\",\"模型信息\"]},\"74\":{\"h\":\"3.3 结果\",\"t\":[\"通过改变货车占比r(propotion of trucks)、随机慢化概率p以及慢启动系数s，分别做FD图以及时空位置图，分别分析其对于交通系统的影响影响。\",\"如当s = 0.1, p = 0.3 条件下，分别做r=0,0.1,0.2,0.3的时空位置图(Time-Space Diagram)以及基本图（Fundemantal Diagram, FD）,红线为货车，黑线为小汽车。\",\"r=0\",\"r=0.1\",\"r=0.2\",\"r=0.3\",\"r=0 含速度\",\"r=0.1 含速度\",\"r=0.2 含速度\",\"r=0.3 含速度\",\"可以看到随着货车比例的增加，wave speed逐渐降低，wave period也逐渐变小，反应交通系统越来越拥堵。\",\"做FD图如下：\",\"r=0\",\"r=0.1\",\"r=0.2\",\"r=0.3\",\"r\",\"极大流率Qm\",\"临界密度Kc\",\"临界速度Vc\",\"堵塞密度Kj\",\"畅行速度Vf\",\"0\",\"2326.9176\",\"19\",\"122.4693\",\"140\",\"126.7668\",\"0.01\",\"1782.0972\",\"40\",\"44.5524\",\"138\",\"126.8262\",\"0.03\",\"1702.6758\",\"40\",\"42.5669\",\"131\",\"126.9054\",\"0.05\",\"1647.4248\",\"39\",\"42.2417\",\"127\",\"46.3035\",\"0.1\",\"1534.3903\",\"37\",\"43.0448\",\"115\",\"46.4292\",\"0.2\",\"1377.4356\",\"34\",\"40.5128\",\"99\",\"46.0799\",\"0.3\",\"1241.7444\",\"32\",\"38.8045\",\"86\",\"42.9739\",\"随着货车比例r的增加，Qm逐渐减小，Kc先增加后减小，Vc先急剧减小后基本不变，Kj逐渐减小，Vf先不变后急剧减小。\",\"通过改变s与p的大小，也可以同理做出上述图表，这里不一一展示。\"]},\"75\":{\"h\":\"3.4 代码\",\"t\":[\"完整代码，内含动画演示。\"]},\"76\":{\"h\":\"3.5 进一步的改进点\",\"t\":[\"多车道，考虑换道，如STCA模型。\",\"Velocity-Dependent-Randomization（VDR）：NS模型中p是固定不变的，VDR中p是v的函数（与加入随机慢化概率s效果类似）。\",\"STCA（[以下内容源于][m]）\",\"由Rickert M和Chowdhury D等人在单车道元胞自动机Nasch模型的基础上提出了双车道元胞自动机STCA模型。该模型将模拟的道路环境扩展为双车道，增加了车辆换道规则，使之能够更真实准确地模拟出道路上交通流的运行状况。\",\"STCA模型在应用过程中将一个时步分为两个相同的子时步。第一个时步为车辆换道时步，车辆在这个时步内按照设计的换道规则决定是否发生换道行为；第二个时步为演化更新时步，两条车道上的车辆在该时步均按照单车道元胞自动机模型中设计的演化更新规则运行。\",\"换道规则一般包括两个部分：\",\"换道动机： 换道动机是指驾驶员想换道的意愿和条件。当某车辆在当前车道上无法达到驾驶员的期望速度，而另一条车道上的驾驶条件可以满足驾驶员对速度的要求时，车辆会以一定的换道概率进行换道。\",\"dn​<Δtmin(vn​+1,vmax​)dn, sidefront ​>dn​⋯​\",\"安全条件： 安全条件是指车辆在决定换道时要确定当前交通状况下换道对于自身和其他车辆是否安全，避免因车辆换道引起交通事故，危害生命财产安全。\",\"dn, sideback ​>dsafe ​\"]},\"77\":{\"c\":[\"交通\"]},\"78\":{\"c\":[\"traffic\"]},\"79\":{\"h\":\"行人流仿真 Pedestrian Simulation\",\"t\":[\"本文探讨基于 CA 模型的行人流仿真，如果你还不了解 CA 模型，请先移步这篇文章。\"]},\"80\":{\"h\":\"概述\",\"t\":[\"行人流仿真是通过模拟人群在不同环境下的移动，研究行人行为及心理的特点的研究，其在城市规划、交通管理、疏散计划、建筑平面设计等方面有着广泛的应用。\",\"Pedestrian simulation studies pedestrians' behavioral patterns and psychological aspects by modeling and simulating the movement of crowds in various scnarios. It finds extensive applications in urban planning, traffic management, evacuation planning, and architectural layout design.\",\"分类\",\"行人流仿真按仿真规模可以大致分为三种，即 宏观(macroscopic) 、 微观(microscopic) 、介于宏微观之间(mesoscopic) 这三种：\",\"宏观：以整个人群为研究对象，研究整体移动特征如速度、密度、流向等，每个个体没有行为特征（distinct behavior），如研究拥堵、紧急疏散人群移动特点。\",\"微观：以个体为研究对象，研究个体行为，每个个体有着独特的行为特征。\",\"介观：介于宏微观之间，人群中每个个体有着相同的行为特征，既研究整体特征也研究个体特征。\",\"常见的模型方法有：\",\"基于物理规则模型：这类模型主要是基于物理规则（law of physics），来模拟人与环境的交互，如流体动力学模型(fluid dynamic model)，社会力模型（social force model）等。 社会力模型由几种力组成，如使人达到向着目的地前进，达到一定期望速度的acceleration force，以及一些环境阻碍的力repulsive force，如来自人行道边界（crosswalk boundary）、周围行人（surrounding pedestrian）、冲突车辆（conflicting vehicles）和信号灯状态（signal phase）等阻力，这些力的合力即为行人朝着什么方向（力的方向），以多大的速度（由力的大小决定）前进。\",\"元胞自动机模型（Celluar Automata, CA）\",\"数据驱动模型：基于现实场景数据，对数据进行合适的编码（encode），采用深度学习等方法预测行人的轨迹、行为，常见的数据有：\",\"轨迹信息（trajectory information），可以是2D平面图，也可以是3D坐标（第三维为速度）的形式（2D spatial or 3D global coordinates + velocity）。\",\"视觉信息（visual information）：包含做过语义分割处理的地图（semantic map）与行人图像(images of pedestrian)，地图主要是反应道路周围的环境，如道路结构（road structure）、其他道路使用者状态（the state of other road users）以及信号状态（signal phase），行人图像主要是反应行人的行为，如动作（motion）、姿势（pose）、朝向（head orientation）等。\",\"自主车辆（ego vehicle）：包含感知周围环境传感器的车辆的信息(vehicle equiped with sensors)，如车辆坐标（coordinates）、速度（velocity）等。\",\"数据驱动模型\",\"⏩ 不同方法并非只适用于一个规模，对行人流仿真进一步了解可以移步此篇论文\"]},\"81\":{\"h\":\"问题描述\",\"t\":[\"模拟行人穿过以平台\",\"相关信息\",\"平台基本信息：\",\"平台 16×30，左三个入口，大小分别为 1×1,1×4,1×1，右四个出口，均为 1×1，中间设有障碍，行人不得通过障碍。\",\"行人每秒走一格，每个行人占一格。\",\"行人随机从各个入口进入。\",\"规定仿真时间为 960s\",\"图1 平面示意图 \"]},\"82\":{\"h\":\"模型设置\"},\"83\":{\"h\":\"基本设置\",\"t\":[\"元胞：状态设置为占有（0）与不占有（1）\",\"元胞空间：划分为方格形。\",\"元胞邻居：采用基本 Moore 型（r=1）\",\"边界条件：采用固定型。\"]},\"84\":{\"h\":\"更新规则\",\"t\":[\"更新规则即行人如何选择下一步走到哪里一个方格，这里引入元胞潜能 Cell Potential，其定义如下：\",\"Ni,j​=Ei,j​exp(kS​Si,j​+kD​Di,j​)\",\"其中，Ei,j​ 代表位置(i, j)处元胞状态，0 代表占有，1 代表不占有，Ni,j​ 代表位置(i, j)处的元胞潜能，可以发现，当元胞占有时 Ei,j​=0 ，即该处元胞潜能为 0，反应了元胞有人占据，就无法选择。Si,j​ 为元胞静态势能 Static Potential，Di,j​ 为元胞动态势能 Dynamic Potential， kS​ 和 kD​ 分别为对应系数。\",\"元胞静态势能反应了行人在选择下一步时，环境中静止物体的影响，这里主要考虑为出口与障碍物，定义为：\",\"Si,j​=kL​Li,j​+kO​Oi,j​\",\"其中，Li,j​ 为位置为(i, j)的元胞距出口的距离，Oi,j​ 为位置为(i, j)的元胞周边的非障碍数目。\",\"元胞动态势能反应行人在选择下一步时，环境的动态影响，这里以位置为(i, j)的元胞周围空元胞数目 Di,j​ 为指标。\",\"所以最后，元胞潜能可以写为：\",\"Ni,j​=Ei,j​exp(k1​Li,j​+k2​Oi,j​+k3​Di,j​)\",\"最后对 9 个位置进行标号、对元胞潜能进行归一化，即可得到选择 9 个位置的选择概率 Transition ProbabilitiePi,j​。\",\"图2 Moore邻居选择示意图\"]},\"85\":{\"h\":\"部分代码解释\",\"t\":[\"代码整体思路如下：\",\"图3 代码流程图\"]},\"86\":{\"h\":\"参数设置\",\"t\":[\"clc,clear format short; n=16; %平台宽度 h=30; %平台长度 star_x = ones(1,6); % 入口横坐标 star_y = [4,7:10,13]; % 入口纵坐标 hurdle_x = repelem(14:16,2); % 障碍 hurdle_x = cat(2,hurdle_x,[20 20]); hurdle_y = repmat(8:9,1,3); hurdle_y = cat(2,hurdle_y,[5 12]); final_x = ones(1,4)\\\\*h; % 出口 final_y = [3,6,11,14]; x=n+2; % 边界矩阵宽 y=h+2; % 边界矩阵长 platform=ones(n,h); %初始化平台 obstacle_map=ones(n+4,h+4); %设置非障碍矩阵 obstacle_map(1:2,:)=0; obstacle_map(end-1:end,:)=0; obstacle_map(:,1:2)=0; obstacle_map(:,end-1:end); border=ones(x,y); %边界矩阵 border(1,:)=0; border(end,:)=0; border(:,1)=0; border(:,end)=0; Sm=ones(n+4,h+4); % 图 Sm(1:2,:)=0; Sm(end-1:end,:)=0; Sm(:,1:2)=0; Sm(:,end-1:end); for i = 1:size(hurdle_y,2) Sm(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 obstacle_map(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 end step=1; %初始迭代次数 po=1:1:9; %位置矩阵 pp = zeros(1,9); neigh = [-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1]; L=zeros(n,h,size(final_y,2)); % 不含边界距离矩阵 N=zeros(n+2,h+2,size(final_y,2)); % 元胞潜力 N_choose=zeros(n+2,h+2); % 最终选择 P=zeros(n+2,h+2); %预留内存 prob=zeros(1,9); %概率矩阵、预留内存 go=0; % 出发人数 arrive=0; % 到达终点人数 total=960; % 迭代时间 time_people_star = zeros(n,h,total); % 记录时刻平台信息 \",\"这里设置了 4 个 map：\",\"platform：反应平台实时状态\",\"border：在 platform 外加了一圈障碍，表示边界条件。\",\"Sm 与 obstacle：在 platform 外加了两圈障碍，分别用计算 $ O*{i, j} $ 与 $ D_{i, j} $。\"]},\"87\":{\"h\":\"参数计算\",\"t\":[\"Li,j​ 的计算：\",\"Dis = zeros(n+2,h+2,size(final_y,2)); Dis = Dis + inf; % 分别计算边界内每个原胞到出口的距离 for f=1:size(final_y,2) for i=1:n for j=1:h L(i,j,f)=sqrt((i-final_y(f))^2+(j-final_x(f))^2); %不含边界的距离矩阵 Lij end end end Dis(2:n+1,2:h+1,:)=L; for i = 1:size(hurdle_y,2) Dis(hurdle_y(i)+1,hurdle_x(i)+1,:)=inf; %障碍视为距离无穷 end \",\"Oi,j​ 与 Di,j​ 的计算：\",\"O=obstacle_map(1:x,2:y+1)+obstacle_map(3:x+2,2:y+1)+obstacle_map(2:x+1,1:y)+obstacle_map(2:x+1,3:y+2)+obstacle_map(1:x,1:y)+obstacle_map(3:x+2,1:y)+obstacle_map(1:x,3:y+2)+obstacle_map(3:x+2,3:y+2); D=Sm(1:x,2:y+1)+Sm(3:x+2,2:y+1)+Sm(2:x+1,1:y)+Sm(2:x+1,3:y+2)+Sm(1:x,1:y)+Sm(3:x+2,1:y)+Sm(1:x,3:y+2)+Sm(3:x+2,3:y+2); \",\"这段代码思想为用一个 n-2×n-2 大小的滑动窗口在 n×n 的平台上，依次从需要计算的 8 个周边位置滑动，最后得到所求，可以自己手动画一个图验证一下。\",\"计算元胞潜力：\",\"% 计算原胞潜力 N for f = 1:size(final_y,2) for i=1:x for j=1:y N(i,j,f)=border(i,j)*exp(-5*Dis(i,j,f)+D(i,j)+O(i,j)); end end end for i = 1:size(final_y,2) N(final_y(i)+1,final_x(i)+1)=1e10; % 设置出口原胞潜力为 1e10，可视为无穷大 end N_1 = max(N(:,:,1),N(:,:,2)); %最大作为原胞潜力 N N_2 = max(N(:,:,3),N(:,:,4)); N_choose = max(N_1,N_2); \",\"这里因为有四个入口，所以需要分别计算四个出口的元胞潜力大小，最后取最大。\",\"位置更新：\",\"for j=h+1:-1:2 for i=2:n+1 if(border(i,j)==0) %如果位置（即原胞）有人，计算所有邻居原胞的原胞潜力N % 计算位置1到9各原胞潜力大小，并进行归一化处理 for xy = po pp(1,xy) = N_choose(i+neigh(xy,2),j+neigh(xy,1)); end prob = pp/sum(pp); if sum([pp(2),pp(3),pp(6),pp(8),pp(9)]~=0) % 上下前三个方向不全都有人 S=randsrc(1,1,[po;prob]); %依原胞潜力N，选择下一位置，即进行位置更新 else S = 5; end k = i + neigh(S,2); t = j + neigh(S,1); if platform(k-1,t-1)==0 % 选择新位置已占，则选回原位置 S = 5; k = i + neigh(S,2); t = j + neigh(S,1); end platform(i-1,j-1)=1; % 位置更新，原来原胞更新为空状态 platform(k-1,t-1)=0; % 位置更新，新选择原胞更新为占有状态 end end end \",\"这里用 border 矩阵进行计算，然后在 platform 上进行更新，最后把再 border = platform ，从而实现每一次迭代的整体更新。此外，代码设定，如果上下和前面三个位置共 5 个位置没有人的话才进行选择，否则就待在原地，贴近现实中人是向前走的；如果选择的位置被占，则待在原地。代码从离平台近的位置向远处开始遍历，反应人流变化的方向与源头。\"]},\"88\":{\"h\":\"结果\",\"t\":[\"图4 动态演示\",\"图5 热力图（迭代周期960s）\",\"完整代码\"]},\"89\":{\"c\":[\"交通\"]},\"90\":{\"c\":[\"traffic\"]},\"91\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"92\":{\"h\":\"ML\"},\"93\":{\"h\":\"English\"},\"94\":{\"h\":\"Path\"},\"95\":{\"h\":\"Traffic\"}},\"dirtCount\":0,\"index\":[[\"热力图\",{\"1\":{\"88\":1}}],[\"动态演示\",{\"1\":{\"88\":1}}],[\"贴近现实中人是向前走的\",{\"1\":{\"87\":1}}],[\"矩阵进行计算\",{\"1\":{\"87\":1}}],[\"新选择原胞更新为占有状态\",{\"1\":{\"87\":1}}],[\"上进行更新\",{\"1\":{\"87\":1}}],[\"上下前三个方向不全都有人\",{\"1\":{\"87\":1}}],[\"上采样\",{\"1\":{\"6\":1}}],[\"~=0\",{\"1\":{\"87\":1}}],[\"依原胞潜力n\",{\"1\":{\"87\":1}}],[\"依次从需要计算的\",{\"1\":{\"87\":1}}],[\"依赖于全部的数据\",{\"1\":{\"15\":1}}],[\"依赖数据表达的距离测度\",{\"1\":{\"15\":1}}],[\"参数计算\",{\"0\":{\"87\":1}}],[\"参数设置\",{\"0\":{\"86\":1}}],[\"外加了两圈障碍\",{\"1\":{\"86\":1}}],[\"外加了一圈障碍\",{\"1\":{\"86\":1}}],[\"记录时刻平台信息\",{\"1\":{\"86\":1}}],[\"迭代周期960s\",{\"1\":{\"88\":1}}],[\"迭代时间\",{\"1\":{\"86\":1}}],[\"迭代次数截断\",{\"1\":{\"11\":1}}],[\"迭代次数\",{\"1\":{\"10\":1}}],[\"到达终点人数\",{\"1\":{\"86\":1}}],[\"出发人数\",{\"1\":{\"86\":1}}],[\"出口\",{\"1\":{\"86\":1}}],[\"概率矩阵\",{\"1\":{\"86\":1}}],[\"概述\",{\"0\":{\"80\":1}}],[\"预留内存\",{\"1\":{\"86\":2}}],[\"预剪枝基于\",{\"1\":{\"13\":1}}],[\"预剪枝\",{\"1\":{\"13\":2}}],[\"位置矩阵\",{\"1\":{\"86\":1}}],[\"位置更新\",{\"1\":{\"70\":1,\"87\":3}}],[\"初始迭代次数\",{\"1\":{\"86\":1}}],[\"初始化平台\",{\"1\":{\"86\":1}}],[\"设置出口原胞潜力为\",{\"1\":{\"87\":1}}],[\"设置障碍\",{\"1\":{\"86\":2}}],[\"设置非障碍矩阵\",{\"1\":{\"86\":1}}],[\"障碍视为距离无穷\",{\"1\":{\"87\":1}}],[\"障碍\",{\"1\":{\"86\":1}}],[\"入口纵坐标\",{\"1\":{\"86\":1}}],[\"入口横坐标\",{\"1\":{\"86\":1}}],[\"部分代码解释\",{\"0\":{\"85\":1}}],[\"环境的动态影响\",{\"1\":{\"84\":1}}],[\"环境中静止物体的影响\",{\"1\":{\"84\":1}}],[\"处的元胞潜能\",{\"1\":{\"84\":1}}],[\"处元胞状态\",{\"1\":{\"84\":1}}],[\"代表不占有\",{\"1\":{\"84\":1}}],[\"代表占有\",{\"1\":{\"84\":1}}],[\"代表位置\",{\"1\":{\"84\":2}}],[\"代码从离平台近的位置向远处开始遍历\",{\"1\":{\"87\":1}}],[\"代码设定\",{\"1\":{\"87\":1}}],[\"代码流程图\",{\"1\":{\"85\":1}}],[\"代码整体思路如下\",{\"1\":{\"85\":1}}],[\"代码\",{\"0\":{\"75\":1}}],[\"划分为方格形\",{\"1\":{\"83\":1}}],[\"划分为三个主要分类\",{\"1\":{\"10\":1}}],[\"状态设置为占有\",{\"1\":{\"83\":1}}],[\"规定仿真时间为\",{\"1\":{\"81\":1}}],[\"均为\",{\"1\":{\"81\":1}}],[\"均值\",{\"1\":{\"21\":1}}],[\"右四个出口\",{\"1\":{\"81\":1}}],[\"大小的滑动窗口在\",{\"1\":{\"87\":1}}],[\"大小分别为\",{\"1\":{\"81\":1}}],[\"大语言模型是利用深度学习技术\",{\"1\":{\"26\":1}}],[\"左三个入口\",{\"1\":{\"81\":1}}],[\"平面示意图\",{\"1\":{\"81\":1}}],[\"平台长度\",{\"1\":{\"86\":1}}],[\"平台宽度\",{\"1\":{\"86\":1}}],[\"平台\",{\"1\":{\"81\":1}}],[\"平台基本信息\",{\"1\":{\"81\":1}}],[\"平移不变性是指输出结果对输入对小量平移基本保持不变\",{\"1\":{\"6\":1}}],[\"平移不变性\",{\"1\":{\"6\":1}}],[\"⏩\",{\"1\":{\"80\":1}}],[\"速度\",{\"1\":{\"80\":1}}],[\"速度属性\",{\"1\":{\"69\":1}}],[\"朝向\",{\"1\":{\"80\":1}}],[\"姿势\",{\"1\":{\"80\":1}}],[\"包含感知周围环境传感器的车辆的信息\",{\"1\":{\"80\":1}}],[\"包含做过语义分割处理的地图\",{\"1\":{\"80\":1}}],[\"包括了车长+距离前车的安全距离\",{\"1\":{\"69\":1}}],[\"包括其定义\",{\"1\":{\"52\":1}}],[\"视觉信息\",{\"1\":{\"80\":1}}],[\"轨迹信息\",{\"1\":{\"80\":1}}],[\"力的方向\",{\"1\":{\"80\":1}}],[\"冲突车辆\",{\"1\":{\"80\":1}}],[\"达到一定期望速度的acceleration\",{\"1\":{\"80\":1}}],[\"达到优化模型的效果\",{\"1\":{\"14\":1}}],[\"社会力模型由几种力组成\",{\"1\":{\"80\":1}}],[\"社会力模型\",{\"1\":{\"80\":1}}],[\"来模拟人与环境的交互\",{\"1\":{\"80\":1}}],[\"既研究整体特征也研究个体特征\",{\"1\":{\"80\":1}}],[\"介观\",{\"1\":{\"80\":1}}],[\"介于宏微观之间\",{\"1\":{\"80\":2}}],[\"紧急疏散人群移动特点\",{\"1\":{\"80\":1}}],[\"流向等\",{\"1\":{\"80\":1}}],[\"流程\",{\"1\":{\"12\":1}}],[\"密度\",{\"1\":{\"80\":1}}],[\"密度聚类\",{\"1\":{\"16\":1}}],[\"研究个体行为\",{\"1\":{\"80\":1}}],[\"研究整体移动特征如速度\",{\"1\":{\"80\":1}}],[\"研究行人行为及心理的特点的研究\",{\"1\":{\"80\":1}}],[\"建筑平面设计等方面有着广泛的应用\",{\"1\":{\"80\":1}}],[\"建立输入和输出之间的映射关系\",{\"1\":{\"10\":1}}],[\"疏散计划\",{\"1\":{\"80\":1}}],[\"行人随机从各个入口进入\",{\"1\":{\"81\":1}}],[\"行人每秒走一格\",{\"1\":{\"81\":1}}],[\"行人不得通过障碍\",{\"1\":{\"81\":1}}],[\"行人图像主要是反应行人的行为\",{\"1\":{\"80\":1}}],[\"行人流仿真按仿真规模可以大致分为三种\",{\"1\":{\"80\":1}}],[\"行人流仿真是通过模拟人群在不同环境下的移动\",{\"1\":{\"80\":1}}],[\"行人流仿真\",{\"0\":{\"79\":1}}],[\"行为\",{\"1\":{\"80\":1}}],[\"行驶\",{\"1\":{\"70\":1}}],[\"危害生命财产安全\",{\"1\":{\"76\":1}}],[\"避免因车辆换道引起交通事故\",{\"1\":{\"76\":1}}],[\"安全条件是指车辆在决定换道时要确定当前交通状况下换道对于自身和其他车辆是否安全\",{\"1\":{\"76\":1}}],[\"安全条件\",{\"1\":{\"76\":1}}],[\"​\",{\"1\":{\"76\":1}}],[\"​>dsafe\",{\"1\":{\"76\":1}}],[\"​>dn​⋯​\",{\"1\":{\"76\":1}}],[\"​s<2∨s>3s=2s=3​\",{\"1\":{\"59\":1}}],[\"换道动机是指驾驶员想换道的意愿和条件\",{\"1\":{\"76\":1}}],[\"换道动机\",{\"1\":{\"76\":1}}],[\"换道规则一般包括两个部分\",{\"1\":{\"76\":1}}],[\"两条车道上的车辆在该时步均按照单车道元胞自动机模型中设计的演化更新规则运行\",{\"1\":{\"76\":1}}],[\"两者都假设数据符合高斯分布\",{\"1\":{\"17\":1}}],[\"两者在降维时均使用了矩阵特征分解的思想\",{\"1\":{\"17\":1}}],[\"两者均可以对数据进行降维\",{\"1\":{\"17\":1}}],[\"完整代码\",{\"1\":{\"75\":1,\"88\":1}}],[\"做fd图如下\",{\"1\":{\"74\":1}}],[\"含速度\",{\"1\":{\"74\":4}}],[\"黑线为小汽车\",{\"1\":{\"74\":1}}],[\"红线为货车\",{\"1\":{\"74\":1}}],[\"条件下\",{\"1\":{\"74\":1}}],[\"单车道\",{\"1\":{\"73\":1}}],[\"单调性\",{\"1\":{\"28\":1}}],[\"车流\",{\"1\":{\"72\":1}}],[\"车辆会以一定的换道概率进行换道\",{\"1\":{\"76\":1}}],[\"车辆在这个时步内按照设计的换道规则决定是否发生换道行为\",{\"1\":{\"76\":1}}],[\"车辆以最大加速度\",{\"1\":{\"72\":1}}],[\"车辆以p的概率随机减速一个单位\",{\"1\":{\"70\":1}}],[\"车辆有最大速度限制\",{\"1\":{\"69\":1}}],[\"考虑换道\",{\"1\":{\"76\":1}}],[\"考虑异质\",{\"1\":{\"72\":1}}],[\"考虑了变量之间的相互作用\",{\"1\":{\"15\":1}}],[\"引入慢启动系数s\",{\"1\":{\"72\":1}}],[\"加减速而不是以1\",{\"1\":{\"72\":1}}],[\"加速\",{\"1\":{\"70\":1}}],[\"驾驶员的这一行为会引起交通系统的一系列反应\",{\"1\":{\"70\":1}}],[\"驾驶员不可能总是按照一定速度\",{\"1\":{\"70\":1}}],[\"总会有一定的波动\",{\"1\":{\"70\":1}}],[\"所有车辆同步更新\",{\"1\":{\"69\":1}}],[\"所以需要分别计算四个出口的元胞潜力大小\",{\"1\":{\"87\":1}}],[\"所以需要对数据先做\",{\"1\":{\"15\":1}}],[\"所以最后\",{\"1\":{\"84\":1}}],[\"所以便有了现在这个页面\",{\"1\":{\"1\":1}}],[\"所以迟迟不肯行动\",{\"1\":{\"1\":1}}],[\"堵塞密度kj\",{\"1\":{\"74\":1}}],[\"堵塞密度\",{\"1\":{\"67\":1}}],[\"临界速度vc\",{\"1\":{\"74\":1}}],[\"临界速度\",{\"1\":{\"67\":1}}],[\"临界密度kc\",{\"1\":{\"74\":1}}],[\"临界密度\",{\"1\":{\"67\":1}}],[\"畅行速度vf\",{\"1\":{\"74\":1}}],[\"畅行速度\",{\"1\":{\"67\":1}}],[\"极大流率qm\",{\"1\":{\"74\":1}}],[\"极大流率对应的速度\",{\"1\":{\"67\":1}}],[\"极大流率对应的密度\",{\"1\":{\"67\":1}}],[\"极大流率\",{\"1\":{\"67\":1}}],[\"更新规则即行人如何选择下一步走到哪里一个方格\",{\"1\":{\"84\":1}}],[\"更新规则\",{\"0\":{\"70\":1,\"84\":1}}],[\"更加危险\",{\"1\":{\"66\":1}}],[\"更费油与更多排放\",{\"1\":{\"66\":1}}],[\"更方便优化\",{\"1\":{\"6\":1}}],[\"宏观\",{\"1\":{\"66\":1,\"80\":2}}],[\"形成原因\",{\"1\":{\"66\":1}}],[\"形成stop\",{\"1\":{\"66\":1}}],[\"字面意是停走波\",{\"1\":{\"66\":1}}],[\"结果\",{\"0\":{\"74\":1,\"88\":1},\"1\":{\"66\":1}}],[\"内含动画演示\",{\"1\":{\"75\":1}}],[\"内生性的交通拥堵\",{\"1\":{\"66\":1}}],[\"内容方面有待优化\",{\"1\":{\"1\":1}}],[\"微观\",{\"1\":{\"66\":1,\"80\":2}}],[\"微小的交通扰动\",{\"1\":{\"66\":1}}],[\"微调\",{\"1\":{\"26\":1}}],[\"莫名发生的交通拥堵\",{\"1\":{\"66\":1}}],[\"幽灵拥堵\",{\"0\":{\"66\":1}}],[\"他们的状态有以下8种\",{\"1\":{\"65\":1}}],[\"补充一下基于ca交通仿真中最常见的规则\",{\"1\":{\"65\":1}}],[\"改进点\",{\"0\":{\"72\":1}}],[\"改进ns模型以及对应代码的实现\",{\"1\":{\"62\":1}}],[\"改进ns模型\",{\"0\":{\"62\":1,\"71\":1}}],[\"改变了问题的复杂度\",{\"1\":{\"15\":1}}],[\"英文总结\",{\"1\":{\"60\":1}}],[\"英语\",{\"1\":{\"4\":1}}],[\"化学\",{\"1\":{\"60\":1}}],[\"化表示\",{\"1\":{\"10\":1}}],[\"作为物理\",{\"1\":{\"60\":1}}],[\"作用是在训练阶段的第三个步骤中\",{\"1\":{\"14\":1}}],[\"作用请从机器学习训练阶段的三个步骤的角度来阐述\",{\"1\":{\"14\":1}}],[\"作用\",{\"1\":{\"10\":3}}],[\"应用\",{\"0\":{\"60\":1}}],[\"应用等方面\",{\"1\":{\"52\":1}}],[\"图5\",{\"1\":{\"88\":1}}],[\"图4\",{\"1\":{\"88\":1}}],[\"图\",{\"1\":{\"86\":1}}],[\"图3\",{\"1\":{\"85\":1}}],[\"图2\",{\"1\":{\"59\":1,\"84\":1}}],[\"图1\",{\"1\":{\"56\":1,\"81\":1}}],[\"νt\",{\"1\":{\"59\":1}}],[\"α\",{\"1\":{\"59\":2}}],[\"死\",{\"1\":{\"59\":1}}],[\"死亡\",{\"1\":{\"59\":2}}],[\"否则就待在原地\",{\"1\":{\"87\":1}}],[\"否则就变为\",{\"1\":{\"59\":1}}],[\"否则维持原速\",{\"1\":{\"70\":1}}],[\"否则继续保持\",{\"1\":{\"59\":1}}],[\"生物过程的基础模型\",{\"1\":{\"60\":1}}],[\"生\",{\"1\":{\"59\":2}}],[\"生命游戏是最著名的二维元胞自动机生命游戏\",{\"1\":{\"59\":1}}],[\"生命游戏\",{\"0\":{\"59\":1},\"1\":{\"59\":1}}],[\"则待在原地\",{\"1\":{\"87\":1}}],[\"则选回原位置\",{\"1\":{\"87\":1}}],[\"则汽车减速为安全距离\",{\"1\":{\"70\":1}}],[\"则该格变为\",{\"1\":{\"59\":1}}],[\"则该格继续保持\",{\"1\":{\"59\":1}}],[\"则无论该神经网络有多少层\",{\"1\":{\"14\":1}}],[\"若它的\",{\"1\":{\"59\":2}}],[\"活着\",{\"1\":{\"59\":3}}],[\"邻居中有\",{\"1\":{\"59\":1}}],[\"邻居\",{\"1\":{\"59\":1}}],[\"邻居定义为\",{\"1\":{\"56\":1}}],[\"邻居定义为下式\",{\"1\":{\"56\":1}}],[\"或活着\",{\"1\":{\"59\":1}}],[\"或自顶向下的分裂聚类\",{\"1\":{\"16\":1}}],[\"年设计\",{\"1\":{\"59\":1}}],[\"年代在洛斯阿拉莫斯国家实验室同时提出\",{\"1\":{\"53\":1}}],[\"高维度\",{\"1\":{\"58\":1}}],[\"高斯核\",{\"1\":{\"15\":1}}],[\"服从相同的规律分布方式相同\",{\"1\":{\"58\":1}}],[\"同质性\",{\"1\":{\"58\":1}}],[\"同时计算复杂度可能会较高\",{\"1\":{\"15\":1}}],[\"同时减小了下一层的输入大小\",{\"1\":{\"6\":1}}],[\"空间时间上均离散化\",{\"1\":{\"69\":1}}],[\"空间\",{\"1\":{\"58\":1}}],[\"离散型\",{\"1\":{\"58\":1}}],[\"由力的大小决定\",{\"1\":{\"80\":1}}],[\"由rickert\",{\"1\":{\"76\":1}}],[\"由上图可以看到stop\",{\"1\":{\"66\":1}}],[\"由john\",{\"1\":{\"59\":1}}],[\"由局部到整体\",{\"1\":{\"58\":1}}],[\"由求特征向量转化为求比例系数\",{\"1\":{\"15\":1}}],[\"映射型\",{\"1\":{\"57\":1}}],[\"虚拟的元胞\",{\"1\":{\"57\":1}}],[\"注\",{\"1\":{\"57\":1}}],[\"绝热型\",{\"1\":{\"57\":1}}],[\"绝热型和映射型这四种\",{\"1\":{\"57\":1}}],[\"绝对的宿命论主义倾向\",{\"1\":{\"3\":1}}],[\"周围行人\",{\"1\":{\"80\":1}}],[\"周期边界\",{\"1\":{\"73\":1}}],[\"周期型\",{\"1\":{\"57\":2}}],[\"周边盆友的影响👬\",{\"1\":{\"2\":1}}],[\"固定型\",{\"1\":{\"57\":2}}],[\"边界矩阵\",{\"1\":{\"86\":1}}],[\"边界矩阵长\",{\"1\":{\"86\":1}}],[\"边界矩阵宽\",{\"1\":{\"86\":1}}],[\"边界元胞为元胞每个维度内侧邻近元胞\",{\"1\":{\"57\":1}}],[\"边界元胞与自己相同\",{\"1\":{\"57\":1}}],[\"边界条件是元胞空间外的部分\",{\"1\":{\"57\":1}}],[\"边界条件\",{\"0\":{\"57\":1},\"1\":{\"83\":1}}],[\"边界点和噪声点\",{\"1\":{\"16\":1}}],[\"∣x−x0​∣+∣y−y0​∣<=r\",{\"1\":{\"56\":1}}],[\"∣x−x0​∣<=r\",{\"1\":{\"56\":1}}],[\"∣y−y0​∣<=r\",{\"1\":{\"56\":1}}],[\"∣v∣+∣e∣\",{\"1\":{\"40\":2}}],[\"型\",{\"1\":{\"56\":1,\"83\":1}}],[\"型和\",{\"1\":{\"56\":1}}],[\"取决于元胞状态更新时所要搜索的空间域\",{\"1\":{\"56\":1}}],[\"复杂情况下也有多维\",{\"1\":{\"54\":1}}],[\"复杂度只与样本数量有关\",{\"1\":{\"15\":1}}],[\"元胞潜力\",{\"1\":{\"86\":1}}],[\"元胞潜能可以写为\",{\"1\":{\"84\":1}}],[\"元胞动态势能反应行人在选择下一步时\",{\"1\":{\"84\":1}}],[\"元胞静态势能反应了行人在选择下一步时\",{\"1\":{\"84\":1}}],[\"元胞的状态更新规则变化是同步进行的\",{\"1\":{\"58\":1}}],[\"元胞类型\",{\"1\":{\"56\":1}}],[\"元胞呈一定形状\",{\"1\":{\"55\":1}}],[\"元胞是\",{\"1\":{\"54\":1}}],[\"元胞规则是整个\",{\"1\":{\"58\":1}}],[\"元胞规则即每次迭代\",{\"1\":{\"58\":1}}],[\"元胞规则\",{\"0\":{\"58\":1},\"1\":{\"53\":1}}],[\"元胞边界\",{\"1\":{\"53\":1}}],[\"元胞邻居是某一元胞周围的元胞\",{\"1\":{\"56\":1}}],[\"元胞邻居\",{\"0\":{\"56\":1},\"1\":{\"53\":1,\"83\":1}}],[\"元胞空间划分方式大致有\",{\"1\":{\"55\":1}}],[\"元胞空间为空间内元胞的集合\",{\"1\":{\"55\":1}}],[\"元胞空间\",{\"0\":{\"55\":1},\"1\":{\"53\":1,\"83\":1}}],[\"元胞\",{\"0\":{\"54\":1},\"1\":{\"53\":1,\"83\":1}}],[\"元胞自动机模型\",{\"1\":{\"80\":1}}],[\"元胞自动机的应用大致有以下几类\",{\"1\":{\"60\":1}}],[\"元胞自动机是一类无穷维动力系统\",{\"1\":{\"58\":1}}],[\"元胞自动机更新规则特征\",{\"1\":{\"58\":1}}],[\"元胞自动机\",{\"0\":{\"52\":1},\"1\":{\"53\":1}}],[\"世纪\",{\"1\":{\"53\":1}}],[\"世界杯\",{\"1\":{\"3\":1}}],[\"世界之本质\",{\"1\":{\"3\":1}}],[\"于\",{\"1\":{\"53\":1}}],[\"¬in\",{\"1\":{\"50\":2}}],[\"<\",{\"1\":{\"48\":1}}],[\"←\",{\"1\":{\"48\":3}}],[\"$\",{\"1\":{\"47\":1,\"86\":4}}],[\"$u\",{\"1\":{\"47\":1}}],[\"∞\",{\"1\":{\"45\":15,\"46\":8,\"47\":10,\"48\":1}}],[\"→maxv\",{\"1\":{\"70\":1}}],[\"→minv\",{\"1\":{\"70\":2}}],[\"→g1∗​\",{\"1\":{\"45\":1}}],[\"→gk−1∗​\",{\"1\":{\"45\":1}}],[\"→gk∗​\",{\"1\":{\"45\":2}}],[\"→\",{\"1\":{\"45\":2,\"66\":4}}],[\"πk​\",{\"1\":{\"43\":2}}],[\"^2\",{\"1\":{\"87\":1}}],[\"^2+\",{\"1\":{\"87\":1}}],[\"^\",{\"1\":{\"41\":2}}],[\"+o\",{\"1\":{\"87\":1}}],[\"+obstacle\",{\"1\":{\"87\":7}}],[\"+d\",{\"1\":{\"87\":1}}],[\"+sm\",{\"1\":{\"87\":7}}],[\"+2\",{\"1\":{\"86\":4}}],[\"+1\",{\"1\":{\"70\":1,\"87\":4}}],[\"+ck−1∗​\",{\"1\":{\"46\":1}}],[\"+l\",{\"1\":{\"47\":1}}],[\"+li​\",{\"1\":{\"46\":1}}],[\"+lf​\",{\"1\":{\"43\":1,\"45\":1}}],[\"+g∗\",{\"1\":{\"47\":1}}],[\"+g3∗​\",{\"1\":{\"45\":2}}],[\"+g5∗​\",{\"1\":{\"45\":4}}],[\"+gk+1∗​\",{\"1\":{\"45\":1}}],[\"+\",{\"1\":{\"40\":1,\"48\":2,\"50\":1,\"80\":1,\"87\":5}}],[\"qm逐渐减小\",{\"1\":{\"74\":1}}],[\"qk曲线极值\",{\"1\":{\"67\":1}}],[\"quite\",{\"1\":{\"50\":1}}],[\"queue\",{\"1\":{\"40\":1,\"41\":1,\"42\":1,\"48\":2}}],[\"quality\",{\"1\":{\"27\":2}}],[\"q\",{\"1\":{\"39\":4,\"40\":5,\"41\":11,\"42\":1,\"48\":4}}],[\"−1\",{\"1\":{\"37\":2,\"70\":1}}],[\"zeros\",{\"1\":{\"86\":2,\"87\":1}}],[\"z\",{\"1\":{\"37\":1}}],[\"j+neigh\",{\"1\":{\"87\":1}}],[\"j=h+1\",{\"1\":{\"87\":1}}],[\"j=1\",{\"1\":{\"87\":2}}],[\"j​+k3​di\",{\"1\":{\"84\":1}}],[\"j​+k2​oi\",{\"1\":{\"84\":1}}],[\"j​+ko​oi\",{\"1\":{\"84\":1}}],[\"j​+kd​di\",{\"1\":{\"84\":1}}],[\"j​=kl​li\",{\"1\":{\"84\":1}}],[\"j​=0\",{\"1\":{\"84\":1}}],[\"j​=ei\",{\"1\":{\"84\":2}}],[\"j​\",{\"1\":{\"84\":11,\"87\":3}}],[\"j​exp\",{\"1\":{\"84\":2}}],[\"judgment\",{\"1\":{\"70\":1}}],[\"just\",{\"1\":{\"38\":1,\"40\":1,\"50\":1}}],[\"jam\",{\"0\":{\"66\":1},\"1\":{\"66\":2,\"67\":1,\"70\":1}}],[\"j∈z\",{\"1\":{\"37\":1}}],[\"j\",{\"1\":{\"37\":2,\"84\":5,\"86\":2,\"87\":11}}],[\"xy\",{\"1\":{\"87\":4}}],[\"x+1\",{\"1\":{\"87\":4}}],[\"x+2\",{\"1\":{\"87\":6}}],[\"x=n+2\",{\"1\":{\"86\":1}}],[\"x0​\",{\"1\":{\"56\":2}}],[\"xd​\",{\"1\":{\"46\":1}}],[\"xb​\",{\"1\":{\"46\":1}}],[\"xe​\",{\"1\":{\"46\":1}}],[\"xc​\",{\"1\":{\"46\":1}}],[\"x=xi​\",{\"1\":{\"46\":1}}],[\"x5​\",{\"1\":{\"45\":7}}],[\"x2​\",{\"1\":{\"45\":2}}],[\"x3​\",{\"1\":{\"45\":4}}],[\"x4​=b\",{\"1\":{\"45\":1}}],[\"x4​\",{\"1\":{\"45\":5}}],[\"x1​\",{\"1\":{\"43\":1,\"45\":4,\"46\":2}}],[\"xf​∈xg​\",{\"1\":{\"43\":1}}],[\"xf​\",{\"1\":{\"43\":4,\"45\":2}}],[\"xk\",{\"1\":{\"45\":2}}],[\"xk−1​\",{\"1\":{\"45\":1,\"46\":2}}],[\"xk​∈xanduk​∈u\",{\"1\":{\"43\":1}}],[\"xk​\",{\"1\":{\"43\":6,\"45\":7,\"46\":4}}],[\"xk+1​\",{\"1\":{\"43\":3,\"45\":2}}],[\"xnew\",{\"1\":{\"42\":1}}],[\"xg\",{\"1\":{\"48\":2}}],[\"xg​=d\",{\"1\":{\"45\":1}}],[\"xg​\",{\"1\":{\"40\":2,\"42\":2,\"43\":1,\"45\":1,\"46\":1,\"48\":4}}],[\"xg​∈x\",{\"1\":{\"36\":1}}],[\"xg=\",{\"1\":{\"37\":1}}],[\"xi​=a\",{\"1\":{\"45\":1}}],[\"xi​\",{\"1\":{\"39\":1,\"42\":2,\"43\":1,\"45\":1,\"46\":4}}],[\"xi​∈x\",{\"1\":{\"36\":1}}],[\"xi\",{\"1\":{\"39\":1,\"41\":2,\"48\":3}}],[\"xi=\",{\"1\":{\"37\":1}}],[\"x∈xg​\",{\"1\":{\"39\":1,\"47\":1}}],[\"x∈x\",{\"1\":{\"36\":1,\"37\":1}}],[\"x\",{\"1\":{\"36\":7,\"37\":5,\"39\":18,\"40\":4,\"41\":36,\"42\":6,\"43\":3,\"46\":1,\"47\":18,\"48\":15,\"56\":2,\"86\":8,\"87\":10}}],[\"960s\",{\"1\":{\"81\":1}}],[\"9739\",{\"1\":{\"74\":1}}],[\"99\",{\"1\":{\"74\":1}}],[\"9054\",{\"1\":{\"74\":1}}],[\"9176\",{\"1\":{\"74\":1}}],[\"9\",{\"1\":{\"32\":1,\"39\":1,\"48\":1,\"84\":2,\"86\":4,\"87\":1}}],[\"y+2\",{\"1\":{\"87\":6}}],[\"y+1\",{\"1\":{\"87\":4}}],[\"y=h+2\",{\"1\":{\"86\":1}}],[\"y=x\",{\"1\":{\"6\":1}}],[\"y\",{\"1\":{\"56\":2,\"86\":11,\"87\":15}}],[\"y0​\",{\"1\":{\"56\":2}}],[\"yes\",{\"1\":{\"48\":1}}],[\"yet\",{\"1\":{\"39\":1,\"42\":1,\"48\":1}}],[\"yield\",{\"1\":{\"46\":1}}],[\"yields\",{\"1\":{\"31\":1,\"43\":1,\"46\":1,\"47\":2,\"50\":1}}],[\"you\",{\"1\":{\"45\":3,\"47\":1}}],[\"地图主要是反应道路周围的环境\",{\"1\":{\"80\":1}}],[\"地\",{\"1\":{\"28\":1}}],[\"向前的\",{\"1\":{\"28\":1}}],[\"事\",{\"1\":{\"28\":1}}],[\"事故等紧急情况下的交通状况\",{\"1\":{\"27\":1}}],[\"防止\",{\"1\":{\"28\":1}}],[\"阻止\",{\"1\":{\"28\":1}}],[\"肤浅的\",{\"1\":{\"28\":1}}],[\"难以去做的\",{\"1\":{\"28\":1}}],[\"沉重的\",{\"1\":{\"28\":1}}],[\"笨重的\",{\"1\":{\"28\":1}}],[\"渐进的\",{\"1\":{\"28\":1}}],[\"遗忘\",{\"1\":{\"28\":1}}],[\"忽略\",{\"1\":{\"28\":1}}],[\"忽略了真实的输入输出\",{\"1\":{\"11\":1}}],[\"省略\",{\"1\":{\"28\":1}}],[\"重复出现\",{\"1\":{\"28\":1}}],[\"重复因而不必要的\",{\"1\":{\"28\":1}}],[\"重新组织已有的知识结构\",{\"1\":{\"10\":1}}],[\"冗余的\",{\"1\":{\"28\":1}}],[\"拥堵和行人安全的影响\",{\"1\":{\"27\":1}}],[\"帮助制定有效的应急响应策略\",{\"1\":{\"27\":1}}],[\"帮助规划者评估其对交通流量\",{\"1\":{\"27\":1}}],[\"帮助开发更为智能的决策方案\",{\"1\":{\"27\":1}}],[\"模拟行人穿过以平台\",{\"1\":{\"81\":1}}],[\"模拟现实复杂动态系统\",{\"1\":{\"60\":1}}],[\"模拟拟不同的交通规划方案\",{\"1\":{\"27\":1}}],[\"模型设置\",{\"0\":{\"82\":1}}],[\"模型的行人流仿真\",{\"1\":{\"79\":1}}],[\"模型的基本单元\",{\"1\":{\"54\":1}}],[\"模型信息\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"模型说明\",{\"0\":{\"69\":1}}],[\"模型描述\",{\"0\":{\"68\":1}}],[\"模型最为关键的部分\",{\"1\":{\"58\":1}}],[\"模型对于交通行业影响\",{\"0\":{\"27\":1}}],[\"模型过分记住了噪声\",{\"1\":{\"11\":1}}],[\"模型复杂度过低\",{\"1\":{\"11\":1}}],[\"模型评估与选择\",{\"0\":{\"11\":1}}],[\"模型训练过程中单独留出的样本集\",{\"1\":{\"10\":1}}],[\"模型\",{\"1\":{\"10\":1,\"79\":1}}],[\"提供应急响应与安全管理案例\",{\"1\":{\"27\":1}}],[\"提供虚拟测试的平台\",{\"1\":{\"27\":1}}],[\"提供新的开发算法思路\",{\"1\":{\"27\":1}}],[\"提供高质量的真实数据用于训练与模拟\",{\"1\":{\"27\":1}}],[\"提取图像的特征\",{\"1\":{\"6\":1}}],[\"语音识别等任务的机器学习模型\",{\"1\":{\"26\":1}}],[\"适应能力的\",{\"1\":{\"26\":1}}],[\"适用于大型数据集\",{\"1\":{\"16\":1}}],[\"适用于线性可分的数据集\",{\"1\":{\"15\":1}}],[\"理解\",{\"1\":{\"26\":1}}],[\"具体讲解可以看这篇文章与这篇文章\",{\"1\":{\"52\":1}}],[\"具体解释\",{\"1\":{\"14\":1}}],[\"具有学习\",{\"1\":{\"26\":1}}],[\"得到的具有\",{\"1\":{\"26\":1}}],[\"架构等\",{\"1\":{\"26\":1}}],[\"前进\",{\"1\":{\"80\":1}}],[\"前方的空元胞数\",{\"1\":{\"70\":1}}],[\"前沿科技\",{\"0\":{\"25\":1}}],[\"前向型和反馈型\",{\"1\":{\"14\":1}}],[\"信息增益或熵\",{\"1\":{\"23\":1}}],[\"杂质\",{\"1\":{\"23\":1}}],[\"间隔\",{\"1\":{\"22\":1}}],[\"支持向量\",{\"1\":{\"22\":1}}],[\"支持向量机采用核函数的机制\",{\"1\":{\"15\":1}}],[\"支持向量机只考虑局部的边界线附近的点\",{\"1\":{\"15\":1}}],[\"支持向量机\",{\"0\":{\"15\":1},\"1\":{\"10\":1,\"22\":1}}],[\"超平面\",{\"1\":{\"22\":1}}],[\"h+1\",{\"1\":{\"87\":1}}],[\"h+2\",{\"1\":{\"86\":3,\"87\":1}}],[\"h+4\",{\"1\":{\"86\":2}}],[\"h\",{\"1\":{\"86\":4,\"87\":1}}],[\"hurdle\",{\"1\":{\"86\":11,\"87\":3}}],[\"h=30\",{\"1\":{\"86\":1}}],[\"hold\",{\"1\":{\"50\":3}}],[\"hopes\",{\"1\":{\"49\":1}}],[\"how\",{\"1\":{\"31\":1,\"39\":2,\"47\":4}}],[\"however\",{\"1\":{\"28\":1,\"47\":1,\"50\":1}}],[\"head\",{\"1\":{\"80\":1}}],[\"heavy\",{\"1\":{\"66\":2}}],[\"hence\",{\"1\":{\"45\":1}}],[\"heuristic\",{\"1\":{\"40\":1}}],[\"here\",{\"1\":{\"39\":1,\"43\":1,\"45\":2,\"46\":1,\"47\":1,\"50\":2}}],[\"helicopter\",{\"1\":{\"31\":1}}],[\"helps\",{\"1\":{\"18\":1,\"19\":1}}],[\"hierarchical\",{\"1\":{\"31\":4}}],[\"high\",{\"1\":{\"27\":2}}],[\"higher\",{\"1\":{\"22\":1,\"48\":1}}],[\"have\",{\"1\":{\"39\":4,\"40\":1,\"48\":1,\"49\":1,\"50\":2}}],[\"has\",{\"1\":{\"31\":1,\"37\":1,\"39\":2,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":1,\"60\":2,\"69\":1,\"70\":1}}],[\"handled\",{\"1\":{\"47\":1}}],[\"handle\",{\"1\":{\"26\":1,\"27\":1}}],[\"http\",{\"1\":{\"29\":1}}],[\"hyperplane\",{\"1\":{\"22\":4}}],[\"质心\",{\"1\":{\"21\":1}}],[\"簇\",{\"1\":{\"21\":1}}],[\"簇数的预先指定\",{\"1\":{\"16\":1}}],[\"折交叉验证\",{\"1\":{\"19\":1}}],[\"惩罚项\",{\"1\":{\"18\":1}}],[\"还可以用于分类\",{\"1\":{\"17\":1}}],[\"还有很多排版\",{\"1\":{\"1\":1}}],[\"除了可以用于降维\",{\"1\":{\"17\":1}}],[\"除训练集外所有样本\",{\"1\":{\"11\":1}}],[\"没有这个限制\",{\"1\":{\"17\":1}}],[\"没有将排名分数作为直接结果\",{\"1\":{\"15\":1}}],[\"之间的区别和联系\",{\"1\":{\"17\":1}}],[\"八\",{\"0\":{\"17\":1}}],[\"特别是在大型数据集上\",{\"1\":{\"16\":1}}],[\"特征值\",{\"1\":{\"20\":1}}],[\"特征向量\",{\"1\":{\"20\":1}}],[\"特征量过少\",{\"1\":{\"11\":1}}],[\"特征降维\",{\"1\":{\"6\":1}}],[\"特征不变性\",{\"1\":{\"6\":1}}],[\"次之\",{\"1\":{\"16\":1}}],[\"计算位置1到9各原胞潜力大小\",{\"1\":{\"87\":1}}],[\"计算所有邻居原胞的原胞潜力n\",{\"1\":{\"87\":1}}],[\"计算原胞潜力\",{\"1\":{\"87\":1}}],[\"计算元胞潜力\",{\"1\":{\"87\":1}}],[\"计算单元\",{\"1\":{\"60\":1}}],[\"计算机视觉\",{\"1\":{\"26\":1}}],[\"计算复杂度\",{\"1\":{\"16\":1}}],[\"计算量相对大\",{\"1\":{\"6\":1}}],[\"计算量大\",{\"1\":{\"6\":1}}],[\"能够理解和生成高质量的文本提示\",{\"1\":{\"27\":1}}],[\"能够发现各种形状和密度的簇\",{\"1\":{\"16\":1}}],[\"能够处理多任务如自然语言处理\",{\"1\":{\"26\":1}}],[\"能够处理非线性特征之间的相互作用\",{\"1\":{\"15\":1}}],[\"能够处理非线性可分的数据集\",{\"1\":{\"15\":1}}],[\"能够处理非线性可分的数据集和噪声数据\",{\"1\":{\"15\":1}}],[\"能够处理大型特征空间\",{\"1\":{\"15\":1}}],[\"假定簇是球形且密度均匀\",{\"1\":{\"16\":1}}],[\"假设数据本身是线性可分的\",{\"1\":{\"15\":1}}],[\"合并或分裂的决定需要检查和估算大量的对象或簇\",{\"1\":{\"16\":1}}],[\"时空图\",{\"1\":{\"66\":1}}],[\"时间及状态都是离散的\",{\"1\":{\"58\":1}}],[\"时间复杂性至少是\",{\"1\":{\"16\":1}}],[\"时是留一法\",{\"1\":{\"11\":1}}],[\"可视为无穷大\",{\"1\":{\"87\":1}}],[\"可视化结果以树状结构呈现\",{\"1\":{\"16\":1}}],[\"可能需要调整半径参数和最小邻居数\",{\"1\":{\"16\":1}}],[\"可能会导致低质量的聚类结果\",{\"1\":{\"16\":1}}],[\"可以自己手动画一个图验证一下\",{\"1\":{\"87\":1}}],[\"可以自然地引入核函数\",{\"1\":{\"15\":1}}],[\"可以发现\",{\"1\":{\"84\":1}}],[\"可以是2d平面图\",{\"1\":{\"80\":1}}],[\"可以看到随着货车比例的增加\",{\"1\":{\"74\":1}}],[\"可以将它们识别为噪声\",{\"1\":{\"16\":1}}],[\"可以根据需要切割簇\",{\"1\":{\"16\":1}}],[\"可以在聚类的同时发现异常点\",{\"1\":{\"16\":1}}],[\"可以对任意形状的稠密数据集进行聚类\",{\"1\":{\"16\":1}}],[\"可以处理非线性特征\",{\"1\":{\"15\":1}}],[\"可以控制对分类错误的容忍程度\",{\"1\":{\"15\":1}}],[\"可以分为\",{\"1\":{\"14\":1}}],[\"可以加入非线性因素\",{\"1\":{\"14\":1}}],[\"可以使得得到的模型更为稳健\",{\"1\":{\"11\":1}}],[\"可以跟人一样聪明\",{\"1\":{\"10\":1}}],[\"凝聚型\",{\"1\":{\"16\":1}}],[\"每个行人占一格\",{\"1\":{\"81\":1}}],[\"每个个体有着独特的行为特征\",{\"1\":{\"80\":1}}],[\"每个个体没有行为特征\",{\"1\":{\"80\":1}}],[\"每个车辆前进当前速度的格数\",{\"1\":{\"70\":1}}],[\"每个车辆拥有坐标\",{\"1\":{\"69\":1}}],[\"每个元胞为空或仅被一辆车占据\",{\"1\":{\"69\":1}}],[\"每个元胞长7\",{\"1\":{\"69\":1}}],[\"每个元胞按照该规则进行状态更新\",{\"1\":{\"58\":1}}],[\"每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态\",{\"1\":{\"58\":1}}],[\"每个维度的第一个元胞与最后一个元胞互为边界\",{\"1\":{\"57\":1}}],[\"每个簇包含最接近其质心的数据点\",{\"1\":{\"16\":1}}],[\"每一个元胞都有一个状态\",{\"1\":{\"54\":1}}],[\"每一维对应一个特征\",{\"1\":{\"10\":1}}],[\"个周边位置滑动\",{\"1\":{\"87\":1}}],[\"个位置没有人的话才进行选择\",{\"1\":{\"87\":1}}],[\"个位置的选择概率\",{\"1\":{\"84\":1}}],[\"个位置进行标号\",{\"1\":{\"84\":1}}],[\"个邻居中有\",{\"1\":{\"59\":1}}],[\"个为\",{\"1\":{\"59\":1}}],[\"个\",{\"1\":{\"59\":2,\"86\":1}}],[\"个簇\",{\"1\":{\"16\":1}}],[\"个人觉得这并不是一个很严重的缺点\",{\"1\":{\"15\":1}}],[\"工作原理\",{\"1\":{\"16\":3}}],[\"层次聚类和\",{\"1\":{\"16\":1}}],[\"层次聚类会生成层次结构\",{\"1\":{\"16\":1}}],[\"层次聚类将数据集逐渐分割或合并成不同的层次簇\",{\"1\":{\"16\":1}}],[\"层次聚类\",{\"1\":{\"16\":2}}],[\"聚类收敛时间较长\",{\"1\":{\"16\":1}}],[\"聚类结果没有偏倚\",{\"1\":{\"16\":1}}],[\"聚类之间不能交换对象\",{\"1\":{\"16\":1}}],[\"聚类方法原理\",{\"1\":{\"16\":1}}],[\"聚类方法分类\",{\"1\":{\"16\":1}}],[\"聚类\",{\"0\":{\"16\":1},\"1\":{\"16\":1}}],[\"七\",{\"0\":{\"16\":1}}],[\"求解的是\",{\"1\":{\"15\":1}}],[\"求解的复杂度与样本的维度有关即\",{\"1\":{\"15\":1}}],[\"求导涉及除法\",{\"1\":{\"6\":1}}],[\"效率并不是很高\",{\"1\":{\"15\":1}}],[\"随着货车比例r的增加\",{\"1\":{\"74\":1}}],[\"随机慢化概率p以及慢启动系数s\",{\"1\":{\"74\":1}}],[\"随机慢化\",{\"1\":{\"70\":1}}],[\"随机森林克服了此缺点\",{\"1\":{\"15\":1}}],[\"随笔等其他内容\",{\"1\":{\"4\":1}}],[\"直观的决策规则\",{\"1\":{\"15\":1}}],[\"当元胞占有时\",{\"1\":{\"84\":1}}],[\"当某车辆在当前车道上无法达到驾驶员的期望速度\",{\"1\":{\"76\":1}}],[\"当车流量足够大\",{\"1\":{\"70\":1}}],[\"当汽车当前速度大于与前车的距离\",{\"1\":{\"70\":1}}],[\"当观测样本很多时\",{\"1\":{\"15\":1}}],[\"当特征空间很大时\",{\"1\":{\"15\":1}}],[\"当然通过改变参数的形状\",{\"1\":{\"6\":1}}],[\"多车道\",{\"1\":{\"76\":1}}],[\"多重共线性并不是问题\",{\"1\":{\"15\":1}}],[\"多项式核和\",{\"1\":{\"15\":1}}],[\"已有工具的高效实现\",{\"1\":{\"15\":1}}],[\"便利的观测样本概率分数\",{\"1\":{\"15\":1}}],[\"便于我们选择合适的模型\",{\"1\":{\"11\":1}}],[\"线性\",{\"1\":{\"15\":1}}],[\"线型模型优势与不足\",{\"1\":{\"12\":1}}],[\"线型模型\",{\"0\":{\"12\":1}}],[\"通常是最快的\",{\"1\":{\"16\":1}}],[\"通常不采用核函数的方法\",{\"1\":{\"15\":1}}],[\"通过改变s与p的大小\",{\"1\":{\"74\":1}}],[\"通过改变货车占比r\",{\"1\":{\"74\":1}}],[\"通过模拟不同紧急情况下的交通流动\",{\"1\":{\"27\":1}}],[\"通过模拟特定时间段的交通流\",{\"1\":{\"27\":1}}],[\"通过生成不同交通规划方案\",{\"1\":{\"27\":1}}],[\"通过海量多样化数据训练\",{\"1\":{\"26\":1}}],[\"通过密度自动确定簇的数量\",{\"1\":{\"16\":1}}],[\"通过使用核函数将输入空间映射到高维特征空间\",{\"1\":{\"15\":1}}],[\"通过调整这些变量\",{\"1\":{\"15\":1}}],[\"通过引入松弛变量来处理噪声和异常点\",{\"1\":{\"15\":1}}],[\"通过梯度下降来寻找更优的学习参数\",{\"1\":{\"14\":1}}],[\"通过验证集我们可以训练几个\",{\"1\":{\"10\":1}}],[\"本文探讨基于\",{\"1\":{\"79\":1}}],[\"本文不定期更新前沿科技简介\",{\"1\":{\"25\":1}}],[\"本节介绍ns模型基本内容\",{\"1\":{\"62\":1}}],[\"本节简单介绍一下元胞自动机模型\",{\"1\":{\"52\":1}}],[\"本节整理机器学习的基本问题\",{\"1\":{\"8\":1}}],[\"本节整理卷积方面基本概念\",{\"1\":{\"5\":1}}],[\"本质上是其\",{\"1\":{\"15\":1}}],[\"都会被放大形成\",{\"1\":{\"66\":1}}],[\"都会具有\",{\"1\":{\"11\":1}}],[\"都是判别模型\",{\"1\":{\"15\":1}}],[\"都是监督学习算法\",{\"1\":{\"15\":1}}],[\"都是线性分类算法\",{\"1\":{\"15\":1}}],[\"都是分类算法\",{\"1\":{\"15\":1}}],[\"回归\",{\"1\":{\"15\":1}}],[\"回归区别联系\",{\"1\":{\"15\":1}}],[\"回归器\",{\"1\":{\"10\":1}}],[\"核函数\",{\"1\":{\"22\":1}}],[\"核心点是在指定半径范围内有足够多邻居的点\",{\"1\":{\"16\":1}}],[\"核\",{\"1\":{\"15\":1}}],[\"常用为固定型和周期型\",{\"1\":{\"57\":1}}],[\"常用的邻居边界条件类型有\",{\"1\":{\"57\":1}}],[\"常用的核函数有线性核\",{\"1\":{\"15\":1}}],[\"常见的数据有\",{\"1\":{\"80\":1}}],[\"常见的模型方法有\",{\"1\":{\"80\":1}}],[\"常见的非监督学习算法包括聚类\",{\"1\":{\"10\":1}}],[\"常见的监督学习算法包括线性回归\",{\"1\":{\"10\":1}}],[\"需要提前指定簇数\",{\"1\":{\"16\":1}}],[\"需要事先指定簇数\",{\"1\":{\"16\":1}}],[\"需要进行转换\",{\"1\":{\"15\":1}}],[\"需要调整松弛变量和惩罚参数\",{\"1\":{\"15\":1}}],[\"需要使偏差小\",{\"1\":{\"11\":1}}],[\"允许在某些情况下出现分类错误\",{\"1\":{\"15\":1}}],[\"放松了对数据线性可分的假设\",{\"1\":{\"15\":1}}],[\"放大图像\",{\"1\":{\"6\":1}}],[\"因为异常点可能导致无法找到一个满足所有约束条件的超平面\",{\"1\":{\"15\":1}}],[\"因此称为幽灵拥堵\",{\"1\":{\"70\":1}}],[\"因此因变量是连续的\",{\"1\":{\"12\":1}}],[\"因此因变量是离散的\",{\"1\":{\"12\":1}}],[\"因此对一些对数据分布敏感的模型选择并不适用\",{\"1\":{\"11\":1}}],[\"此外\",{\"1\":{\"15\":1,\"87\":1}}],[\"原来原胞更新为空状态\",{\"1\":{\"87\":1}}],[\"原理\",{\"1\":{\"15\":3}}],[\"原因\",{\"1\":{\"11\":2,\"66\":1}}],[\"原因大致有以下几点\",{\"1\":{\"2\":1}}],[\"硬间隔\",{\"1\":{\"15\":4}}],[\"基尼杂质\",{\"1\":{\"23\":1}}],[\"基于现实场景数据\",{\"1\":{\"80\":1}}],[\"基于物理规则模型\",{\"1\":{\"80\":1}}],[\"基于概率密度函数的估计方法和基于样本间相似性度量的间接聚类方法\",{\"1\":{\"16\":1}}],[\"基于核函数的\",{\"1\":{\"15\":3}}],[\"基本设置\",{\"0\":{\"83\":1}}],[\"基本图\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"基本思想是将高维的模式样本投影到最佳鉴别矢量空间\",{\"1\":{\"12\":1}}],[\"基本概念\",{\"0\":{\"6\":1,\"9\":1,\"63\":1},\"1\":{\"52\":1}}],[\"软间隔\",{\"1\":{\"15\":4}}],[\"试述硬间隔\",{\"1\":{\"15\":1}}],[\"六\",{\"0\":{\"15\":1}}],[\"沿着梯度下降的方向求解极小值\",{\"1\":{\"14\":1}}],[\"θ\",{\"1\":{\"14\":1}}],[\"梯度下降方法通过求出损失函数在某点对于参数\",{\"1\":{\"14\":1}}],[\"梯度下降方法的原理\",{\"1\":{\"14\":1}}],[\"再励学习\",{\"1\":{\"14\":1}}],[\"按学习方式\",{\"1\":{\"14\":1}}],[\"按一定步长\",{\"1\":{\"6\":1}}],[\"联接方式\",{\"1\":{\"14\":1}}],[\"无需依赖整个数据\",{\"1\":{\"15\":1}}],[\"无法找到一个有效的超平面\",{\"1\":{\"15\":1}}],[\"无法解决线性不可分问题\",{\"1\":{\"14\":1}}],[\"无监督学习方法主要有两大类\",{\"1\":{\"16\":1}}],[\"无监督学习\",{\"1\":{\"14\":1}}],[\"无监督学习无反馈\",{\"1\":{\"10\":1}}],[\"无导师的学习\",{\"1\":{\"14\":1}}],[\"最后把再\",{\"1\":{\"87\":1}}],[\"最后取最大\",{\"1\":{\"87\":1}}],[\"最后得到所求\",{\"1\":{\"87\":1}}],[\"最后对\",{\"1\":{\"84\":1}}],[\"最大作为原胞潜力\",{\"1\":{\"87\":1}}],[\"最大加速度\",{\"1\":{\"72\":1}}],[\"最大速度\",{\"1\":{\"72\":1}}],[\"最大池化操作在该神经元上很大概率的输出仍是\",{\"1\":{\"6\":1}}],[\"最大池化将会取\",{\"1\":{\"6\":1}}],[\"最终选择\",{\"1\":{\"86\":1}}],[\"最终形成拥堵现象\",{\"1\":{\"70\":1}}],[\"最终的输出都是输入的线性组合\",{\"1\":{\"14\":1}}],[\"最初由德国物理学家kai\",{\"1\":{\"64\":1}}],[\"最初由stanislaw\",{\"1\":{\"53\":1}}],[\"最常用的邻居类型是\",{\"1\":{\"56\":1}}],[\"非线性激活函数的主要作用是什么\",{\"1\":{\"14\":1}}],[\"非监督学习只需要输入数据\",{\"1\":{\"10\":1}}],[\"非监督学习以及强化学习的定义和区别\",{\"1\":{\"10\":1}}],[\"非监督学习\",{\"1\":{\"10\":2}}],[\"五大部分\",{\"1\":{\"53\":1}}],[\"五\",{\"0\":{\"14\":1}}],[\"比如在步骤2减速时刹车踩的过大\",{\"1\":{\"70\":1}}],[\"比预剪枝保留了更多分支\",{\"1\":{\"13\":1}}],[\"比赛\",{\"1\":{\"3\":2}}],[\"禁止这些分支展开\",{\"1\":{\"13\":1}}],[\"贪心\",{\"1\":{\"13\":1}}],[\"缺点\",{\"1\":{\"13\":2,\"15\":3,\"16\":3}}],[\"显著降低训练时间和测试时间的开销\",{\"1\":{\"13\":1}}],[\"降低过拟合风险\",{\"1\":{\"13\":1}}],[\"降维最多降到类别数\",{\"1\":{\"17\":1}}],[\"降维\",{\"0\":{\"17\":1},\"1\":{\"10\":1}}],[\"四\",{\"0\":{\"13\":1}}],[\"投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离\",{\"1\":{\"12\":1}}],[\"分类\",{\"1\":{\"80\":1}}],[\"分类器\",{\"1\":{\"10\":1}}],[\"分别计算边界内每个原胞到出口的距离\",{\"1\":{\"87\":1}}],[\"分别用计算\",{\"1\":{\"86\":1}}],[\"分别为对应系数\",{\"1\":{\"84\":1}}],[\"分别做r=0\",{\"1\":{\"74\":1}}],[\"分别做fd图以及时空位置图\",{\"1\":{\"74\":1}}],[\"分别分析其对于交通系统的影响影响\",{\"1\":{\"74\":1}}],[\"分裂型\",{\"1\":{\"16\":1}}],[\"分析\",{\"1\":{\"12\":1}}],[\"优缺点\",{\"1\":{\"15\":1,\"16\":1}}],[\"优点\",{\"1\":{\"13\":2,\"15\":3,\"16\":3}}],[\"优势\",{\"1\":{\"12\":1}}],[\"优化器\",{\"1\":{\"10\":1}}],[\"三角形\",{\"1\":{\"55\":1}}],[\"三者最终计算方式以及限制条件\",{\"1\":{\"15\":1}}],[\"三\",{\"0\":{\"12\":1}}],[\"度量了同样大小的训练集的变动所导致的学习性能的变化\",{\"1\":{\"11\":1}}],[\"度量了学习算法的期望预测与真实结果的偏离程度\",{\"1\":{\"11\":1}}],[\"刻画了学习算法本身的拟合能力\",{\"1\":{\"11\":1}}],[\"==0\",{\"1\":{\"87\":2}}],[\"=1\",{\"1\":{\"87\":1}}],[\"=1e10\",{\"1\":{\"87\":1}}],[\"=1+1=2\",{\"1\":{\"45\":1}}],[\"=1+0=1\",{\"1\":{\"45\":1}}],[\"=border\",{\"1\":{\"87\":1}}],[\"=inf\",{\"1\":{\"87\":1}}],[\"=sqrt\",{\"1\":{\"87\":1}}],[\"=sumk=1k​l\",{\"1\":{\"43\":1}}],[\"=⎩⎨⎧​0\",{\"1\":{\"59\":1}}],[\"=2\",{\"1\":{\"45\":1}}],[\"=4+0=4\",{\"1\":{\"45\":1}}],[\"=li​\",{\"1\":{\"46\":1}}],[\"=l\",{\"1\":{\"45\":4,\"87\":1}}],[\"=xf​\",{\"1\":{\"45\":1}}],[\"=x+u\",{\"1\":{\"37\":1}}],[\"=u1\",{\"1\":{\"46\":1}}],[\"=u4​min​l\",{\"1\":{\"45\":1}}],[\"=u4min​l\",{\"1\":{\"45\":1}}],[\"=uk−1min​l\",{\"1\":{\"46\":1}}],[\"=ukmin​l\",{\"1\":{\"45\":1}}],[\"=uk\",{\"1\":{\"45\":1}}],[\"=uforallx∈x\",{\"1\":{\"37\":1}}],[\"=∞+0=∞\",{\"1\":{\"45\":1}}],[\"=∞\",{\"1\":{\"43\":1,\"45\":1,\"46\":2}}],[\"=0\",{\"1\":{\"43\":1,\"46\":1,\"86\":12,\"87\":1}}],[\"=f\",{\"1\":{\"36\":1,\"39\":1}}],[\"=\",{\"1\":{\"11\":1,\"37\":3,\"39\":2,\"40\":1,\"41\":6,\"48\":2,\"50\":1,\"56\":2,\"74\":2,\"86\":12,\"87\":18}}],[\"请先移步这篇文章\",{\"1\":{\"79\":1}}],[\"请给出常用的几种非线性激活函数及其导数\",{\"1\":{\"14\":1}}],[\"请给出你对泛化误差的理解\",{\"1\":{\"11\":1}}],[\"请简要说明主成分分析\",{\"1\":{\"17\":1}}],[\"请简要说明他们之间的关系\",{\"1\":{\"10\":1}}],[\"请简述这两种方式的优缺点\",{\"1\":{\"13\":1}}],[\"86\",{\"1\":{\"74\":1}}],[\"8045\",{\"1\":{\"74\":1}}],[\"8262\",{\"1\":{\"74\":1}}],[\"8\",{\"1\":{\"11\":1,\"32\":1,\"39\":1,\"48\":2,\"59\":2,\"86\":1,\"87\":2}}],[\"减速\",{\"1\":{\"70\":1}}],[\"减少\",{\"1\":{\"28\":2}}],[\"减少数据扰动产生的影响\",{\"1\":{\"11\":1}}],[\"减小模型复杂度\",{\"1\":{\"11\":1}}],[\"充分拟合数据\",{\"1\":{\"11\":1}}],[\"给定学习任务为了取得好的泛化性能\",{\"1\":{\"11\":1}}],[\"给定一个数据样本集\",{\"1\":{\"10\":1}}],[\"数据驱动模型\",{\"1\":{\"80\":2}}],[\"数据的充分性以及学习任务本身的难度所共同决定的\",{\"1\":{\"11\":1}}],[\"数以亿计参数的\",{\"1\":{\"26\":1}}],[\"数量级\",{\"1\":{\"9\":1}}],[\"vn​+1\",{\"1\":{\"76\":1}}],[\"vdr中p是v的函数\",{\"1\":{\"76\":1}}],[\"vdr\",{\"1\":{\"76\":1}}],[\"vf先不变后急剧减小\",{\"1\":{\"74\":1}}],[\"vc先急剧减小后基本不变\",{\"1\":{\"74\":1}}],[\"vmax​\",{\"1\":{\"70\":1,\"76\":1}}],[\"v=0时的密度\",{\"1\":{\"67\":1}}],[\"vt+1\",{\"1\":{\"59\":1}}],[\"von\",{\"1\":{\"53\":1,\"56\":2}}],[\"vocabulary\",{\"0\":{\"28\":1}}],[\"vs\",{\"1\":{\"47\":1}}],[\"v\",{\"1\":{\"42\":4,\"70\":4}}],[\"visual\",{\"1\":{\"80\":1}}],[\"visited\",{\"1\":{\"38\":1,\"39\":7,\"41\":11}}],[\"vision\",{\"1\":{\"26\":1}}],[\"view\",{\"0\":{\"42\":1}}],[\"virtual\",{\"1\":{\"27\":1}}],[\"videos\",{\"1\":{\"27\":2}}],[\"various\",{\"1\":{\"26\":1,\"31\":1,\"80\":1}}],[\"variations\",{\"1\":{\"50\":1}}],[\"variable\",{\"1\":{\"23\":1,\"47\":4}}],[\"variances\",{\"1\":{\"20\":1}}],[\"variance\",{\"1\":{\"11\":1,\"18\":1,\"20\":1,\"21\":1}}],[\"valued\",{\"1\":{\"31\":1,\"50\":1}}],[\"value\",{\"0\":{\"45\":1,\"46\":1},\"1\":{\"23\":1,\"43\":1,\"44\":3,\"45\":3,\"46\":1,\"47\":3,\"48\":5,\"50\":1}}],[\"values\",{\"1\":{\"23\":2,\"50\":1}}],[\"validated\",{\"1\":{\"19\":1}}],[\"validation\",{\"0\":{\"19\":1},\"1\":{\"19\":4}}],[\"vehicles\",{\"1\":{\"72\":1,\"80\":1}}],[\"vehicle\",{\"1\":{\"66\":2,\"69\":5,\"70\":5,\"72\":2,\"80\":2}}],[\"versions\",{\"1\":{\"44\":1}}],[\"vertex\",{\"1\":{\"31\":5,\"42\":1,\"45\":2}}],[\"very\",{\"1\":{\"10\":1}}],[\"velocity\",{\"1\":{\"31\":1,\"69\":2,\"70\":2,\"72\":1,\"76\":1,\"80\":2}}],[\"vectors\",{\"1\":{\"22\":2,\"37\":1}}],[\"vector\",{\"0\":{\"22\":1},\"1\":{\"6\":1,\"10\":1,\"22\":1}}],[\"噪声处理\",{\"1\":{\"16\":1}}],[\"噪声\",{\"1\":{\"11\":1}}],[\"噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界即刻画了学习问题本身的难度\",{\"1\":{\"11\":1}}],[\"噪声含义\",{\"1\":{\"11\":1}}],[\"方差分解角度解释泛化性能\",{\"1\":{\"11\":1}}],[\"方差度量了同样大小训练集的变动所导致的学习性能的变化\",{\"1\":{\"11\":1}}],[\"方差\",{\"1\":{\"11\":2}}],[\"偏差+方差+噪声\",{\"1\":{\"11\":1}}],[\"偏差方差冲突\",{\"1\":{\"11\":1}}],[\"偏差度量了学习算法期望预测与真实结果的偏离程度\",{\"1\":{\"11\":1}}],[\"偏差\",{\"1\":{\"11\":3}}],[\"偏离\",{\"1\":{\"9\":1}}],[\"中间设有障碍\",{\"1\":{\"81\":1}}],[\"中的一种离散计算模型\",{\"1\":{\"53\":1}}],[\"中数据的分布未必相一致\",{\"1\":{\"11\":1}}],[\"中划分训练集和测试\",{\"1\":{\"11\":1}}],[\"解决线性模型所不能解决的问题\",{\"1\":{\"14\":1}}],[\"解决了交叉验证法中模型选择阶段和最终模型训练阶段的训练集规模差异问题\",{\"1\":{\"11\":1}}],[\"解决办法\",{\"1\":{\"11\":2}}],[\"集\",{\"1\":{\"11\":1}}],[\"验证\",{\"1\":{\"11\":1}}],[\"验证集的重要性\",{\"1\":{\"10\":1}}],[\"验证集的作用\",{\"1\":{\"10\":1}}],[\"验证集\",{\"1\":{\"10\":1}}],[\"验证集区别联系\",{\"1\":{\"10\":1}}],[\"根据数据点的密度将它们分为核心点\",{\"1\":{\"16\":1}}],[\"根据一定规则从数据集\",{\"1\":{\"11\":1}}],[\"根据学习方式的划分\",{\"1\":{\"10\":1}}],[\"它由二维元胞网格组成\",{\"1\":{\"59\":1}}],[\"它们被用于扩展簇\",{\"1\":{\"16\":1}}],[\"它们作为人工智能中评估模型的方法\",{\"1\":{\"11\":1}}],[\"它的结果易于解释和可视化\",{\"1\":{\"16\":1}}],[\"它通过迭代地将数据点分配给最近的质心并更新质心来执行聚类\",{\"1\":{\"16\":1}}],[\"它可以是自底向上的聚合聚类\",{\"1\":{\"16\":1}}],[\"它可以结合\",{\"1\":{\"15\":1}}],[\"它可以用于调整模型的超参数和用于对模型的能力进行初步评估\",{\"1\":{\"10\":1}}],[\"相互作用\",{\"1\":{\"58\":1}}],[\"相关信息\",{\"1\":{\"31\":1,\"58\":1,\"81\":1}}],[\"相同之处\",{\"1\":{\"12\":1}}],[\"相同点\",{\"1\":{\"11\":1,\"15\":1,\"17\":1}}],[\"相较于全连接层直接把图像展开成一个行向量\",{\"1\":{\"6\":1}}],[\"k1​li\",{\"1\":{\"84\":1}}],[\"kd​\",{\"1\":{\"84\":1}}],[\"ks​\",{\"1\":{\"84\":1}}],[\"ks​si\",{\"1\":{\"84\":1}}],[\"kj逐渐减小\",{\"1\":{\"74\":1}}],[\"kc先增加后减小\",{\"1\":{\"74\":1}}],[\"kai\",{\"1\":{\"64\":1}}],[\"kind\",{\"1\":{\"50\":1}}],[\"kinds\",{\"1\":{\"39\":1}}],[\"known\",{\"1\":{\"47\":1}}],[\"know\",{\"1\":{\"47\":1}}],[\"k=0对应的速度\",{\"1\":{\"67\":1}}],[\"k=3\",{\"1\":{\"45\":1}}],[\"k=4\",{\"1\":{\"45\":2,\"46\":1}}],[\"k=m\",{\"1\":{\"11\":1}}],[\"k+1\",{\"1\":{\"43\":1}}],[\"key\",{\"1\":{\"47\":1,\"48\":1}}],[\"keeps\",{\"1\":{\"70\":1}}],[\"keep\",{\"1\":{\"38\":1}}],[\"kernel\",{\"1\":{\"6\":1,\"22\":1}}],[\"k\",{\"0\":{\"21\":1},\"1\":{\"16\":10,\"17\":1,\"19\":4,\"20\":1,\"21\":4,\"40\":2,\"43\":2,\"45\":1,\"46\":1,\"47\":2,\"87\":4}}],[\"留出法\",{\"1\":{\"11\":1}}],[\"评估方法\",{\"1\":{\"11\":1}}],[\"泛化性能更好\",{\"1\":{\"13\":1}}],[\"泛化性能是出学习算法的能力\",{\"1\":{\"11\":1}}],[\"泛化误差\",{\"1\":{\"11\":2}}],[\"泛化能力\",{\"1\":{\"9\":1}}],[\"经常的\",{\"1\":{\"28\":2}}],[\"经验\",{\"1\":{\"11\":1}}],[\"经过训练的网络也能给出合适的输出\",{\"1\":{\"10\":1}}],[\"错分样本的占比\",{\"1\":{\"11\":1}}],[\"错误率\",{\"1\":{\"11\":2}}],[\"错误率及误差概念\",{\"1\":{\"11\":1}}],[\"误差\",{\"1\":{\"11\":3}}],[\"扩大训练集\",{\"1\":{\"11\":1}}],[\"扩大感受野\",{\"1\":{\"6\":1}}],[\"神经网络与人脑相比计算特能力特点\",{\"1\":{\"14\":1}}],[\"神经网络根据是否存在网络回路\",{\"1\":{\"14\":1}}],[\"神经网络分类\",{\"1\":{\"14\":1}}],[\"神经网络\",{\"0\":{\"14\":1}}],[\"神经网络的训练轮数等\",{\"1\":{\"11\":1}}],[\"神经网络等\",{\"1\":{\"10\":1}}],[\"增长\",{\"1\":{\"28\":2}}],[\"增加了车辆换道规则\",{\"1\":{\"76\":1}}],[\"增加模型复杂度\",{\"1\":{\"11\":1}}],[\"增加新特征\",{\"1\":{\"11\":1}}],[\"增广训练集\",{\"1\":{\"11\":1}}],[\"让一些神经元以一定的概率不工作\",{\"1\":{\"11\":1}}],[\"让我顺利解决了很多问题\",{\"1\":{\"1\":1}}],[\"7444\",{\"1\":{\"74\":1}}],[\"7668\",{\"1\":{\"74\":1}}],[\"7\",{\"1\":{\"11\":1,\"12\":1,\"14\":1,\"46\":2,\"48\":3,\"69\":1,\"86\":1}}],[\"6758\",{\"1\":{\"74\":1}}],[\"6\",{\"0\":{\"23\":1},\"1\":{\"11\":1,\"42\":1,\"45\":3,\"46\":5,\"47\":5,\"48\":1,\"86\":2,\"87\":1}}],[\"约束模型特征\",{\"1\":{\"11\":1}}],[\"交叉验证法采用的是无放回的随机采样方式\",{\"1\":{\"11\":1}}],[\"交叉验证法和自助法都是随机采样法\",{\"1\":{\"11\":1}}],[\"交叉验证法和自助法异同\",{\"1\":{\"11\":1}}],[\"交叉验证法\",{\"1\":{\"11\":1}}],[\"交叉验证\",{\"1\":{\"11\":1}}],[\"交通管理\",{\"1\":{\"80\":1}}],[\"交通流中\",{\"1\":{\"66\":1}}],[\"交通规划模拟与分析\",{\"1\":{\"27\":1}}],[\"交通\",{\"1\":{\"4\":1},\"2\":{\"61\":1,\"77\":1,\"89\":1}}],[\"清洗数据\",{\"1\":{\"11\":1}}],[\"权值学习迭代次数过多\",{\"1\":{\"11\":1}}],[\"4356\",{\"1\":{\"74\":1}}],[\"43\",{\"1\":{\"74\":1}}],[\"46\",{\"1\":{\"74\":3}}],[\"4693\",{\"1\":{\"74\":1}}],[\"4292\",{\"1\":{\"74\":1}}],[\"4248\",{\"1\":{\"74\":1}}],[\"42\",{\"1\":{\"74\":3}}],[\"44\",{\"1\":{\"74\":1}}],[\"404\",{\"1\":{\"91\":1}}],[\"40\",{\"1\":{\"53\":1,\"74\":3}}],[\"4\",{\"0\":{\"21\":1,\"42\":1,\"49\":1,\"50\":1,\"67\":1,\"75\":1},\"1\":{\"11\":3,\"13\":1,\"15\":3,\"16\":1,\"17\":1,\"28\":1,\"32\":1,\"37\":1,\"39\":1,\"45\":4,\"46\":5,\"47\":7,\"48\":1,\"70\":1,\"86\":3,\"87\":1}}],[\"不含边界的距离矩阵\",{\"1\":{\"87\":1}}],[\"不含边界距离矩阵\",{\"1\":{\"86\":1}}],[\"不重要的\",{\"1\":{\"28\":1}}],[\"不适合不规则形状和不同密度的簇\",{\"1\":{\"16\":1}}],[\"不需要\",{\"1\":{\"16\":1}}],[\"不需要预先指定簇数\",{\"1\":{\"16\":1}}],[\"不能撤消已做的处理\",{\"1\":{\"16\":1}}],[\"不能很好地处理大量多类特征或变量\",{\"1\":{\"15\":1}}],[\"不具有很好的可伸缩性\",{\"1\":{\"16\":1}}],[\"不受其影响\",{\"1\":{\"15\":1}}],[\"不同方法并非只适用于一个规模\",{\"1\":{\"80\":1}}],[\"不同\",{\"1\":{\"15\":1}}],[\"不同之处\",{\"1\":{\"12\":1}}],[\"不同点\",{\"1\":{\"11\":1,\"15\":1,\"17\":1}}],[\"不足\",{\"1\":{\"12\":1}}],[\"不匹配\",{\"1\":{\"11\":1}}],[\"不想走出舒适圈\",{\"1\":{\"1\":1}}],[\"与不占有\",{\"1\":{\"83\":1}}],[\"与行人图像\",{\"1\":{\"80\":1}}],[\"与加入随机慢化概率s效果类似\",{\"1\":{\"76\":1}}],[\"与\",{\"1\":{\"15\":1,\"86\":2,\"87\":1}}],[\"与没有隐藏层的效果相当\",{\"1\":{\"14\":1}}],[\"与模型复杂度\",{\"1\":{\"11\":1}}],[\"与图像对应元素进行点乘相加的操作\",{\"1\":{\"6\":1}}],[\"n×n\",{\"1\":{\"87\":1}}],[\"n+1\",{\"1\":{\"87\":2}}],[\"n+2\",{\"1\":{\"86\":3,\"87\":1}}],[\"n+4\",{\"1\":{\"86\":2}}],[\"n=zeros\",{\"1\":{\"86\":1}}],[\"n=16\",{\"1\":{\"86\":1}}],[\"ni\",{\"1\":{\"84\":3}}],[\"ns\",{\"0\":{\"71\":1},\"1\":{\"64\":1}}],[\"ns模型中p是固定不变的\",{\"1\":{\"76\":1}}],[\"ns模型\",{\"0\":{\"64\":1}}],[\"nv​\",{\"1\":{\"56\":1}}],[\"nm​\",{\"1\":{\"56\":1}}],[\"nagel\",{\"0\":{\"64\":1},\"1\":{\"64\":4}}],[\"name\",{\"1\":{\"50\":2}}],[\"namely\",{\"1\":{\"44\":1}}],[\"natural\",{\"1\":{\"26\":1}}],[\"number\",{\"1\":{\"31\":2,\"40\":1,\"43\":2,\"47\":4,\"50\":1,\"70\":1}}],[\"neigh\",{\"1\":{\"86\":1,\"87\":4}}],[\"neighbors\",{\"1\":{\"60\":1}}],[\"neighbor\",{\"1\":{\"60\":1}}],[\"neumann\",{\"1\":{\"53\":1,\"56\":2}}],[\"negative\",{\"1\":{\"50\":8}}],[\"negated\",{\"1\":{\"50\":1}}],[\"net\",{\"1\":{\"46\":1}}],[\"need\",{\"1\":{\"45\":2,\"46\":2,\"47\":1,\"48\":1,\"50\":1}}],[\"next\",{\"1\":{\"39\":3,\"47\":1}}],[\"nearest\",{\"1\":{\"21\":1}}],[\"new\",{\"1\":{\"20\":1,\"31\":1,\"36\":1,\"42\":1,\"45\":1,\"46\":1,\"48\":1}}],[\"n^2\",{\"1\":{\"16\":1}}],[\"node\",{\"1\":{\"23\":3}}],[\"no\",{\"1\":{\"21\":1,\"31\":1,\"47\":4,\"48\":3}}],[\"nonempty\",{\"1\":{\"36\":1,\"50\":3}}],[\"non\",{\"1\":{\"21\":1,\"22\":1}}],[\"normalization\",{\"1\":{\"15\":1}}],[\"noise\",{\"1\":{\"11\":1}}],[\"note\",{\"1\":{\"50\":1}}],[\"notably\",{\"1\":{\"43\":1,\"48\":1}}],[\"notation\",{\"1\":{\"28\":1}}],[\"nothing\",{\"1\":{\"39\":1}}],[\"not\",{\"1\":{\"10\":1,\"39\":3,\"41\":5,\"42\":1,\"45\":1,\"47\":2,\"48\":3,\"49\":1,\"50\":3,\"70\":1,\"72\":1,\"91\":1}}],[\"n\",{\"1\":{\"11\":1,\"16\":1,\"86\":4,\"87\":16}}],[\"欠拟合风险小\",{\"1\":{\"13\":1}}],[\"欠拟合应对\",{\"1\":{\"11\":1}}],[\"欠拟合原因\",{\"1\":{\"11\":1}}],[\"欠拟合\",{\"1\":{\"11\":1}}],[\"欠拟合定义\",{\"1\":{\"11\":1}}],[\"导致泛化性能下降\",{\"1\":{\"11\":1}}],[\"导数趋于\",{\"1\":{\"6\":1}}],[\"样本集较大时\",{\"1\":{\"16\":1}}],[\"样本真实输出与预测输出之间的差异\",{\"1\":{\"11\":1}}],[\"样本噪声过多\",{\"1\":{\"11\":1}}],[\"样本\",{\"1\":{\"11\":1}}],[\"潜在\",{\"1\":{\"11\":1}}],[\"将训练样本本身的特点当做所有\",{\"1\":{\"11\":1}}],[\"将数据对象进行特征\",{\"1\":{\"10\":1}}],[\"太好\",{\"1\":{\"11\":1}}],[\"过拟合原因\",{\"1\":{\"11\":1}}],[\"过拟合\",{\"1\":{\"11\":3}}],[\"过程中还遇到很多莫名其妙的小\",{\"1\":{\"1\":1}}],[\"二者都使用了极大似然估计对训练样本进行建模\",{\"1\":{\"12\":1}}],[\"二者在求解超参数的过程中都使用梯度下降的方法\",{\"1\":{\"12\":1}}],[\"二\",{\"0\":{\"11\":1}}],[\"为指标\",{\"1\":{\"84\":1}}],[\"为位置为\",{\"1\":{\"84\":2}}],[\"为元胞动态势能\",{\"1\":{\"84\":1}}],[\"为元胞静态势能\",{\"1\":{\"84\":1}}],[\"为交通规划提供数据支持\",{\"1\":{\"27\":1}}],[\"为什么要引入对偶问题\",{\"1\":{\"15\":1}}],[\"为什么通常要进行标准化处理\",{\"1\":{\"10\":1}}],[\"为了让我们的模型在测试集表现得更好\",{\"1\":{\"10\":1}}],[\"该模型将模拟的道路环境扩展为双车道\",{\"1\":{\"76\":1}}],[\"该游戏采用标准\",{\"1\":{\"59\":1}}],[\"该能力称为泛化能力\",{\"1\":{\"10\":1}}],[\"该规律不仅适用于训练数据\",{\"1\":{\"10\":1}}],[\"什么是回归\",{\"1\":{\"12\":1}}],[\"什么是泛化性能\",{\"1\":{\"10\":1}}],[\"什么是机器学习和深度学习\",{\"1\":{\"10\":1}}],[\"确认网络的实际预测能力\",{\"1\":{\"10\":1}}],[\"仅仅用来评估模最终模型的泛化能力\",{\"1\":{\"10\":1}}],[\"然后在\",{\"1\":{\"87\":1}}],[\"然后决定怎么调整我们的超参数\",{\"1\":{\"10\":1}}],[\"然后再来调整参数\",{\"1\":{\"10\":1}}],[\"监控模型是否正常\",{\"1\":{\"10\":1}}],[\"监督学习和非监督学习常常结合使用\",{\"1\":{\"10\":1}}],[\"监督学习和非监督学习是机器学习中两种不同的学习方式\",{\"1\":{\"10\":1}}],[\"监督学习需要已知的输入和输出数据\",{\"1\":{\"10\":1}}],[\"监督学习不具备\",{\"1\":{\"10\":1}}],[\"监督学习关注与标签或已知输出的误差\",{\"1\":{\"10\":1}}],[\"监督学习有反馈\",{\"1\":{\"10\":1}}],[\"监督学习通常用于分类\",{\"1\":{\"10\":1}}],[\"监督学习\",{\"1\":{\"10\":2,\"14\":1}}],[\"选择新位置已占\",{\"1\":{\"87\":1}}],[\"选择下一位置\",{\"1\":{\"87\":1}}],[\"选择样本点投影具有最大方差的方向\",{\"1\":{\"17\":1}}],[\"选择分类性能最好的投影方向\",{\"1\":{\"17\":1}}],[\"选择合适的核函数和参数是一个挑战\",{\"1\":{\"15\":1}}],[\"选择超参数\",{\"1\":{\"10\":1}}],[\"选择特征等算法相关的选择的依据\",{\"1\":{\"10\":1}}],[\"等阻力\",{\"1\":{\"80\":1}}],[\"等类型\",{\"1\":{\"55\":1}}],[\"等\",{\"1\":{\"10\":1,\"80\":3}}],[\"等函数\",{\"1\":{\"6\":1}}],[\"网络节点数\",{\"1\":{\"10\":1}}],[\"网络层数\",{\"1\":{\"10\":1}}],[\"快速调参\",{\"1\":{\"10\":1}}],[\"调整网络权重\",{\"1\":{\"10\":1}}],[\"调参去拟合测试集合\",{\"1\":{\"10\":1}}],[\"调参是不可避免地一部分\",{\"1\":{\"10\":1}}],[\"调参\",{\"1\":{\"9\":1}}],[\"各数据集的作用\",{\"1\":{\"10\":1}}],[\"用1代表有车占有\",{\"1\":{\"65\":1}}],[\"用0代表空\",{\"1\":{\"65\":1}}],[\"用函数表示如下\",{\"1\":{\"59\":1}}],[\"用来评估模最终模型的泛化能力\",{\"1\":{\"10\":1}}],[\"用于模型拟合的数据样本\",{\"1\":{\"10\":1}}],[\"即进行位置更新\",{\"1\":{\"87\":1}}],[\"即原胞\",{\"1\":{\"87\":1}}],[\"即可得到选择\",{\"1\":{\"84\":1}}],[\"即该处元胞潜能为\",{\"1\":{\"84\":1}}],[\"即wave\",{\"1\":{\"66\":1}}],[\"即对于一条道路上连续的三个cell\",{\"1\":{\"65\":1}}],[\"即\",{\"1\":{\"65\":1,\"80\":1}}],[\"即按一定方式对空间划分\",{\"1\":{\"55\":1}}],[\"即过拟合\",{\"1\":{\"15\":1}}],[\"即存在一个超平面可以将不同类别的样本完全分开\",{\"1\":{\"15\":1}}],[\"即模式在该空间中有最佳的可分离性\",{\"1\":{\"12\":1}}],[\"即刻画了学习问题本身的难度\",{\"1\":{\"11\":1}}],[\"即刻画了学习法本身的拟合能力\",{\"1\":{\"11\":1}}],[\"即刻画了数据扰动所造成的影响\",{\"1\":{\"11\":2}}],[\"即用于训练的样本集合\",{\"1\":{\"10\":1}}],[\"即将变为sjtuer\",{\"1\":{\"3\":1}}],[\"独立成分分析\",{\"1\":{\"10\":1}}],[\"朴素贝叶斯\",{\"1\":{\"10\":1}}],[\"决策树各自优缺点\",{\"1\":{\"15\":1}}],[\"决策树中剪枝方式分为哪两种\",{\"1\":{\"13\":1}}],[\"决策树三种导致递归返回的情况\",{\"1\":{\"13\":1}}],[\"决策树\",{\"0\":{\"13\":1},\"1\":{\"10\":1,\"15\":1,\"23\":1}}],[\"决定写\",{\"1\":{\"2\":1}}],[\"逻辑回归的性能不是很好\",{\"1\":{\"15\":1}}],[\"逻辑回归的缺点\",{\"1\":{\"15\":1}}],[\"逻辑回归的优点\",{\"1\":{\"15\":1}}],[\"逻辑回归广泛的应用于工业问题上\",{\"1\":{\"15\":1}}],[\"逻辑回归解决的是分类问题\",{\"1\":{\"12\":1}}],[\"逻辑回归和线性回归的异同\",{\"1\":{\"12\":1}}],[\"逻辑回归\",{\"1\":{\"10\":1,\"15\":1}}],[\"举例\",{\"1\":{\"10\":1}}],[\"变分自编码器等\",{\"1\":{\"10\":1}}],[\"变量\",{\"1\":{\"10\":1}}],[\"变换太缓慢\",{\"1\":{\"6\":1}}],[\"并进行归一化处理\",{\"1\":{\"87\":1}}],[\"并行性\",{\"1\":{\"58\":1}}],[\"并以负梯度方向为搜索方向\",{\"1\":{\"14\":1}}],[\"并严格划分训练集与测试集的界限\",{\"1\":{\"11\":1}}],[\"并分别给出监督和非监督学习的两种算法\",{\"1\":{\"10\":1}}],[\"并且减少了参数的相互依存关系\",{\"1\":{\"6\":1}}],[\"区别\",{\"1\":{\"10\":2,\"16\":2}}],[\"使之能够更真实准确地模拟出道路上交通流的运行状况\",{\"1\":{\"76\":1}}],[\"使得在高维特征空间中数据变得线性可分\",{\"1\":{\"15\":1}}],[\"使得所有的特征具有同样的尺度\",{\"1\":{\"10\":1}}],[\"使用最小二乘法求解线性回归时我们认为因变量服从正态分布\",{\"1\":{\"12\":1}}],[\"使系统行为从环境中获得的累积奖励值最大的一种机器学习方法\",{\"1\":{\"10\":1}}],[\"使不断改善自身的性能\",{\"1\":{\"10\":1}}],[\"是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞\",{\"1\":{\"57\":1}}],[\"是否为邻居\",{\"1\":{\"56\":1}}],[\"是模型迭代的直接参与者\",{\"1\":{\"54\":1}}],[\"是自动机理论\",{\"1\":{\"53\":1}}],[\"是无监督的降维方法\",{\"1\":{\"17\":1}}],[\"是有监督的降维方法\",{\"1\":{\"17\":1}}],[\"是指机器学习算法对新鲜样本的适应能力\",{\"1\":{\"10\":1}}],[\"是指从环境状态到行为映射的学习\",{\"1\":{\"10\":1}}],[\"是不可行地\",{\"1\":{\"10\":1}}],[\"是一种基于ca模型的用于交通仿真的理论模型\",{\"1\":{\"64\":1}}],[\"是一种在没有标签或目标的情况下\",{\"1\":{\"10\":1}}],[\"是一种通过使用已知输出来训练模型的学习方式\",{\"1\":{\"10\":1}}],[\"又称为再励学习\",{\"1\":{\"10\":1}}],[\"异常检测等操作\",{\"1\":{\"10\":1}}],[\"问题描述\",{\"0\":{\"81\":1}}],[\"问题\",{\"1\":{\"10\":1}}],[\"和信号灯状态\",{\"1\":{\"80\":1}}],[\"和线性判别分析\",{\"1\":{\"17\":1}}],[\"和层次聚类通常需要额外的后处理步骤来处理噪声点\",{\"1\":{\"16\":1}}],[\"和\",{\"1\":{\"14\":1,\"15\":3,\"84\":1}}],[\"和后剪枝\",{\"1\":{\"13\":1}}],[\"和原始数据集\",{\"1\":{\"11\":1}}],[\"和输出之间的映射关系\",{\"1\":{\"10\":1}}],[\"和回归\",{\"1\":{\"10\":1}}],[\"和抽象\",{\"1\":{\"6\":1}}],[\"以多大的速度\",{\"1\":{\"80\":1}}],[\"以及信号状态\",{\"1\":{\"80\":1}}],[\"以及一些环境阻碍的力repulsive\",{\"1\":{\"80\":1}}],[\"以及基本图\",{\"1\":{\"74\":1}}],[\"以个体为研究对象\",{\"1\":{\"80\":1}}],[\"以整个人群为研究对象\",{\"1\":{\"80\":1}}],[\"以下内容源于\",{\"1\":{\"76\":1}}],[\"以一个单位加速\",{\"1\":{\"70\":1}}],[\"以帮助开发更为智能的决策制定算法\",{\"1\":{\"27\":1}}],[\"以找到最佳的分类效果\",{\"1\":{\"15\":1}}],[\"以达到抽取分类信息和压缩特征空间维数的效果\",{\"1\":{\"12\":1}}],[\"以提高机器学习的效果和性能\",{\"1\":{\"10\":1}}],[\"以便对数据进行聚类\",{\"1\":{\"10\":1}}],[\"以预测新的输入数据的输出\",{\"1\":{\"10\":1}}],[\"以获取新的知识或技能\",{\"1\":{\"10\":1}}],[\"算法将数据划分为\",{\"1\":{\"16\":1}}],[\"算法的基本思想及算法流程\",{\"1\":{\"12\":1}}],[\"算法只能使用输入数据进行学习\",{\"1\":{\"10\":1}}],[\"算法通过学习这些数据\",{\"1\":{\"10\":1}}],[\"算激活函数时\",{\"1\":{\"6\":1}}],[\"定义为\",{\"1\":{\"84\":1}}],[\"定义\",{\"0\":{\"53\":1},\"1\":{\"10\":1,\"11\":1,\"66\":1}}],[\"简称ns\",{\"1\":{\"64\":1}}],[\"简单且高效\",{\"1\":{\"16\":1}}],[\"简单明了\",{\"1\":{\"15\":1}}],[\"简要介绍卷积概念及其作用\",{\"1\":{\"14\":1}}],[\"简要说明监督学习和非监督学习之间的区别\",{\"1\":{\"10\":1}}],[\"简述神经网络中梯度下降方法的原理和作用\",{\"1\":{\"14\":1}}],[\"简述神经网络的学习过程\",{\"1\":{\"14\":1}}],[\"简述\",{\"1\":{\"12\":1}}],[\"简述监督学习\",{\"1\":{\"10\":1}}],[\"简介\",{\"0\":{\"0\":1}}],[\"关系见下\",{\"1\":{\"10\":1}}],[\"强化学习是一个学习+决策的过程\",{\"1\":{\"10\":1}}],[\"强化学习的奖惩概念没有正确和错误之分\",{\"1\":{\"10\":1}}],[\"强化学习的目标与监督学习目标不同\",{\"1\":{\"10\":1}}],[\"强化学习看重行为序列下的长期收益\",{\"1\":{\"10\":1}}],[\"强化学习执行多步后反馈\",{\"1\":{\"10\":1}}],[\"强化学习\",{\"1\":{\"10\":2,\"14\":1}}],[\"g=on\",{\"1\":{\"50\":1}}],[\"game\",{\"1\":{\"48\":1}}],[\"gain\",{\"1\":{\"23\":1}}],[\"global\",{\"1\":{\"48\":1,\"60\":1,\"80\":1}}],[\"globally\",{\"1\":{\"48\":1}}],[\"g₋₄\",{\"1\":{\"47\":1}}],[\"g₋₃\",{\"1\":{\"47\":1}}],[\"g₋₂\",{\"1\":{\"47\":1}}],[\"g₋₁\",{\"1\":{\"47\":1}}],[\"g₀\",{\"1\":{\"47\":1}}],[\"g∗\",{\"1\":{\"47\":2}}],[\"g1​\",{\"1\":{\"47\":1}}],[\"g1∗​\",{\"1\":{\"45\":2}}],[\"g2​\",{\"1\":{\"47\":1}}],[\"g2∗​\",{\"1\":{\"45\":2}}],[\"g₁\",{\"1\":{\"45\":1}}],[\"g₂\",{\"1\":{\"45\":1}}],[\"g₃\",{\"1\":{\"45\":1}}],[\"g₄\",{\"1\":{\"45\":1}}],[\"g₅\",{\"1\":{\"45\":1}}],[\"g5∗​\",{\"1\":{\"45\":2}}],[\"g3∗​\",{\"1\":{\"45\":5}}],[\"g4∗​\",{\"1\":{\"45\":5}}],[\"gf∗​\",{\"1\":{\"45\":1}}],[\"gk+1∗​\",{\"1\":{\"45\":1}}],[\"gk∗​\",{\"1\":{\"45\":4}}],[\"go=0\",{\"1\":{\"86\":1}}],[\"goes\",{\"1\":{\"45\":1}}],[\"going\",{\"1\":{\"40\":1,\"47\":1}}],[\"go\",{\"1\":{\"40\":1,\"44\":1,\"45\":1,\"47\":5,\"48\":1,\"66\":4}}],[\"goal\",{\"1\":{\"21\":1,\"31\":2,\"36\":1,\"37\":1,\"40\":1,\"41\":2,\"47\":5,\"48\":5,\"50\":6}}],[\"guarantees\",{\"1\":{\"40\":1}}],[\"guide\",{\"1\":{\"27\":1}}],[\"g\",{\"1\":{\"39\":1,\"40\":2,\"41\":9,\"42\":2,\"47\":1,\"49\":1}}],[\"german\",{\"1\":{\"64\":1}}],[\"getting\",{\"1\":{\"66\":1}}],[\"get\",{\"1\":{\"46\":1}}],[\"getfirst\",{\"1\":{\"39\":1,\"41\":3,\"48\":1}}],[\"generalized\",{\"1\":{\"47\":1}}],[\"generalization\",{\"1\":{\"9\":1,\"10\":1,\"11\":1,\"18\":1,\"47\":1}}],[\"general\",{\"0\":{\"39\":1,\"41\":1},\"1\":{\"31\":1,\"39\":2,\"48\":1,\"50\":1}}],[\"generate\",{\"1\":{\"42\":1}}],[\"generates\",{\"1\":{\"31\":1}}],[\"generating\",{\"1\":{\"27\":1}}],[\"given\",{\"1\":{\"47\":1}}],[\"gives\",{\"1\":{\"39\":1}}],[\"gird\",{\"1\":{\"37\":1}}],[\"gini\",{\"1\":{\"23\":1}}],[\"gpt\",{\"1\":{\"27\":1}}],[\"greedy\",{\"1\":{\"48\":1}}],[\"greatest\",{\"1\":{\"20\":1}}],[\"grown\",{\"1\":{\"41\":2}}],[\"graph\",{\"1\":{\"37\":1,\"38\":2,\"40\":1,\"42\":2}}],[\"gradient\",{\"1\":{\"10\":2}}],[\"grid\",{\"1\":{\"37\":2}}],[\"表皮的\",{\"1\":{\"28\":1}}],[\"表面的\",{\"1\":{\"28\":1}}],[\"表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界\",{\"1\":{\"11\":1}}],[\"表征了参数每次更新的幅度\",{\"1\":{\"10\":1}}],[\"表示边界条件\",{\"1\":{\"86\":1}}],[\"表示\",{\"1\":{\"10\":1}}],[\"也可以是3d坐标\",{\"1\":{\"80\":1}}],[\"也可以同理做出上述图表\",{\"1\":{\"74\":1}}],[\"也就是通过验证集我们可以选择超参数\",{\"1\":{\"10\":1}}],[\"也称为标签或目标\",{\"1\":{\"10\":1}}],[\"也叫步长\",{\"1\":{\"10\":1}}],[\"也适用于未知数据\",{\"1\":{\"10\":1}}],[\"学习器把训练样本学习的\",{\"1\":{\"11\":1}}],[\"学习的目的是学到隐含在数据背后的规律\",{\"1\":{\"10\":1}}],[\"学习率\",{\"1\":{\"10\":2}}],[\"学习率太大和太小的可能影响\",{\"1\":{\"10\":1}}],[\"学习率这种参数叫什么\",{\"1\":{\"10\":1}}],[\"学过的知识都记不清了\",{\"1\":{\"2\":1}}],[\"利用学到的模型进行预测\",{\"1\":{\"10\":1}}],[\"测试误差\",{\"1\":{\"11\":1}}],[\"测试集上\",{\"1\":{\"11\":1}}],[\"测试集的作用\",{\"1\":{\"10\":1}}],[\"测试集\",{\"1\":{\"10\":2}}],[\"测试\",{\"1\":{\"10\":1}}],[\"称为泛化能力\",{\"1\":{\"10\":1}}],[\"目标是从数据中发现模式和结构\",{\"1\":{\"10\":1}}],[\"目标是学习输入\",{\"1\":{\"10\":1}}],[\"目标是找到输入数据之间的相似性和区别\",{\"1\":{\"10\":1}}],[\"目标\",{\"1\":{\"10\":1}}],[\"目前的系统往往在特定场景下表现良好\",{\"1\":{\"27\":1}}],[\"目前博客内容主要为过去做过的一些项目\",{\"1\":{\"4\":1}}],[\"目前小小的愿望清单\",{\"1\":{\"3\":1}}],[\"目前先尝试一个\",{\"1\":{\"2\":1}}],[\"目前还是处于入门小白阶段\",{\"1\":{\"1\":1}}],[\"从driver角度\",{\"1\":{\"66\":1}}],[\"从概念上就可以理解元胞就好似生物体的细胞\",{\"1\":{\"54\":1}}],[\"从数据中发现模式或结构的学习方式\",{\"1\":{\"10\":1}}],[\"从中学习出规律\",{\"1\":{\"10\":1}}],[\"从而实现每一次迭代的整体更新\",{\"1\":{\"87\":1}}],[\"从而引起全局的变化\",{\"1\":{\"58\":1}}],[\"从而推广到非线性分类问题\",{\"1\":{\"15\":1}}],[\"从而增强测试评估的稳定性和可靠性\",{\"1\":{\"11\":1}}],[\"从而评价模型在数据集上的表现\",{\"1\":{\"11\":1}}],[\"从而无法完成深层网络的训练\",{\"1\":{\"6\":1}}],[\"从而使模型可以抽取更加广范围的特征\",{\"1\":{\"6\":1}}],[\"训练时间开销大\",{\"1\":{\"13\":1}}],[\"训练样本过少\",{\"1\":{\"11\":1}}],[\"训练样本的一般性质尚未学好\",{\"1\":{\"11\":1}}],[\"训练集上的效果高度优于测试集\",{\"1\":{\"15\":1}}],[\"训练集上\",{\"1\":{\"11\":1}}],[\"训练集与测试集的特征分布不一致\",{\"1\":{\"11\":1}}],[\"训练集的数量级\",{\"1\":{\"11\":1}}],[\"训练集的作用\",{\"1\":{\"10\":1}}],[\"训练集\",{\"1\":{\"10\":2}}],[\"训练数据包括输入数据和对应的输出数据\",{\"1\":{\"10\":1}}],[\"训练\",{\"1\":{\"10\":1,\"11\":1}}],[\"希望机器通过学习的手段\",{\"1\":{\"10\":1}}],[\"人群中每个个体有着相同的行为特征\",{\"1\":{\"80\":1}}],[\"人\",{\"1\":{\"28\":1}}],[\"人工智能是想要达成的目标\",{\"1\":{\"10\":1}}],[\"人格\",{\"1\":{\"3\":1}}],[\"绪论\",{\"0\":{\"10\":1}}],[\"量纲\",{\"1\":{\"9\":1}}],[\"拟合了不具代表性的特征\",{\"1\":{\"11\":1}}],[\"拟合模型\",{\"1\":{\"10\":1}}],[\"拟合\",{\"1\":{\"9\":1}}],[\"振荡\",{\"1\":{\"9\":1}}],[\"收敛\",{\"1\":{\"9\":1}}],[\"幅度\",{\"1\":{\"9\":1}}],[\"缓解了过拟合问题的发生\",{\"1\":{\"6\":1}}],[\"这段代码思想为用一个\",{\"1\":{\"87\":1}}],[\"这里用\",{\"1\":{\"87\":1}}],[\"这里因为有四个入口\",{\"1\":{\"87\":1}}],[\"这里设置了\",{\"1\":{\"86\":1}}],[\"这里以位置为\",{\"1\":{\"84\":1}}],[\"这里主要考虑为出口与障碍物\",{\"1\":{\"84\":1}}],[\"这里引入元胞潜能\",{\"1\":{\"84\":1}}],[\"这里不一一展示\",{\"1\":{\"74\":1}}],[\"这类模型主要是基于物理规则\",{\"1\":{\"80\":1}}],[\"这三种\",{\"1\":{\"80\":1}}],[\"这也是反映了拥堵总是在没有任何外部原因\",{\"1\":{\"70\":1}}],[\"这反应了司机希望开得越快越好\",{\"1\":{\"70\":1}}],[\"这些力的合力即为行人朝着什么方向\",{\"1\":{\"80\":1}}],[\"这些提示用于指导视频内容的生成\",{\"1\":{\"27\":1}}],[\"这些特征的量纲和数量级都是不一样的\",{\"1\":{\"10\":1}}],[\"这一点很重要\",{\"1\":{\"15\":1}}],[\"这个超平面需要满足离其最近的点到其的距离最大化\",{\"1\":{\"15\":1}}],[\"这是两者最本质的区别\",{\"1\":{\"12\":1}}],[\"这种情况就是最原始的感知机\",{\"1\":{\"14\":1}}],[\"这种情况会造成信息丢失\",{\"1\":{\"6\":1}}],[\"这种方式可以保持数据分布的一致性条件\",{\"1\":{\"11\":1}}],[\"这两种方法最大的不同点在于每次划分过程中每个样本点是否只有一次被划入训练集或测试集的机会\",{\"1\":{\"11\":1}}],[\"这时需要对数据进行标准化处理\",{\"1\":{\"10\":1}}],[\"这样的stop\",{\"1\":{\"66\":1}}],[\"这样子时间代价较高\",{\"1\":{\"10\":1}}],[\"这样就造成了网络的稀疏性\",{\"1\":{\"6\":1}}],[\"这相当于作弊\",{\"1\":{\"10\":1}}],[\"会使一部分神经元的输出为\",{\"1\":{\"6\":1}}],[\"接近饱和区时\",{\"1\":{\"6\":1}}],[\"函数反向传播时\",{\"1\":{\"6\":1}}],[\"第五章\",{\"1\":{\"14\":3}}],[\"第四章\",{\"1\":{\"13\":1}}],[\"第三维为速度\",{\"1\":{\"80\":1}}],[\"第三章\",{\"1\":{\"12\":3}}],[\"第三\",{\"1\":{\"6\":1}}],[\"第二个时步为演化更新时步\",{\"1\":{\"76\":1}}],[\"第二\",{\"1\":{\"6\":1}}],[\"第一个时步为车辆换道时步\",{\"1\":{\"76\":1}}],[\"第一\",{\"1\":{\"6\":1}}],[\"整个过程的计算量节省很多\",{\"1\":{\"6\":1}}],[\"而另一条车道上的驾驶条件可以满足驾驶员对速度的要求时\",{\"1\":{\"76\":1}}],[\"而层次聚类较慢\",{\"1\":{\"16\":1}}],[\"而层次聚类和\",{\"1\":{\"16\":1}}],[\"而\",{\"1\":{\"15\":1,\"17\":3}}],[\"而逻辑回归考虑全局\",{\"1\":{\"15\":1}}],[\"而线性回归解决的是回归问题\",{\"1\":{\"12\":1}}],[\"而且方差较小\",{\"1\":{\"11\":1}}],[\"而且复习过程中也苦于没有地方整理\",{\"1\":{\"2\":1}}],[\"而不需要预先定义的目标\",{\"1\":{\"10\":1}}],[\"而监督学习的标签是正确的\",{\"1\":{\"10\":1}}],[\"而深度学习\",{\"1\":{\"10\":1}}],[\"而机器学习是想要达成目标的手段\",{\"1\":{\"10\":1}}],[\"而采用\",{\"1\":{\"6\":1}}],[\"反应人流变化的方向与源头\",{\"1\":{\"87\":1}}],[\"反应平台实时状态\",{\"1\":{\"86\":1}}],[\"反应了元胞有人占据\",{\"1\":{\"84\":1}}],[\"反应交通系统越来越拥堵\",{\"1\":{\"74\":1}}],[\"反应静止车辆启动较慢\",{\"1\":{\"72\":1}}],[\"反映在车长\",{\"1\":{\"72\":1}}],[\"反映驾驶员的不完美驾驶行为\",{\"1\":{\"70\":1}}],[\"反复出现\",{\"1\":{\"28\":2}}],[\"反向传播求误差梯度时\",{\"1\":{\"6\":1}}],[\"反卷积\",{\"1\":{\"6\":1}}],[\"指更新参数步幅\",{\"1\":{\"10\":1}}],[\"指数运算\",{\"1\":{\"6\":1}}],[\"指南\",{\"0\":{\"4\":1}}],[\"采用固定型\",{\"1\":{\"83\":1}}],[\"采用基本\",{\"1\":{\"83\":1}}],[\"采用深度学习等方法预测行人的轨迹\",{\"1\":{\"80\":1}}],[\"采用\",{\"1\":{\"6\":1}}],[\"采用原因\",{\"1\":{\"6\":1}}],[\"正六边形\",{\"1\":{\"55\":1}}],[\"正方形\",{\"1\":{\"55\":1}}],[\"正则化来解决\",{\"1\":{\"15\":1}}],[\"正则化\",{\"1\":{\"11\":1,\"18\":2}}],[\"正\",{\"1\":{\"6\":1}}],[\"负为\",{\"1\":{\"6\":1}}],[\"激活函数是神经网络的一个重要组成部分\",{\"1\":{\"14\":1}}],[\"激活函数\",{\"1\":{\"6\":2,\"14\":1}}],[\"的平台上\",{\"1\":{\"87\":1}}],[\"的计算\",{\"1\":{\"87\":2}}],[\"的元胞周围空元胞数目\",{\"1\":{\"84\":1}}],[\"的元胞周边的非障碍数目\",{\"1\":{\"84\":1}}],[\"的元胞距出口的距离\",{\"1\":{\"84\":1}}],[\"的形式\",{\"1\":{\"80\":1}}],[\"的格子\",{\"1\":{\"59\":2}}],[\"的维数\",{\"1\":{\"17\":1}}],[\"的维度\",{\"1\":{\"15\":1}}],[\"的缺点\",{\"1\":{\"15\":1}}],[\"的优点\",{\"1\":{\"15\":1}}],[\"的损失函数就自带正则\",{\"1\":{\"15\":1}}],[\"的原理\",{\"1\":{\"15\":1}}],[\"的微分值\",{\"1\":{\"14\":1}}],[\"的一般性质\",{\"1\":{\"11\":1}}],[\"的卷积\",{\"1\":{\"6\":1}}],[\"的想法\",{\"1\":{\"1\":1}}],[\"2×n\",{\"1\":{\"87\":1}}],[\"2417\",{\"1\":{\"74\":1}}],[\"2326\",{\"1\":{\"74\":1}}],[\"20\",{\"1\":{\"53\":1,\"86\":2}}],[\"2006\",{\"1\":{\"29\":1}}],[\"2d\",{\"1\":{\"37\":1,\"80\":1}}],[\"2\",{\"0\":{\"19\":1,\"31\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":2,\"38\":2,\"39\":2,\"40\":3,\"41\":2,\"42\":2,\"43\":1,\"44\":1,\"45\":1,\"46\":2,\"47\":2,\"48\":1,\"49\":1,\"50\":1,\"65\":1,\"68\":1,\"69\":1,\"70\":2,\"73\":1},\"1\":{\"6\":1,\"10\":3,\"11\":6,\"12\":5,\"15\":6,\"16\":1,\"17\":2,\"27\":1,\"28\":1,\"32\":2,\"36\":1,\"37\":2,\"40\":2,\"42\":1,\"43\":3,\"45\":3,\"46\":4,\"47\":8,\"48\":3,\"50\":1,\"58\":1,\"59\":1,\"70\":2,\"74\":5,\"86\":10,\"87\":24}}],[\"如车辆坐标\",{\"1\":{\"80\":1}}],[\"如动作\",{\"1\":{\"80\":1}}],[\"如道路结构\",{\"1\":{\"80\":1}}],[\"如来自人行道边界\",{\"1\":{\"80\":1}}],[\"如使人达到向着目的地前进\",{\"1\":{\"80\":1}}],[\"如流体动力学模型\",{\"1\":{\"80\":1}}],[\"如研究拥堵\",{\"1\":{\"80\":1}}],[\"如stca模型\",{\"1\":{\"76\":1}}],[\"如当s\",{\"1\":{\"74\":1}}],[\"如事故\",{\"1\":{\"70\":1}}],[\"如下图time\",{\"1\":{\"66\":1}}],[\"如下图所示\",{\"1\":{\"65\":1}}],[\"如司机过度刹车或者与其他车里的太近\",{\"1\":{\"66\":1}}],[\"如图一所示\",{\"1\":{\"56\":1}}],[\"如\",{\"1\":{\"54\":1}}],[\"如预训练\",{\"1\":{\"26\":1}}],[\"如决策树的扩展分支\",{\"1\":{\"11\":1}}],[\"如池化与步长为\",{\"1\":{\"6\":1}}],[\"如果选择的位置被占\",{\"1\":{\"87\":1}}],[\"如果上下和前面三个位置共\",{\"1\":{\"87\":1}}],[\"如果位置\",{\"1\":{\"87\":1}}],[\"如果你还不了解\",{\"1\":{\"79\":1}}],[\"如果某一步没有很好地选择合并或分裂的决定\",{\"1\":{\"16\":1}}],[\"如果不考虑核函数\",{\"1\":{\"15\":1}}],[\"如果不使用激活函数\",{\"1\":{\"14\":1}}],[\"如果没有设置验证集\",{\"1\":{\"10\":1}}],[\"如果把测试集当验证集\",{\"1\":{\"10\":1}}],[\"如果原先的神经元在最大池化操作后输出\",{\"1\":{\"6\":1}}],[\"如果将输入右移一位得到\",{\"1\":{\"6\":1}}],[\"如果之前有所记录就很便于回忆\",{\"1\":{\"2\":1}}],[\"缩小图像\",{\"1\":{\"6\":1}}],[\"转置卷积\",{\"1\":{\"6\":1}}],[\"类似栅格化\",{\"1\":{\"55\":1}}],[\"类似\",{\"1\":{\"6\":1}}],[\"实现非线性\",{\"1\":{\"6\":1}}],[\"在现实场景\",{\"1\":{\"70\":1}}],[\"在拥堵\",{\"1\":{\"66\":1}}],[\"在外围补上固定不变的\",{\"1\":{\"57\":1}}],[\"在二维空间下\",{\"1\":{\"56\":1}}],[\"在应急响应规划中\",{\"1\":{\"27\":1}}],[\"在复杂环境中做出快速决策的\",{\"1\":{\"27\":1}}],[\"在处理噪声点时比较鲁棒\",{\"1\":{\"16\":1}}],[\"在对偶问题下\",{\"1\":{\"15\":1}}],[\"在原始问题下\",{\"1\":{\"15\":1}}],[\"在解决非线性问题时\",{\"1\":{\"15\":1}}],[\"在神经网络中\",{\"1\":{\"14\":1}}],[\"在自变量和超参数确定的情况下逻辑回归可看作广义的线性模型在因变量下服从二元分布的一个特殊情况\",{\"1\":{\"12\":1}}],[\"在训练样本上都存在较大的经验误差\",{\"1\":{\"11\":1}}],[\"在实际问题中\",{\"1\":{\"10\":1}}],[\"在实际应用中\",{\"1\":{\"10\":1}}],[\"在数据处理时\",{\"1\":{\"10\":1}}],[\"在非监督学习中\",{\"1\":{\"10\":1}}],[\"在监督学习中\",{\"1\":{\"10\":1}}],[\"在机器学习中\",{\"1\":{\"10\":1}}],[\"在\",{\"1\":{\"6\":1,\"86\":2}}],[\"在一定程度上防止过拟合\",{\"1\":{\"6\":1}}],[\"在此表示十分感谢\",{\"1\":{\"1\":1}}],[\"进一步的改进点\",{\"0\":{\"76\":1}}],[\"进而减少计算量和参数个数\",{\"1\":{\"6\":1}}],[\"进入到梦中情组\",{\"1\":{\"3\":1}}],[\"下面将分别做进一步阐述\",{\"1\":{\"53\":1}}],[\"下面将针对这方面详细展开论述\",{\"1\":{\"11\":1}}],[\"下面来\",{\"1\":{\"1\":1}}],[\"下采样\",{\"1\":{\"6\":2}}],[\"后剪枝过程是在生成完全的决策树之后\",{\"1\":{\"13\":1}}],[\"后剪枝\",{\"1\":{\"13\":1}}],[\"后查看模型的训练效果及我们的网络是否出现异常\",{\"1\":{\"10\":1}}],[\"后\",{\"1\":{\"6\":1}}],[\"尺度变换\",{\"1\":{\"6\":1}}],[\"那么经过伸缩\",{\"1\":{\"6\":1}}],[\"输出的结果仍将为\",{\"1\":{\"6\":1}}],[\"输入为\",{\"1\":{\"6\":1}}],[\"0799\",{\"1\":{\"74\":1}}],[\"0448\",{\"1\":{\"74\":1}}],[\"05\",{\"1\":{\"74\":1}}],[\"03\",{\"1\":{\"74\":1}}],[\"0972\",{\"1\":{\"74\":1}}],[\"01\",{\"1\":{\"74\":1}}],[\"0\",{\"1\":{\"6\":4,\"16\":1,\"37\":9,\"45\":2,\"46\":1,\"47\":6,\"48\":1,\"54\":1,\"59\":1,\"60\":1,\"70\":1,\"74\":12,\"83\":1,\"84\":2,\"86\":6}}],[\"3d\",{\"1\":{\"80\":1}}],[\"38\",{\"1\":{\"74\":1}}],[\"32\",{\"1\":{\"74\":1}}],[\"34\",{\"1\":{\"74\":1}}],[\"37\",{\"1\":{\"74\":1}}],[\"3035\",{\"1\":{\"74\":1}}],[\"3903\",{\"1\":{\"74\":1}}],[\"39\",{\"1\":{\"74\":1}}],[\"3的时空位置图\",{\"1\":{\"74\":1}}],[\"3\",{\"0\":{\"20\":1,\"32\":1,\"41\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":2,\"66\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":2,\"75\":1,\"76\":1},\"1\":{\"6\":1,\"10\":3,\"11\":6,\"12\":4,\"15\":5,\"16\":1,\"17\":2,\"32\":2,\"37\":2,\"40\":2,\"45\":2,\"46\":3,\"47\":1,\"48\":1,\"50\":1,\"59\":2,\"70\":1,\"74\":5,\"86\":2,\"87\":14}}],[\"5128\",{\"1\":{\"74\":1}}],[\"5669\",{\"1\":{\"74\":1}}],[\"5524\",{\"1\":{\"74\":1}}],[\"5m\",{\"1\":{\"69\":1}}],[\"5\",{\"0\":{\"22\":1,\"76\":1},\"1\":{\"6\":6,\"11\":2,\"15\":1,\"37\":1,\"45\":1,\"46\":5,\"47\":4,\"48\":4,\"69\":1,\"86\":1,\"87\":4}}],[\"1e10\",{\"1\":{\"87\":1}}],[\"1×4\",{\"1\":{\"81\":1}}],[\"1×1\",{\"1\":{\"81\":3}}],[\"16\",{\"1\":{\"86\":1}}],[\"16×30\",{\"1\":{\"81\":1}}],[\"1647\",{\"1\":{\"74\":1}}],[\"1702\",{\"1\":{\"74\":1}}],[\"1782\",{\"1\":{\"74\":1}}],[\"19\",{\"1\":{\"74\":1}}],[\"1970\",{\"1\":{\"59\":1}}],[\"184\",{\"0\":{\"65\":1},\"1\":{\"65\":2}}],[\"10100\",{\"1\":{\"49\":1}}],[\"10\",{\"1\":{\"48\":3,\"86\":1}}],[\"100\",{\"1\":{\"37\":4}}],[\"140\",{\"1\":{\"74\":1}}],[\"14\",{\"1\":{\"48\":1,\"86\":2}}],[\"1534\",{\"1\":{\"74\":1}}],[\"15\",{\"1\":{\"32\":1}}],[\"1377\",{\"1\":{\"74\":1}}],[\"131\",{\"1\":{\"74\":1}}],[\"138\",{\"1\":{\"74\":1}}],[\"13\",{\"1\":{\"32\":1,\"86\":1}}],[\"1241\",{\"1\":{\"74\":1}}],[\"127\",{\"1\":{\"74\":1}}],[\"126\",{\"1\":{\"74\":3}}],[\"122\",{\"1\":{\"74\":1}}],[\"12\",{\"1\":{\"32\":1,\"86\":1}}],[\"115\",{\"1\":{\"74\":1}}],[\"11\",{\"1\":{\"31\":1,\"86\":1}}],[\"1\",{\"0\":{\"18\":1,\"29\":1,\"30\":2,\"31\":1,\"32\":1,\"35\":1,\"36\":2,\"37\":1,\"39\":1,\"44\":1,\"45\":2,\"46\":1,\"50\":1,\"63\":1,\"64\":2,\"65\":1,\"66\":1,\"67\":1,\"69\":1,\"72\":1},\"1\":{\"6\":2,\"10\":3,\"11\":6,\"12\":3,\"13\":1,\"15\":6,\"16\":1,\"17\":3,\"27\":1,\"28\":1,\"31\":1,\"32\":2,\"36\":1,\"37\":5,\"40\":3,\"41\":8,\"43\":1,\"45\":4,\"46\":4,\"47\":8,\"48\":1,\"50\":1,\"53\":1,\"54\":1,\"59\":2,\"60\":1,\"70\":2,\"72\":1,\"74\":6,\"83\":1,\"84\":1,\"86\":29,\"87\":31}}],[\"例如\",{\"1\":{\"6\":1}}],[\"旋转不变性和尺度不变性\",{\"1\":{\"6\":1}}],[\"r=1\",{\"1\":{\"83\":1}}],[\"r=0\",{\"1\":{\"74\":12}}],[\"r\",{\"1\":{\"74\":1}}],[\"rule\",{\"0\":{\"65\":1},\"1\":{\"65\":2}}],[\"rules\",{\"1\":{\"42\":1,\"60\":2}}],[\"rug\",{\"1\":{\"50\":1}}],[\"running\",{\"1\":{\"40\":2}}],[\"rubik\",{\"1\":{\"37\":1}}],[\"right\",{\"1\":{\"28\":2,\"37\":1}}],[\"ridge\",{\"1\":{\"18\":1}}],[\"randomization\",{\"1\":{\"70\":2,\"76\":1}}],[\"randomly\",{\"1\":{\"21\":1}}],[\"rate\",{\"1\":{\"10\":4}}],[\"road\",{\"1\":{\"80\":2}}],[\"role\",{\"1\":{\"46\":1}}],[\"route\",{\"1\":{\"31\":1}}],[\"robotics\",{\"1\":{\"31\":1}}],[\"robot\",{\"1\":{\"28\":2,\"30\":2,\"31\":4,\"37\":2}}],[\"robustness\",{\"1\":{\"19\":1}}],[\"rooted\",{\"1\":{\"31\":1}}],[\"root\",{\"1\":{\"23\":1,\"31\":1}}],[\"row\",{\"1\":{\"6\":1}}],[\"rbf\",{\"1\":{\"15\":1}}],[\"remove\",{\"1\":{\"50\":1}}],[\"removecap\",{\"1\":{\"50\":1}}],[\"remaining\",{\"1\":{\"19\":1,\"47\":1}}],[\"retaining\",{\"1\":{\"50\":1}}],[\"return\",{\"1\":{\"39\":2,\"41\":5,\"42\":1}}],[\"revisited\",{\"0\":{\"48\":1}}],[\"revealed\",{\"1\":{\"38\":1}}],[\"reasons\",{\"1\":{\"66\":1,\"70\":1}}],[\"reason\",{\"1\":{\"48\":1}}],[\"reaching\",{\"1\":{\"70\":1}}],[\"reached\",{\"1\":{\"47\":1}}],[\"reaches\",{\"1\":{\"47\":1,\"50\":1}}],[\"reach\",{\"1\":{\"40\":1,\"47\":1,\"50\":1}}],[\"real\",{\"1\":{\"27\":2,\"43\":1,\"70\":1}}],[\"research\",{\"1\":{\"50\":1}}],[\"respectively\",{\"1\":{\"45\":1}}],[\"resolve\",{\"1\":{\"39\":1,\"41\":3}}],[\"results\",{\"1\":{\"45\":1,\"47\":1}}],[\"resulting\",{\"1\":{\"21\":1,\"23\":1,\"31\":1,\"47\":1}}],[\"result\",{\"1\":{\"11\":1,\"50\":1}}],[\"repmat\",{\"1\":{\"86\":1}}],[\"repelem\",{\"1\":{\"86\":1}}],[\"repeating\",{\"1\":{\"47\":1}}],[\"repeat\",{\"1\":{\"47\":1}}],[\"repeatedly\",{\"1\":{\"31\":1}}],[\"reports\",{\"1\":{\"42\":1}}],[\"representation\",{\"0\":{\"50\":1}}],[\"representations\",{\"1\":{\"49\":1,\"50\":4}}],[\"represented\",{\"1\":{\"31\":1}}],[\"represents\",{\"1\":{\"23\":3,\"31\":1,\"45\":3,\"47\":2}}],[\"represent\",{\"1\":{\"10\":2,\"31\":1,\"45\":1}}],[\"reflects\",{\"1\":{\"70\":1}}],[\"reflect\",{\"1\":{\"70\":1,\"72\":1}}],[\"refers\",{\"1\":{\"47\":1,\"50\":1}}],[\"referred\",{\"1\":{\"30\":1}}],[\"refine\",{\"1\":{\"31\":1}}],[\"refinement\",{\"1\":{\"31\":3}}],[\"redundant\",{\"1\":{\"28\":1,\"47\":1}}],[\"reduction\",{\"1\":{\"20\":1,\"23\":1}}],[\"reducing\",{\"1\":{\"18\":1}}],[\"reduces\",{\"1\":{\"70\":2}}],[\"reduced\",{\"1\":{\"44\":1}}],[\"reduce\",{\"1\":{\"6\":1,\"20\":1}}],[\"receive\",{\"1\":{\"46\":1}}],[\"recycled\",{\"1\":{\"46\":1}}],[\"recall\",{\"1\":{\"31\":1,\"50\":1}}],[\"recurrence\",{\"1\":{\"28\":1,\"45\":1,\"46\":1}}],[\"recurring\",{\"1\":{\"28\":4}}],[\"recursively\",{\"1\":{\"23\":1}}],[\"recognition\",{\"1\":{\"26\":1}}],[\"rely\",{\"1\":{\"47\":1}}],[\"reliable\",{\"1\":{\"19\":1}}],[\"relu\",{\"1\":{\"6\":4}}],[\"regardless\",{\"1\":{\"47\":1}}],[\"regularization\",{\"0\":{\"18\":1},\"1\":{\"11\":1,\"18\":1}}],[\"regression\",{\"1\":{\"10\":2,\"22\":1,\"23\":1}}],[\"池化的作用是什么\",{\"1\":{\"14\":1}}],[\"池化相当于在空间范围内做了维度约减\",{\"1\":{\"6\":1}}],[\"池化操作是模型更加关注是否存在某些特征而不是特征具体的位置\",{\"1\":{\"6\":1}}],[\"池化层的引入是仿照人的视觉系统对视觉输入对象进行降维\",{\"1\":{\"6\":1}}],[\"池化\",{\"1\":{\"6\":1}}],[\"p=zeros\",{\"1\":{\"86\":1}}],[\"pp\",{\"1\":{\"86\":1,\"87\":8}}],[\"ppt\",{\"1\":{\"11\":1,\"13\":1,\"14\":3}}],[\"psychological\",{\"1\":{\"80\":1}}],[\"p称为随机慢化概率\",{\"1\":{\"70\":1}}],[\"phase\",{\"1\":{\"80\":2}}],[\"phantom\",{\"0\":{\"66\":1},\"1\":{\"70\":1}}],[\"physics\",{\"1\":{\"80\":1}}],[\"physicists\",{\"1\":{\"64\":1}}],[\"physical\",{\"1\":{\"31\":1}}],[\"p\",{\"1\":{\"50\":1,\"70\":1,\"74\":1}}],[\"patterns\",{\"1\":{\"80\":1}}],[\"paths\",{\"1\":{\"48\":1}}],[\"path\",{\"0\":{\"94\":1},\"1\":{\"31\":3,\"42\":1,\"47\":1,\"48\":2}}],[\"past\",{\"1\":{\"47\":1}}],[\"passed\",{\"1\":{\"42\":1}}],[\"pairs\",{\"1\":{\"37\":1}}],[\"parallel\",{\"1\":{\"69\":1}}],[\"parameter\",{\"1\":{\"10\":1}}],[\"parameters\",{\"1\":{\"6\":1,\"18\":1,\"26\":1}}],[\"parts\",{\"1\":{\"60\":1}}],[\"partial\",{\"1\":{\"50\":4}}],[\"particular\",{\"0\":{\"40\":1}}],[\"partitions\",{\"1\":{\"21\":1}}],[\"partitioning\",{\"1\":{\"19\":1}}],[\"part\",{\"1\":{\"32\":4,\"47\":1}}],[\"picture\",{\"1\":{\"31\":1}}],[\"put\",{\"1\":{\"50\":1}}],[\"putting\",{\"1\":{\"50\":2}}],[\"purpose\",{\"1\":{\"37\":1}}],[\"puzzle\",{\"1\":{\"31\":1,\"37\":1}}],[\"published\",{\"1\":{\"29\":1}}],[\"platform\",{\"1\":{\"86\":3,\"87\":5}}],[\"platform=ones\",{\"1\":{\"86\":1}}],[\"platforms\",{\"1\":{\"27\":1}}],[\"place\",{\"1\":{\"50\":2}}],[\"placecap\",{\"1\":{\"50\":1}}],[\"plans\",{\"0\":{\"38\":1,\"44\":1,\"47\":1},\"1\":{\"31\":2,\"40\":2,\"46\":1,\"47\":5,\"48\":1}}],[\"planned\",{\"1\":{\"31\":1}}],[\"planning\",{\"0\":{\"28\":1,\"30\":1,\"31\":1,\"34\":1,\"35\":1,\"37\":1,\"43\":1,\"49\":1},\"1\":{\"29\":2,\"30\":1,\"31\":3,\"32\":3,\"41\":1,\"43\":2,\"47\":5,\"48\":2,\"49\":1,\"50\":4,\"80\":2}}],[\"plan\",{\"1\":{\"30\":1,\"31\":17,\"43\":2,\"47\":6,\"50\":2}}],[\"po\",{\"1\":{\"87\":2}}],[\"po=1\",{\"1\":{\"86\":1}}],[\"potential\",{\"1\":{\"45\":1,\"84\":3}}],[\"pose\",{\"1\":{\"80\":1}}],[\"positive\",{\"1\":{\"50\":8}}],[\"position\",{\"1\":{\"31\":2}}],[\"possibly\",{\"1\":{\"39\":1}}],[\"possible\",{\"1\":{\"31\":1,\"37\":1,\"39\":1,\"70\":1}}],[\"possess\",{\"1\":{\"26\":1}}],[\"postpruning\",{\"1\":{\"13\":1}}],[\"points\",{\"1\":{\"21\":1,\"22\":1}}],[\"point\",{\"1\":{\"21\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"people\",{\"1\":{\"86\":1}}],[\"pedestrians\",{\"1\":{\"80\":1}}],[\"pedestrian\",{\"0\":{\"79\":1},\"1\":{\"80\":3}}],[\"penalties\",{\"1\":{\"18\":1}}],[\"penalty\",{\"1\":{\"18\":1}}],[\"period也逐渐变小\",{\"1\":{\"74\":1}}],[\"periodic\",{\"1\":{\"73\":1}}],[\"period\",{\"1\":{\"66\":1}}],[\"per\",{\"1\":{\"31\":1}}],[\"perceptron\",{\"1\":{\"14\":1}}],[\"perturbations\",{\"1\":{\"11\":1}}],[\"performs\",{\"1\":{\"40\":1}}],[\"performed\",{\"1\":{\"31\":1}}],[\"performance\",{\"1\":{\"11\":1,\"19\":3,\"48\":1}}],[\"perform\",{\"1\":{\"6\":1,\"40\":1,\"46\":1}}],[\"pca\",{\"0\":{\"20\":1},\"1\":{\"17\":4,\"20\":1}}],[\"p5\",{\"1\":{\"14\":2}}],[\"p6\",{\"1\":{\"14\":1}}],[\"p2\",{\"1\":{\"12\":1}}],[\"p10\",{\"1\":{\"12\":1}}],[\"p1\",{\"1\":{\"12\":1,\"13\":1}}],[\"p9\",{\"1\":{\"11\":1}}],[\"prune\",{\"1\":{\"48\":1}}],[\"prioritize\",{\"1\":{\"48\":1}}],[\"priority\",{\"1\":{\"41\":1,\"42\":1,\"48\":2}}],[\"principal\",{\"1\":{\"20\":4}}],[\"principle\",{\"0\":{\"20\":1,\"21\":1,\"22\":1,\"23\":1},\"1\":{\"10\":1,\"22\":1}}],[\"pr\",{\"2\":{\"33\":1,\"51\":1}}],[\"prob\",{\"1\":{\"87\":2}}],[\"prob=zeros\",{\"1\":{\"86\":1}}],[\"probabilitiepi\",{\"1\":{\"84\":1}}],[\"probability\",{\"1\":{\"70\":1,\"72\":1}}],[\"problems\",{\"1\":{\"31\":2,\"41\":1,\"43\":1,\"48\":3,\"49\":2,\"50\":1}}],[\"problem\",{\"0\":{\"36\":1},\"1\":{\"11\":1,\"31\":1,\"49\":1,\"50\":2}}],[\"prodces\",{\"1\":{\"50\":1}}],[\"produces\",{\"1\":{\"36\":1,\"45\":1}}],[\"produce\",{\"1\":{\"27\":1,\"48\":1}}],[\"propotion\",{\"1\":{\"74\":1}}],[\"properties\",{\"1\":{\"50\":1}}],[\"propagates\",{\"1\":{\"48\":1}}],[\"pros\",{\"1\":{\"49\":1}}],[\"programming\",{\"1\":{\"48\":1}}],[\"proof\",{\"1\":{\"45\":1}}],[\"provide\",{\"1\":{\"27\":1,\"48\":1}}],[\"prompts\",{\"1\":{\"27\":2}}],[\"processing\",{\"1\":{\"26\":1}}],[\"process\",{\"1\":{\"21\":1,\"45\":1,\"50\":1}}],[\"projection\",{\"1\":{\"20\":1}}],[\"preceeding\",{\"1\":{\"69\":1}}],[\"preconditions\",{\"1\":{\"50\":4}}],[\"preclude\",{\"1\":{\"28\":1}}],[\"predicate\",{\"1\":{\"50\":7}}],[\"predicates\",{\"1\":{\"50\":8}}],[\"predicts\",{\"1\":{\"23\":1}}],[\"prediction\",{\"1\":{\"11\":1}}],[\"predecessor\",{\"1\":{\"47\":1}}],[\"previous\",{\"1\":{\"47\":1}}],[\"prevent\",{\"1\":{\"18\":1,\"28\":1}}],[\"presents\",{\"1\":{\"40\":1}}],[\"presented\",{\"1\":{\"38\":1,\"39\":1}}],[\"preserving\",{\"1\":{\"20\":1}}],[\"press\",{\"1\":{\"29\":1}}],[\"pre\",{\"1\":{\"26\":1}}],[\"prepruning\",{\"1\":{\"13\":1}}],[\"l=zeros\",{\"1\":{\"86\":1}}],[\"ld−c​+c3∗​\",{\"1\":{\"46\":1}}],[\"lda\",{\"1\":{\"12\":1,\"17\":5}}],[\"lb−c​+c3∗​\",{\"1\":{\"46\":1}}],[\"lc−c​=∞\",{\"1\":{\"46\":1}}],[\"lf​\",{\"1\":{\"43\":3,\"46\":1}}],[\"l\",{\"1\":{\"43\":5,\"45\":1,\"47\":4,\"48\":2,\"87\":1}}],[\"less\",{\"1\":{\"48\":1}}],[\"lengths\",{\"0\":{\"47\":1},\"1\":{\"47\":2}}],[\"length\",{\"0\":{\"44\":1},\"1\":{\"43\":2,\"47\":11,\"69\":2,\"72\":1}}],[\"let\",{\"1\":{\"37\":3,\"43\":1,\"45\":2}}],[\"left\",{\"1\":{\"28\":2,\"37\":1,\"45\":1}}],[\"least\",{\"1\":{\"47\":1,\"48\":1}}],[\"learn\",{\"1\":{\"47\":1}}],[\"learning\",{\"1\":{\"10\":4,\"11\":5,\"18\":1,\"19\":1,\"22\":1,\"23\":1,\"26\":3}}],[\"leads\",{\"1\":{\"31\":1,\"47\":1}}],[\"leading\",{\"1\":{\"18\":1,\"47\":1,\"69\":1}}],[\"leaf\",{\"1\":{\"23\":2}}],[\"lij\",{\"1\":{\"87\":1}}],[\"li\",{\"1\":{\"84\":1,\"87\":1}}],[\"literals\",{\"1\":{\"50\":7}}],[\"literal\",{\"1\":{\"50\":6}}],[\"li​\",{\"1\":{\"46\":4}}],[\"line\",{\"1\":{\"39\":3,\"48\":2}}],[\"linearly\",{\"1\":{\"22\":1}}],[\"linear\",{\"1\":{\"10\":1,\"22\":1}}],[\"limit\",{\"1\":{\"31\":1,\"47\":1,\"69\":1,\"70\":1}}],[\"likewise\",{\"1\":{\"46\":1}}],[\"like\",{\"0\":{\"50\":1},\"1\":{\"23\":1,\"43\":1,\"45\":1,\"47\":1,\"49\":1,\"50\":4,\"70\":1,\"72\":1}}],[\"lie\",{\"1\":{\"20\":1}}],[\"l1\",{\"1\":{\"18\":2}}],[\"l2\",{\"1\":{\"15\":1,\"18\":2}}],[\"lr\",{\"1\":{\"15\":5}}],[\"logically\",{\"1\":{\"50\":1}}],[\"logic\",{\"0\":{\"49\":1},\"1\":{\"49\":1,\"50\":1}}],[\"logistic\",{\"1\":{\"10\":1,\"15\":2}}],[\"lowest\",{\"1\":{\"47\":2}}],[\"lower\",{\"1\":{\"11\":1}}],[\"long\",{\"1\":{\"47\":2}}],[\"longer\",{\"1\":{\"21\":1,\"47\":2}}],[\"locations\",{\"1\":{\"31\":1}}],[\"loss\",{\"1\":{\"15\":1,\"18\":1,\"43\":1}}],[\"lol\",{\"1\":{\"3\":2}}],[\"law\",{\"1\":{\"80\":1}}],[\"layout\",{\"1\":{\"80\":1}}],[\"layer\",{\"1\":{\"6\":3}}],[\"lane\",{\"0\":{\"71\":1},\"1\":{\"69\":1,\"73\":1}}],[\"language\",{\"1\":{\"26\":1}}],[\"latter\",{\"1\":{\"46\":1}}],[\"la−c​\",{\"1\":{\"46\":1}}],[\"lashlight\",{\"1\":{\"50\":3}}],[\"last\",{\"1\":{\"40\":1}}],[\"lasso\",{\"1\":{\"18\":1}}],[\"lavalle\",{\"1\":{\"29\":2}}],[\"label\",{\"1\":{\"23\":1,\"48\":3}}],[\"larger\",{\"1\":{\"31\":2,\"70\":1}}],[\"large\",{\"1\":{\"10\":1,\"41\":1}}],[\"f=1\",{\"1\":{\"87\":1}}],[\"f=k+1\",{\"1\":{\"43\":1}}],[\"fd\",{\"1\":{\"74\":1}}],[\"f−1\",{\"1\":{\"47\":4}}],[\"f^\",{\"1\":{\"41\":2}}],[\"fast\",{\"1\":{\"70\":1}}],[\"false\",{\"1\":{\"50\":2}}],[\"family\",{\"1\":{\"48\":1}}],[\"factor\",{\"1\":{\"41\":1}}],[\"failure\",{\"1\":{\"39\":1,\"41\":3,\"42\":1}}],[\"f\",{\"1\":{\"37\":2,\"39\":1,\"41\":1,\"42\":1,\"43\":3,\"45\":1,\"47\":3,\"48\":1,\"50\":3,\"87\":6}}],[\"fluid\",{\"1\":{\"80\":1}}],[\"fluctuations\",{\"1\":{\"70\":2}}],[\"flow\",{\"0\":{\"71\":1},\"1\":{\"67\":2,\"72\":1}}],[\"floor\",{\"1\":{\"37\":1}}],[\"flashlights\",{\"1\":{\"50\":1}}],[\"flashlight\",{\"1\":{\"50\":14}}],[\"flame\",{\"1\":{\"3\":1}}],[\"feedback\",{\"1\":{\"31\":1}}],[\"feasible\",{\"0\":{\"35\":1,\"38\":1}}],[\"feasiblity\",{\"1\":{\"31\":1}}],[\"feature\",{\"1\":{\"10\":1,\"23\":3,\"48\":1}}],[\"features\",{\"1\":{\"6\":2}}],[\"front\",{\"1\":{\"70\":1}}],[\"from\",{\"1\":{\"23\":1,\"31\":1,\"37\":2,\"41\":5,\"42\":4,\"43\":1,\"45\":3,\"46\":4,\"47\":7,\"48\":1,\"50\":1}}],[\"free\",{\"1\":{\"31\":1,\"67\":1}}],[\"focus\",{\"1\":{\"47\":1}}],[\"focuses\",{\"1\":{\"39\":1}}],[\"follows\",{\"1\":{\"60\":1}}],[\"following\",{\"1\":{\"31\":1,\"39\":1,\"42\":1,\"45\":3,\"50\":2}}],[\"folds\",{\"1\":{\"19\":2}}],[\"fold\",{\"1\":{\"19\":2}}],[\"fomular\",{\"1\":{\"27\":1}}],[\"fourth\",{\"1\":{\"31\":1}}],[\"four\",{\"1\":{\"28\":2,\"37\":1,\"45\":1,\"50\":1}}],[\"foudation\",{\"1\":{\"26\":2}}],[\"found\",{\"1\":{\"22\":1,\"40\":1,\"42\":1,\"91\":1}}],[\"force\",{\"1\":{\"80\":3}}],[\"forward\",{\"0\":{\"39\":1,\"40\":1,\"46\":1},\"1\":{\"39\":2,\"40\":1,\"42\":1,\"44\":1,\"46\":2,\"47\":2,\"48\":5,\"70\":1}}],[\"format\",{\"1\":{\"86\":1}}],[\"former\",{\"1\":{\"46\":1}}],[\"formulate\",{\"0\":{\"49\":1}}],[\"formulated\",{\"1\":{\"48\":1}}],[\"formulations\",{\"1\":{\"47\":1}}],[\"formulation\",{\"0\":{\"36\":1},\"1\":{\"36\":1,\"37\":1,\"43\":2,\"50\":1}}],[\"formulas\",{\"1\":{\"47\":2}}],[\"formula\",{\"1\":{\"45\":1,\"47\":2}}],[\"form\",{\"1\":{\"37\":2,\"50\":2}}],[\"for\",{\"0\":{\"38\":1,\"71\":1},\"1\":{\"19\":1,\"22\":2,\"23\":1,\"27\":2,\"29\":1,\"31\":1,\"37\":4,\"39\":3,\"40\":4,\"41\":4,\"42\":4,\"43\":2,\"45\":4,\"46\":3,\"47\":9,\"48\":8,\"49\":1,\"50\":6,\"64\":2,\"70\":1,\"72\":1,\"86\":1,\"87\":11}}],[\"fundemantal\",{\"1\":{\"74\":1}}],[\"fundamental\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"functional\",{\"1\":{\"43\":2}}],[\"functions\",{\"1\":{\"22\":1,\"44\":1,\"46\":1,\"50\":2}}],[\"function\",{\"1\":{\"14\":1,\"15\":1,\"18\":1,\"31\":2,\"40\":2,\"46\":1,\"47\":3,\"50\":3}}],[\"fuels\",{\"1\":{\"66\":1}}],[\"future\",{\"1\":{\"47\":1}}],[\"further\",{\"1\":{\"47\":2}}],[\"fuctional\",{\"1\":{\"45\":1}}],[\"fuction\",{\"1\":{\"36\":1,\"43\":1,\"45\":1}}],[\"fully\",{\"1\":{\"6\":2,\"38\":1}}],[\"five\",{\"1\":{\"45\":3,\"60\":1}}],[\"fixed\",{\"0\":{\"44\":1},\"1\":{\"43\":1,\"46\":2,\"47\":6}}],[\"filo\",{\"1\":{\"40\":1}}],[\"fifo\",{\"1\":{\"40\":1}}],[\"figure\",{\"1\":{\"28\":1,\"31\":1,\"37\":1,\"39\":1,\"45\":1,\"46\":1,\"50\":1}}],[\"finalized\",{\"1\":{\"48\":1}}],[\"final\",{\"1\":{\"31\":1,\"43\":2,\"86\":4,\"87\":8}}],[\"finally\",{\"1\":{\"31\":1}}],[\"finite\",{\"1\":{\"31\":1,\"36\":1,\"43\":1,\"50\":3}}],[\"finds\",{\"1\":{\"80\":1}}],[\"finding\",{\"1\":{\"47\":1,\"48\":1}}],[\"find\",{\"1\":{\"22\":1,\"37\":1,\"40\":2,\"45\":1,\"50\":2}}],[\"fine\",{\"1\":{\"9\":1,\"26\":1}}],[\"firstly\",{\"1\":{\"45\":2}}],[\"first\",{\"1\":{\"20\":1,\"31\":1,\"40\":13,\"48\":1,\"50\":1,\"64\":1}}],[\"fitting\",{\"1\":{\"11\":1}}],[\"fit\",{\"1\":{\"9\":1}}],[\"d=sm\",{\"1\":{\"87\":1}}],[\"dn\",{\"1\":{\"76\":2}}],[\"dn​<δtmin\",{\"1\":{\"76\":1}}],[\"d等人在单车道元胞自动机nasch模型的基础上提出了双车道元胞自动机stca模型\",{\"1\":{\"76\":1}}],[\"driving\",{\"1\":{\"70\":1}}],[\"drive\",{\"1\":{\"70\":2}}],[\"drivers\",{\"1\":{\"70\":4}}],[\"dropout\",{\"1\":{\"11\":1}}],[\"dangerous\",{\"1\":{\"66\":1}}],[\"datasets\",{\"1\":{\"26\":1,\"27\":1}}],[\"dataset\",{\"1\":{\"19\":2,\"21\":1}}],[\"data\",{\"1\":{\"6\":1,\"11\":1,\"18\":1,\"19\":1,\"20\":4,\"21\":2,\"22\":4,\"23\":2}}],[\"dynamic\",{\"1\":{\"48\":2,\"80\":1,\"84\":1}}],[\"duplicate\",{\"1\":{\"39\":1,\"41\":3}}],[\"during\",{\"1\":{\"39\":1}}],[\"does\",{\"1\":{\"48\":1,\"49\":1,\"50\":1}}],[\"done\",{\"1\":{\"47\":1}}],[\"don\",{\"1\":{\"47\":1}}],[\"do\",{\"1\":{\"39\":1,\"41\":2,\"48\":1}}],[\"downloading\",{\"1\":{\"29\":1}}],[\"down\",{\"1\":{\"28\":2,\"37\":1}}],[\"dot\",{\"1\":{\"6\":1}}],[\"dbscan\",{\"1\":{\"16\":8}}],[\"d\",{\"1\":{\"11\":2,\"45\":15,\"46\":3,\"47\":1,\"70\":1,\"86\":1}}],[\"density\",{\"1\":{\"67\":2}}],[\"denoted\",{\"1\":{\"47\":1}}],[\"denote\",{\"1\":{\"43\":2}}],[\"denotes\",{\"1\":{\"37\":1,\"46\":1}}],[\"develped\",{\"1\":{\"64\":1}}],[\"device\",{\"1\":{\"31\":1}}],[\"deviation\",{\"1\":{\"9\":1,\"11\":1}}],[\"design\",{\"1\":{\"80\":1}}],[\"desire\",{\"1\":{\"70\":1}}],[\"desirable\",{\"1\":{\"50\":2}}],[\"description\",{\"0\":{\"68\":1}}],[\"descent\",{\"1\":{\"10\":2}}],[\"destination\",{\"1\":{\"50\":1}}],[\"derived\",{\"1\":{\"50\":1}}],[\"degrades\",{\"1\":{\"48\":1}}],[\"degree\",{\"1\":{\"11\":1}}],[\"define\",{\"1\":{\"50\":2}}],[\"defined\",{\"1\":{\"22\":1,\"43\":2,\"50\":1}}],[\"definition\",{\"1\":{\"45\":1}}],[\"defining\",{\"1\":{\"40\":1}}],[\"demonstrated\",{\"1\":{\"40\":1}}],[\"demention\",{\"1\":{\"6\":1}}],[\"dead\",{\"1\":{\"39\":3,\"60\":1}}],[\"dependent\",{\"1\":{\"76\":1}}],[\"dependency\",{\"1\":{\"47\":1}}],[\"depends\",{\"1\":{\"47\":2}}],[\"depth\",{\"1\":{\"31\":1,\"40\":6}}],[\"depicts\",{\"1\":{\"11\":3}}],[\"determine\",{\"1\":{\"39\":1,\"42\":1}}],[\"determined\",{\"1\":{\"31\":1}}],[\"details\",{\"1\":{\"28\":1}}],[\"decelerates\",{\"1\":{\"72\":1}}],[\"decelerate\",{\"1\":{\"66\":1}}],[\"decades\",{\"1\":{\"31\":1}}],[\"decrements\",{\"1\":{\"28\":2,\"37\":1}}],[\"decrement\",{\"1\":{\"28\":2}}],[\"decisions\",{\"1\":{\"31\":1}}],[\"decision\",{\"0\":{\"23\":1},\"1\":{\"10\":1,\"23\":3,\"30\":1,\"32\":1}}],[\"deepening\",{\"1\":{\"40\":1}}],[\"deep\",{\"1\":{\"26\":1}}],[\"di\",{\"1\":{\"84\":2,\"87\":1}}],[\"diagram\",{\"0\":{\"67\":1},\"1\":{\"66\":1,\"67\":1,\"74\":2}}],[\"diagram所示\",{\"1\":{\"66\":1}}],[\"dirt\",{\"1\":{\"50\":1}}],[\"direction\",{\"1\":{\"47\":1}}],[\"directions\",{\"1\":{\"28\":2,\"37\":1}}],[\"directed\",{\"1\":{\"42\":1}}],[\"directly\",{\"1\":{\"6\":1}}],[\"dijkstra\",{\"0\":{\"48\":1},\"1\":{\"40\":1,\"44\":1,\"48\":4}}],[\"dis\",{\"1\":{\"87\":6}}],[\"discuss\",{\"1\":{\"44\":1}}],[\"discusses\",{\"1\":{\"43\":1}}],[\"discrete\",{\"0\":{\"34\":1,\"35\":1,\"37\":1,\"43\":1,\"49\":1},\"1\":{\"28\":2,\"31\":2,\"37\":1,\"43\":1,\"49\":1,\"50\":1,\"60\":1,\"69\":1}}],[\"disturbances\",{\"1\":{\"66\":2}}],[\"distinguish\",{\"1\":{\"43\":1,\"47\":1}}],[\"distinct\",{\"1\":{\"21\":1,\"80\":1}}],[\"distance\",{\"1\":{\"22\":1,\"40\":2,\"43\":1,\"69\":1,\"70\":1}}],[\"diverse\",{\"1\":{\"26\":1}}],[\"diverge\",{\"1\":{\"10\":1}}],[\"divided\",{\"1\":{\"19\":1,\"69\":1}}],[\"difficuty\",{\"1\":{\"72\":1}}],[\"difficulty\",{\"1\":{\"11\":1}}],[\"differences\",{\"1\":{\"47\":1,\"48\":1}}],[\"differential\",{\"1\":{\"31\":2,\"32\":1}}],[\"different\",{\"1\":{\"19\":2,\"22\":1,\"40\":1,\"47\":2,\"50\":2}}],[\"dimensional\",{\"1\":{\"22\":1,\"37\":1}}],[\"dimensionality\",{\"1\":{\"20\":2}}],[\"dimension\",{\"1\":{\"6\":1,\"9\":1}}],[\"ego\",{\"1\":{\"80\":1}}],[\"emmisions\",{\"1\":{\"66\":1}}],[\"empty\",{\"1\":{\"39\":1,\"41\":2,\"42\":1,\"48\":1,\"69\":1,\"70\":2}}],[\"effects\",{\"1\":{\"50\":4}}],[\"effectively\",{\"1\":{\"47\":1}}],[\"effort\",{\"1\":{\"49\":1}}],[\"efficiency\",{\"1\":{\"48\":1}}],[\"efficient\",{\"1\":{\"31\":1,\"39\":1,\"41\":1,\"48\":3}}],[\"e\",{\"1\":{\"42\":1,\"45\":7,\"46\":3,\"47\":1,\"49\":1}}],[\"else\",{\"1\":{\"39\":1,\"41\":3,\"87\":1}}],[\"elements\",{\"1\":{\"6\":1}}],[\"evacuation\",{\"1\":{\"80\":1}}],[\"evaluated\",{\"1\":{\"19\":1}}],[\"evaluate\",{\"1\":{\"10\":1,\"50\":1}}],[\"every\",{\"1\":{\"39\":2,\"43\":1,\"47\":1,\"60\":1,\"70\":1}}],[\"ei\",{\"1\":{\"84\":2}}],[\"either\",{\"1\":{\"31\":1,\"41\":1,\"50\":1,\"69\":1}}],[\"eigenvalues\",{\"1\":{\"20\":1}}],[\"eigenvectors\",{\"1\":{\"20\":1}}],[\"edu\",{\"1\":{\"29\":1}}],[\"edges\",{\"1\":{\"45\":1}}],[\"edge\",{\"0\":{\"25\":1},\"1\":{\"42\":3,\"45\":3}}],[\"edg\",{\"1\":{\"3\":1}}],[\"english\",{\"0\":{\"93\":1}}],[\"end\",{\"1\":{\"86\":11,\"87\":14}}],[\"enormous\",{\"1\":{\"49\":1}}],[\"entire\",{\"1\":{\"48\":1,\"49\":1}}],[\"entropy\",{\"1\":{\"23\":1}}],[\"enables\",{\"1\":{\"47\":1}}],[\"enabling\",{\"1\":{\"26\":1,\"27\":1}}],[\"energy\",{\"1\":{\"43\":1}}],[\"encode\",{\"1\":{\"80\":1}}],[\"encodes\",{\"1\":{\"42\":1,\"70\":1}}],[\"encodings\",{\"1\":{\"49\":1}}],[\"encountered\",{\"1\":{\"39\":1,\"41\":1}}],[\"ensure\",{\"1\":{\"19\":1,\"31\":1}}],[\"estimates\",{\"1\":{\"47\":1}}],[\"estimate\",{\"1\":{\"19\":1,\"40\":1}}],[\"essentially\",{\"1\":{\"6\":1}}],[\"earlier\",{\"1\":{\"47\":1}}],[\"early\",{\"1\":{\"11\":1,\"42\":1}}],[\"easily\",{\"1\":{\"45\":1,\"48\":1,\"50\":1}}],[\"easy\",{\"1\":{\"37\":1}}],[\"each\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"23\":3,\"28\":2,\"31\":1,\"36\":2,\"37\":2,\"40\":2,\"45\":3,\"46\":1,\"47\":1,\"48\":1,\"50\":3,\"60\":2,\"69\":3}}],[\"equiped\",{\"1\":{\"80\":1}}],[\"equilibria\",{\"1\":{\"48\":1}}],[\"equivalent\",{\"1\":{\"6\":1,\"46\":1}}],[\"equals\",{\"1\":{\"46\":1}}],[\"equal\",{\"1\":{\"40\":1}}],[\"equally\",{\"1\":{\"19\":1}}],[\"equation\",{\"1\":{\"31\":1,\"37\":1,\"45\":4,\"46\":1}}],[\"error\",{\"1\":{\"11\":1}}],[\"epoch\",{\"1\":{\"10\":2}}],[\"existing\",{\"1\":{\"50\":1}}],[\"exists\",{\"1\":{\"39\":1}}],[\"extensive\",{\"1\":{\"80\":1}}],[\"extends\",{\"1\":{\"48\":1}}],[\"extended\",{\"1\":{\"47\":1}}],[\"external\",{\"1\":{\"70\":1}}],[\"extract\",{\"1\":{\"6\":1}}],[\"exsits\",{\"1\":{\"46\":1}}],[\"exact\",{\"1\":{\"43\":1,\"47\":1}}],[\"example\",{\"1\":{\"37\":2,\"40\":1,\"45\":3,\"46\":1,\"47\":3,\"50\":5}}],[\"examples\",{\"0\":{\"37\":1},\"1\":{\"48\":1}}],[\"exhausted\",{\"1\":{\"40\":1,\"41\":1}}],[\"except\",{\"1\":{\"39\":1,\"48\":1}}],[\"executed\",{\"1\":{\"31\":1}}],[\"execute\",{\"1\":{\"31\":1}}],[\"execution\",{\"1\":{\"31\":1}}],[\"exp\",{\"1\":{\"87\":1}}],[\"expand\",{\"1\":{\"48\":1}}],[\"expands\",{\"1\":{\"6\":1,\"48\":1}}],[\"expression\",{\"1\":{\"43\":1}}],[\"expressed\",{\"1\":{\"37\":1,\"50\":2}}],[\"expresses\",{\"1\":{\"11\":1}}],[\"expect\",{\"1\":{\"50\":1}}],[\"expected\",{\"1\":{\"11\":2}}],[\"expensive\",{\"1\":{\"42\":1,\"48\":1}}],[\"explored\",{\"1\":{\"49\":1}}],[\"explores\",{\"1\":{\"48\":2}}],[\"exploration\",{\"1\":{\"48\":1}}],[\"explicitly\",{\"1\":{\"31\":2}}],[\"explanation\",{\"1\":{\"28\":1}}],[\"o=obstacle\",{\"1\":{\"87\":1}}],[\"oi\",{\"1\":{\"84\":1,\"87\":1}}],[\"occur\",{\"1\":{\"70\":1}}],[\"occurs\",{\"1\":{\"41\":1}}],[\"occupied\",{\"1\":{\"69\":1}}],[\"obstacle\",{\"1\":{\"86\":7}}],[\"objects\",{\"1\":{\"50\":1}}],[\"object\",{\"1\":{\"50\":1}}],[\"obviously\",{\"1\":{\"45\":1,\"47\":1,\"50\":1}}],[\"obtain\",{\"1\":{\"42\":1,\"43\":1,\"45\":2,\"47\":1}}],[\"obtained\",{\"1\":{\"40\":1,\"43\":1}}],[\"obtaining\",{\"1\":{\"19\":1}}],[\"o\",{\"1\":{\"40\":2,\"50\":2,\"86\":1}}],[\"outside\",{\"1\":{\"43\":1,\"50\":1}}],[\"out\",{\"1\":{\"40\":2,\"45\":1}}],[\"outcome\",{\"1\":{\"23\":1}}],[\"omitted\",{\"1\":{\"45\":1}}],[\"omits\",{\"1\":{\"28\":1}}],[\"omit\",{\"1\":{\"28\":1}}],[\"operator\",{\"1\":{\"50\":2}}],[\"operators\",{\"1\":{\"50\":5}}],[\"operation\",{\"1\":{\"6\":1,\"40\":1}}],[\"options\",{\"1\":{\"45\":1,\"46\":1}}],[\"optimizing\",{\"1\":{\"43\":1}}],[\"optimality\",{\"1\":{\"31\":1}}],[\"optimal\",{\"0\":{\"43\":1,\"44\":1,\"47\":1},\"1\":{\"22\":1,\"43\":2,\"44\":1,\"45\":1,\"46\":2,\"47\":6,\"48\":3}}],[\"overreations\",{\"1\":{\"66\":1,\"70\":1}}],[\"overwhelming\",{\"1\":{\"50\":1}}],[\"overall\",{\"1\":{\"47\":1}}],[\"over\",{\"1\":{\"31\":1,\"44\":1,\"47\":1,\"48\":2}}],[\"overlapping\",{\"1\":{\"21\":1}}],[\"overfitting\",{\"1\":{\"18\":1}}],[\"otherwise\",{\"1\":{\"43\":1,\"70\":1}}],[\"other\",{\"0\":{\"41\":1},\"1\":{\"20\":1,\"41\":1,\"46\":1,\"50\":2,\"80\":1}}],[\"only\",{\"1\":{\"39\":1,\"40\":1,\"46\":1,\"48\":1,\"50\":3,\"69\":1,\"70\":1}}],[\"once\",{\"1\":{\"31\":1,\"47\":2}}],[\"onward\",{\"1\":{\"28\":1}}],[\"ones\",{\"1\":{\"86\":2}}],[\"one\",{\"1\":{\"28\":6,\"31\":2,\"37\":2,\"39\":1,\"41\":1,\"48\":1,\"50\":4,\"69\":1,\"70\":1}}],[\"on\",{\"1\":{\"11\":1,\"18\":1,\"19\":1,\"20\":1,\"23\":3,\"26\":1,\"31\":1,\"37\":3,\"40\":1,\"45\":1,\"47\":7,\"48\":1,\"50\":11,\"60\":1}}],[\"organization\",{\"0\":{\"32\":1}}],[\"originating\",{\"1\":{\"45\":1}}],[\"originally\",{\"1\":{\"47\":1}}],[\"original\",{\"1\":{\"31\":1}}],[\"orientation\",{\"1\":{\"31\":1,\"80\":1}}],[\"orthogonal\",{\"1\":{\"20\":1}}],[\"or\",{\"1\":{\"10\":1,\"18\":1,\"23\":2,\"28\":2,\"30\":1,\"31\":10,\"36\":1,\"37\":1,\"42\":5,\"43\":1,\"44\":1,\"47\":1,\"50\":7,\"60\":2,\"66\":1,\"69\":1,\"80\":1}}],[\"order\",{\"1\":{\"9\":1}}],[\"oscillate\",{\"1\":{\"9\":1,\"10\":1}}],[\"off\",{\"1\":{\"50\":1}}],[\"offer\",{\"1\":{\"27\":2}}],[\"of\",{\"0\":{\"31\":1,\"32\":1,\"37\":1,\"42\":1,\"47\":1},\"1\":{\"6\":6,\"9\":1,\"10\":1,\"11\":6,\"18\":1,\"19\":3,\"20\":4,\"21\":1,\"22\":1,\"23\":2,\"26\":2,\"27\":2,\"28\":4,\"29\":1,\"30\":2,\"31\":15,\"37\":8,\"38\":3,\"39\":5,\"40\":8,\"43\":9,\"44\":1,\"45\":7,\"46\":2,\"47\":13,\"48\":4,\"49\":2,\"50\":23,\"53\":1,\"60\":2,\"66\":1,\"69\":1,\"70\":8,\"72\":1,\"74\":1,\"80\":4}}],[\"oyh的帮助\",{\"1\":{\"1\":1}}],[\"wave会造成以下危害\",{\"1\":{\"66\":1}}],[\"wave沿车流末端传播的速度\",{\"1\":{\"66\":1}}],[\"wave\",{\"1\":{\"66\":2,\"74\":2}}],[\"want\",{\"1\":{\"47\":1,\"50\":1}}],[\"way\",{\"1\":{\"45\":1,\"47\":1,\"48\":1}}],[\"ways\",{\"1\":{\"31\":1,\"50\":1}}],[\"would\",{\"1\":{\"47\":1,\"48\":1,\"49\":1,\"50\":1}}],[\"words\",{\"1\":{\"50\":2}}],[\"worry\",{\"1\":{\"48\":1}}],[\"work\",{\"1\":{\"41\":1,\"48\":2}}],[\"works\",{\"1\":{\"18\":1,\"21\":1,\"23\":1}}],[\"world\",{\"1\":{\"27\":1,\"31\":1,\"50\":1,\"70\":1}}],[\"written\",{\"1\":{\"45\":1,\"50\":1}}],[\"weights\",{\"1\":{\"45\":1}}],[\"well\",{\"1\":{\"21\":1,\"45\":1}}],[\"we\",{\"1\":{\"20\":1,\"40\":2,\"45\":2,\"46\":5,\"47\":11,\"48\":1,\"49\":1,\"50\":4}}],[\"w\",{\"1\":{\"14\":1,\"15\":1}}],[\"why\",{\"1\":{\"48\":1}}],[\"whether\",{\"1\":{\"39\":2,\"42\":1,\"50\":2}}],[\"wheel\",{\"1\":{\"31\":1}}],[\"when\",{\"1\":{\"31\":1,\"36\":1,\"41\":2,\"47\":1}}],[\"where\",{\"1\":{\"19\":1,\"22\":1,\"23\":1,\"47\":3}}],[\"while\",{\"1\":{\"20\":1,\"31\":1,\"39\":1,\"41\":2,\"43\":1,\"46\":1,\"48\":1}}],[\"which\",{\"1\":{\"11\":1,\"18\":1,\"22\":2,\"26\":1,\"28\":2,\"37\":5,\"39\":2,\"40\":1,\"42\":2,\"43\":2,\"44\":1,\"45\":3,\"46\":3,\"47\":4,\"48\":1,\"50\":10,\"60\":1,\"69\":1}}],[\"what\",{\"0\":{\"18\":1,\"19\":1,\"30\":1}}],[\"who\",{\"1\":{\"3\":1}}],[\"will\",{\"1\":{\"10\":3,\"37\":1,\"39\":1,\"40\":4,\"42\":1,\"43\":1,\"44\":1,\"45\":3,\"46\":1,\"47\":2,\"50\":1}}],[\"within\",{\"1\":{\"21\":1}}],[\"without\",{\"1\":{\"18\":1,\"47\":1,\"48\":1,\"66\":1}}],[\"with\",{\"1\":{\"6\":2,\"36\":1,\"38\":1,\"40\":3,\"41\":1,\"42\":1,\"47\":2,\"48\":1,\"70\":2,\"72\":1,\"73\":1,\"80\":1}}],[\"window\",{\"1\":{\"6\":1}}],[\"avoid\",{\"1\":{\"70\":1}}],[\"available\",{\"1\":{\"29\":1}}],[\"amax​\",{\"1\":{\"72\":1}}],[\"amount\",{\"1\":{\"70\":1}}],[\"amplified\",{\"1\":{\"66\":2}}],[\"automaton\",{\"1\":{\"60\":2}}],[\"automata\",{\"0\":{\"52\":1},\"1\":{\"53\":2,\"60\":1,\"64\":1,\"80\":1}}],[\"away\",{\"1\":{\"48\":1}}],[\"aim\",{\"1\":{\"47\":1}}],[\"aims\",{\"1\":{\"22\":1}}],[\"after\",{\"1\":{\"43\":2}}],[\"again\",{\"1\":{\"39\":1}}],[\"agent\",{\"1\":{\"30\":1}}],[\"appears\",{\"1\":{\"50\":1}}],[\"appear\",{\"1\":{\"43\":1,\"50\":1}}],[\"applying\",{\"1\":{\"43\":1,\"47\":1,\"50\":1}}],[\"apply\",{\"1\":{\"42\":1,\"50\":2}}],[\"applies\",{\"1\":{\"47\":1}}],[\"applied\",{\"1\":{\"31\":2,\"36\":1,\"43\":2,\"45\":1,\"47\":2,\"50\":2}}],[\"applications\",{\"1\":{\"60\":1,\"80\":1}}],[\"application\",{\"1\":{\"38\":1,\"43\":1,\"50\":1}}],[\"approach\",{\"1\":{\"31\":1,\"40\":1,\"47\":1,\"48\":2}}],[\"always\",{\"1\":{\"50\":1,\"70\":2}}],[\"alternative\",{\"1\":{\"48\":1}}],[\"alive\",{\"1\":{\"39\":4,\"48\":3,\"60\":1}}],[\"also\",{\"1\":{\"39\":1,\"40\":1,\"46\":1,\"50\":1}}],[\"already\",{\"1\":{\"38\":1,\"41\":2}}],[\"along\",{\"1\":{\"31\":1,\"48\":1}}],[\"allow\",{\"1\":{\"50\":1}}],[\"allows\",{\"1\":{\"47\":1}}],[\"all\",{\"1\":{\"31\":1,\"37\":2,\"39\":1,\"40\":1,\"41\":3,\"42\":1,\"43\":1,\"45\":1,\"46\":1,\"48\":7,\"50\":1}}],[\"algorithms\",{\"0\":{\"28\":1},\"1\":{\"27\":1,\"29\":1,\"30\":1,\"38\":2,\"39\":1,\"40\":2,\"48\":1,\"50\":1}}],[\"algorithm\",{\"1\":{\"10\":2,\"11\":2,\"21\":1,\"22\":1,\"23\":1,\"38\":1,\"39\":1,\"40\":5,\"42\":2,\"44\":3,\"47\":1,\"48\":6,\"49\":1,\"50\":1}}],[\"adapted\",{\"1\":{\"48\":1}}],[\"adaptive\",{\"1\":{\"27\":1}}],[\"adapting\",{\"1\":{\"26\":1}}],[\"added\",{\"1\":{\"50\":1}}],[\"address\",{\"1\":{\"47\":1}}],[\"additive\",{\"1\":{\"43\":1}}],[\"additional\",{\"1\":{\"18\":1,\"47\":1}}],[\"addition\",{\"1\":{\"6\":1,\"37\":1}}],[\"adding\",{\"1\":{\"18\":1,\"50\":1}}],[\"advances\",{\"1\":{\"43\":1}}],[\"advance\",{\"1\":{\"38\":1,\"47\":1}}],[\"arrive=0\",{\"1\":{\"86\":1}}],[\"arriving\",{\"1\":{\"31\":1}}],[\"architectural\",{\"1\":{\"80\":1}}],[\"architectures\",{\"1\":{\"26\":1}}],[\"argument\",{\"1\":{\"50\":2}}],[\"argmin\",{\"1\":{\"47\":1}}],[\"are\",{\"1\":{\"20\":1,\"22\":1,\"23\":1,\"26\":2,\"30\":1,\"31\":3,\"37\":3,\"38\":1,\"39\":3,\"40\":3,\"42\":2,\"44\":1,\"45\":5,\"47\":4,\"48\":1,\"50\":15}}],[\"aspects\",{\"1\":{\"31\":1,\"80\":1}}],[\"asymptotic\",{\"1\":{\"28\":1,\"40\":1}}],[\"assumed\",{\"1\":{\"50\":2}}],[\"assume\",{\"1\":{\"45\":1}}],[\"assigned\",{\"1\":{\"21\":1}}],[\"assigning\",{\"1\":{\"21\":1}}],[\"assessing\",{\"1\":{\"19\":1}}],[\"as\",{\"1\":{\"18\":1,\"19\":2,\"26\":1,\"30\":1,\"31\":6,\"37\":2,\"39\":1,\"40\":2,\"41\":3,\"43\":2,\"45\":6,\"46\":1,\"47\":1,\"48\":1,\"50\":8,\"66\":1,\"70\":2}}],[\"achieving\",{\"1\":{\"50\":1}}],[\"achieved\",{\"1\":{\"47\":1}}],[\"achieves\",{\"1\":{\"20\":1}}],[\"achieve\",{\"1\":{\"11\":1}}],[\"acceleration\",{\"1\":{\"70\":1,\"72\":2}}],[\"accelerates\",{\"1\":{\"70\":1,\"72\":1}}],[\"accelerate\",{\"1\":{\"66\":1}}],[\"accomplish\",{\"1\":{\"47\":1}}],[\"account\",{\"1\":{\"31\":1}}],[\"accumulated\",{\"1\":{\"45\":1}}],[\"actions\",{\"1\":{\"31\":5,\"37\":1,\"38\":1,\"43\":2,\"47\":2}}],[\"action\",{\"1\":{\"31\":2,\"36\":3,\"42\":1,\"47\":15}}],[\"activation\",{\"1\":{\"14\":1}}],[\"actual\",{\"1\":{\"11\":1}}],[\"able\",{\"1\":{\"50\":1}}],[\"above\",{\"1\":{\"39\":1}}],[\"about\",{\"1\":{\"1\":1,\"48\":1}}],[\"ability\",{\"1\":{\"9\":1,\"10\":1,\"11\":1}}],[\"abstract\",{\"1\":{\"6\":1}}],[\"analogous\",{\"1\":{\"47\":1}}],[\"analysis\",{\"1\":{\"10\":1,\"20\":1}}],[\"another\",{\"1\":{\"47\":1,\"66\":1}}],[\"an\",{\"1\":{\"6\":1,\"31\":1,\"37\":1,\"38\":1,\"40\":1,\"42\":4,\"43\":1,\"45\":1,\"50\":3}}],[\"any\",{\"1\":{\"6\":1,\"11\":1,\"20\":1,\"31\":2,\"39\":1,\"46\":1,\"47\":2,\"50\":4}}],[\"and\",{\"1\":{\"6\":1,\"10\":1,\"11\":1,\"19\":5,\"20\":2,\"21\":2,\"22\":2,\"23\":2,\"26\":4,\"27\":2,\"28\":1,\"31\":4,\"37\":3,\"39\":3,\"40\":4,\"41\":6,\"42\":1,\"43\":3,\"44\":1,\"45\":2,\"46\":3,\"47\":7,\"48\":5,\"49\":1,\"50\":16,\"60\":4,\"64\":2,\"66\":5,\"69\":3,\"72\":1,\"80\":3}}],[\"at\",{\"1\":{\"6\":1,\"29\":1,\"31\":3,\"39\":1,\"40\":1,\"41\":1,\"43\":1,\"47\":3,\"48\":3,\"60\":1,\"70\":1}}],[\"a\",{\"0\":{\"42\":1,\"50\":1,\"71\":1},\"1\":{\"6\":5,\"15\":1,\"18\":2,\"19\":4,\"20\":2,\"21\":2,\"22\":3,\"23\":9,\"30\":1,\"31\":20,\"36\":1,\"37\":4,\"39\":6,\"40\":7,\"41\":1,\"42\":5,\"43\":3,\"45\":15,\"46\":6,\"47\":13,\"48\":10,\"49\":1,\"50\":24,\"60\":4,\"64\":1,\"66\":1,\"69\":1,\"70\":1}}],[\"i+neigh\",{\"1\":{\"87\":1}}],[\"irrelevant\",{\"1\":{\"50\":1}}],[\"i=2\",{\"1\":{\"87\":1}}],[\"i=\",{\"1\":{\"50\":1}}],[\"i=1\",{\"1\":{\"40\":1,\"87\":2}}],[\"ideas\",{\"1\":{\"46\":1}}],[\"i\",{\"1\":{\"37\":3,\"39\":2,\"40\":5,\"41\":7,\"50\":4,\"70\":8,\"84\":5,\"86\":7,\"87\":17}}],[\"illinois\",{\"1\":{\"29\":1}}],[\"immediate\",{\"1\":{\"47\":2}}],[\"immediately\",{\"1\":{\"46\":1}}],[\"imagine\",{\"1\":{\"50\":1}}],[\"imagined\",{\"1\":{\"31\":1,\"37\":1}}],[\"images\",{\"1\":{\"80\":1}}],[\"image\",{\"1\":{\"6\":4}}],[\"imperfect\",{\"1\":{\"70\":2}}],[\"implied\",{\"1\":{\"50\":1}}],[\"implicit\",{\"1\":{\"49\":1}}],[\"implicitly\",{\"1\":{\"31\":2}}],[\"improves\",{\"1\":{\"48\":1}}],[\"improving\",{\"1\":{\"48\":1}}],[\"important\",{\"1\":{\"38\":1,\"48\":1,\"50\":1}}],[\"impurity\",{\"1\":{\"23\":2}}],[\"impact\",{\"1\":{\"11\":1}}],[\"ica\",{\"1\":{\"10\":1}}],[\"if\",{\"1\":{\"10\":2,\"37\":1,\"39\":2,\"40\":2,\"41\":7,\"42\":4,\"43\":1,\"48\":4,\"70\":1,\"87\":3}}],[\"iterations\",{\"1\":{\"45\":1}}],[\"iteration\",{\"0\":{\"45\":1,\"46\":1},\"1\":{\"44\":3,\"46\":1,\"47\":6,\"48\":7}}],[\"iteratively\",{\"1\":{\"44\":1,\"45\":1,\"47\":1}}],[\"iterative\",{\"1\":{\"40\":1}}],[\"iterate\",{\"1\":{\"42\":1}}],[\"iterates\",{\"1\":{\"21\":1,\"48\":1}}],[\"its\",{\"1\":{\"20\":1,\"45\":1,\"48\":1,\"50\":2,\"69\":1,\"70\":1}}],[\"itself\",{\"1\":{\"11\":2}}],[\"it\",{\"1\":{\"6\":1,\"11\":2,\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"31\":4,\"37\":1,\"41\":2,\"42\":1,\"43\":1,\"44\":1,\"45\":2,\"47\":4,\"48\":4,\"50\":7,\"60\":1,\"70\":5,\"80\":1}}],[\"issue\",{\"1\":{\"47\":1}}],[\"issues\",{\"1\":{\"27\":1}}],[\"is\",{\"0\":{\"18\":1,\"19\":1,\"30\":1},\"1\":{\"6\":2,\"10\":2,\"18\":1,\"19\":5,\"20\":1,\"21\":2,\"22\":4,\"23\":2,\"28\":2,\"30\":1,\"31\":4,\"37\":3,\"38\":3,\"39\":6,\"40\":4,\"41\":4,\"42\":4,\"43\":10,\"44\":1,\"45\":6,\"46\":4,\"47\":17,\"48\":7,\"49\":1,\"50\":22,\"60\":1,\"64\":1,\"69\":3,\"70\":1}}],[\"inhomogeneous\",{\"1\":{\"72\":2}}],[\"inhomogenous\",{\"0\":{\"71\":1}}],[\"inherited\",{\"1\":{\"43\":1}}],[\"inefficient\",{\"1\":{\"50\":1}}],[\"indicates\",{\"1\":{\"50\":1}}],[\"indicate\",{\"1\":{\"50\":2}}],[\"independent\",{\"1\":{\"47\":1}}],[\"index\",{\"1\":{\"47\":2}}],[\"inappropriate\",{\"1\":{\"47\":1}}],[\"invested\",{\"1\":{\"49\":1}}],[\"investigated\",{\"1\":{\"40\":1}}],[\"involving\",{\"1\":{\"43\":1}}],[\"involve\",{\"1\":{\"31\":2}}],[\"involves\",{\"1\":{\"19\":1,\"42\":1,\"50\":3}}],[\"institute\",{\"1\":{\"50\":1}}],[\"instances\",{\"1\":{\"50\":9}}],[\"instance\",{\"1\":{\"45\":1,\"46\":1,\"50\":3}}],[\"instead\",{\"1\":{\"38\":1}}],[\"inserted\",{\"1\":{\"42\":1,\"50\":1}}],[\"insert\",{\"1\":{\"39\":2,\"41\":6,\"42\":1,\"48\":2,\"50\":3}}],[\"initialization\",{\"1\":{\"42\":1}}],[\"initializing\",{\"1\":{\"21\":1}}],[\"initially\",{\"1\":{\"39\":2,\"40\":1,\"50\":2}}],[\"initial\",{\"1\":{\"31\":2,\"36\":1,\"37\":1,\"40\":1,\"41\":2,\"42\":1,\"46\":1,\"50\":4}}],[\"ingredients\",{\"0\":{\"31\":1}}],[\"input\",{\"1\":{\"23\":1,\"45\":1}}],[\"inf\",{\"1\":{\"87\":1}}],[\"infinite\",{\"1\":{\"31\":2,\"36\":1,\"37\":1,\"46\":1}}],[\"information\",{\"0\":{\"69\":1},\"1\":{\"23\":1,\"80\":2}}],[\"infj\",{\"1\":{\"3\":1}}],[\"incurred\",{\"1\":{\"47\":3}}],[\"includes\",{\"1\":{\"60\":1,\"69\":1}}],[\"included\",{\"1\":{\"50\":1}}],[\"include\",{\"1\":{\"42\":1,\"48\":1}}],[\"including\",{\"1\":{\"26\":1,\"27\":1,\"48\":1}}],[\"inclusion\",{\"1\":{\"31\":3}}],[\"incorporate\",{\"1\":{\"40\":1}}],[\"incorporated\",{\"1\":{\"31\":2}}],[\"incorporates\",{\"1\":{\"31\":1}}],[\"incorporating\",{\"1\":{\"18\":1}}],[\"increase\",{\"1\":{\"40\":1,\"47\":1}}],[\"increasing\",{\"1\":{\"18\":1}}],[\"incrementally\",{\"1\":{\"38\":1}}],[\"increments\",{\"1\":{\"28\":2,\"37\":1}}],[\"increment\",{\"1\":{\"28\":2}}],[\"in\",{\"0\":{\"28\":1,\"71\":1},\"1\":{\"11\":2,\"18\":2,\"19\":1,\"21\":1,\"23\":1,\"27\":1,\"28\":2,\"31\":10,\"37\":5,\"38\":2,\"39\":6,\"40\":2,\"41\":5,\"42\":4,\"43\":2,\"44\":1,\"45\":4,\"46\":4,\"47\":11,\"48\":5,\"49\":2,\"50\":21,\"60\":2,\"66\":1,\"69\":1,\"70\":4,\"80\":2}}],[\"introduce\",{\"1\":{\"43\":1,\"45\":1,\"46\":1,\"47\":2,\"72\":1}}],[\"introduction\",{\"0\":{\"0\":1,\"29\":1,\"35\":1}}],[\"intro\",{\"1\":{\"32\":1}}],[\"integers\",{\"1\":{\"37\":1}}],[\"integer\",{\"1\":{\"37\":2}}],[\"integrates\",{\"1\":{\"27\":1,\"40\":1}}],[\"interactions\",{\"1\":{\"70\":1}}],[\"interaction\",{\"1\":{\"70\":1}}],[\"interpreted\",{\"1\":{\"50\":1}}],[\"interesting\",{\"1\":{\"37\":1}}],[\"interchangeable\",{\"1\":{\"30\":1}}],[\"internal\",{\"1\":{\"23\":1}}],[\"into\",{\"1\":{\"6\":2,\"19\":2,\"20\":1,\"21\":1,\"22\":2,\"31\":3,\"42\":2,\"47\":2,\"50\":2,\"66\":2,\"69\":1}}],[\"c∗\",{\"1\":{\"47\":2}}],[\"c₅\",{\"1\":{\"46\":1}}],[\"c₄\",{\"1\":{\"46\":1}}],[\"c₃\",{\"1\":{\"46\":1}}],[\"c₂\",{\"1\":{\"46\":1}}],[\"c₁\",{\"1\":{\"46\":1}}],[\"c3∗​\",{\"1\":{\"46\":1}}],[\"ck−1∗​\",{\"1\":{\"46\":1}}],[\"ck∗​\",{\"1\":{\"46\":4}}],[\"c4∗​\",{\"1\":{\"46\":2}}],[\"c\",{\"1\":{\"40\":3,\"45\":12,\"46\":8,\"47\":1,\"48\":9}}],[\"circumstances\",{\"1\":{\"39\":1,\"45\":1}}],[\"cs\",{\"1\":{\"29\":1}}],[\"csuer\",{\"1\":{\"3\":1}}],[\"cube\",{\"1\":{\"37\":1}}],[\"cumbersome\",{\"1\":{\"28\":2}}],[\"cutting\",{\"0\":{\"25\":1}}],[\"current\",{\"1\":{\"11\":1,\"36\":1,\"40\":2,\"45\":1,\"47\":1,\"48\":1,\"60\":1}}],[\"choose\",{\"1\":{\"87\":2}}],[\"choose=zeros\",{\"1\":{\"86\":1}}],[\"chosen\",{\"1\":{\"23\":1}}],[\"check\",{\"1\":{\"42\":1}}],[\"children\",{\"1\":{\"31\":2}}],[\"characterized\",{\"1\":{\"69\":1}}],[\"challenging\",{\"1\":{\"50\":1}}],[\"chapter\",{\"0\":{\"29\":1,\"34\":1},\"1\":{\"32\":4}}],[\"changed\",{\"1\":{\"47\":1}}],[\"changes\",{\"1\":{\"11\":1,\"31\":1,\"47\":2,\"60\":1}}],[\"change\",{\"1\":{\"11\":1,\"21\":1,\"45\":1}}],[\"changing\",{\"1\":{\"6\":1,\"47\":1}}],[\"crowds\",{\"1\":{\"80\":1}}],[\"crosswalk\",{\"1\":{\"80\":1}}],[\"cross\",{\"0\":{\"19\":1},\"1\":{\"19\":2}}],[\"critical\",{\"1\":{\"67\":2}}],[\"criterion\",{\"1\":{\"31\":1}}],[\"creation\",{\"1\":{\"27\":1}}],[\"create\",{\"1\":{\"23\":1}}],[\"clc\",{\"1\":{\"86\":1}}],[\"clear\",{\"1\":{\"66\":1,\"86\":1}}],[\"clever\",{\"1\":{\"48\":1}}],[\"close\",{\"1\":{\"31\":1,\"66\":1}}],[\"closest\",{\"1\":{\"22\":1}}],[\"classical\",{\"1\":{\"40\":1}}],[\"classification\",{\"1\":{\"22\":1,\"23\":1}}],[\"class\",{\"1\":{\"23\":1,\"48\":1}}],[\"classes\",{\"1\":{\"22\":1}}],[\"clusters\",{\"1\":{\"21\":2}}],[\"clustering\",{\"1\":{\"21\":1}}],[\"cluster\",{\"0\":{\"16\":1},\"1\":{\"21\":1}}],[\"celluar\",{\"1\":{\"80\":1}}],[\"cellular\",{\"0\":{\"52\":1},\"1\":{\"53\":1,\"60\":2,\"64\":1}}],[\"cells\",{\"1\":{\"69\":1,\"70\":2}}],[\"cell\",{\"1\":{\"60\":7,\"69\":1,\"70\":1,\"84\":1}}],[\"centroid\",{\"1\":{\"21\":1}}],[\"centroids\",{\"1\":{\"21\":3}}],[\"certain\",{\"1\":{\"6\":1,\"42\":1,\"50\":1}}],[\"cat\",{\"1\":{\"86\":2}}],[\"ca\",{\"1\":{\"53\":1,\"54\":1,\"58\":1,\"79\":2,\"80\":1}}],[\"case\",{\"1\":{\"40\":1,\"41\":2,\"42\":3,\"46\":2,\"48\":1}}],[\"cambridge\",{\"1\":{\"29\":1}}],[\"capacity\",{\"1\":{\"67\":1}}],[\"capable\",{\"1\":{\"26\":1}}],[\"cap\",{\"1\":{\"50\":11}}],[\"capture\",{\"1\":{\"6\":1}}],[\"calculates\",{\"1\":{\"47\":1}}],[\"calculate\",{\"1\":{\"45\":1,\"46\":1}}],[\"calculating\",{\"1\":{\"20\":1}}],[\"called\",{\"1\":{\"20\":1,\"40\":1,\"45\":1,\"50\":3}}],[\"caused\",{\"1\":{\"11\":1}}],[\"candidate\",{\"1\":{\"48\":1}}],[\"cannot\",{\"1\":{\"40\":2,\"70\":1}}],[\"can\",{\"1\":{\"6\":2,\"11\":1,\"20\":1,\"22\":1,\"28\":1,\"30\":1,\"31\":8,\"37\":1,\"39\":3,\"43\":1,\"44\":1,\"45\":8,\"46\":2,\"47\":5,\"48\":1,\"50\":4,\"60\":1,\"66\":1,\"69\":1}}],[\"correcting\",{\"1\":{\"48\":3}}],[\"corresponding\",{\"1\":{\"6\":1,\"37\":1,\"50\":2}}],[\"covering\",{\"1\":{\"48\":1}}],[\"covariance\",{\"1\":{\"20\":1}}],[\"costs\",{\"1\":{\"47\":1,\"48\":1}}],[\"cost\",{\"1\":{\"40\":3,\"43\":4,\"44\":2,\"45\":2,\"46\":3,\"47\":24,\"48\":10}}],[\"collision\",{\"1\":{\"31\":1,\"70\":1}}],[\"collection\",{\"1\":{\"31\":1}}],[\"could\",{\"1\":{\"42\":2,\"48\":2,\"50\":1}}],[\"countably\",{\"1\":{\"31\":1}}],[\"course\",{\"1\":{\"6\":1,\"39\":1}}],[\"copyright\",{\"1\":{\"29\":1}}],[\"coordinates\",{\"1\":{\"20\":1,\"37\":1,\"69\":1,\"80\":2}}],[\"coordinate\",{\"1\":{\"20\":1,\"28\":2,\"37\":1}}],[\"combines\",{\"1\":{\"47\":1}}],[\"combinations\",{\"1\":{\"45\":1,\"50\":2}}],[\"come\",{\"1\":{\"20\":1,\"40\":1,\"44\":1,\"46\":2,\"47\":3,\"48\":6}}],[\"commonly\",{\"1\":{\"23\":1}}],[\"common\",{\"1\":{\"19\":1,\"50\":1}}],[\"complete\",{\"1\":{\"60\":1}}],[\"complex\",{\"1\":{\"27\":1}}],[\"complexity\",{\"1\":{\"18\":1}}],[\"computing\",{\"1\":{\"48\":2,\"60\":2}}],[\"computes\",{\"1\":{\"46\":1}}],[\"compute\",{\"1\":{\"44\":1}}],[\"computer\",{\"1\":{\"26\":1,\"49\":1}}],[\"compare\",{\"1\":{\"46\":1}}],[\"compared\",{\"1\":{\"6\":1}}],[\"compact\",{\"1\":{\"21\":1}}],[\"components\",{\"1\":{\"20\":3,\"43\":1}}],[\"component\",{\"1\":{\"10\":1,\"20\":1}}],[\"conflicting\",{\"1\":{\"80\":1}}],[\"conway于\",{\"1\":{\"59\":1}}],[\"conditions\",{\"1\":{\"44\":1}}],[\"condition\",{\"1\":{\"42\":1}}],[\"constant\",{\"1\":{\"70\":2}}],[\"constructing\",{\"1\":{\"45\":1,\"49\":1}}],[\"constructs\",{\"1\":{\"40\":1}}],[\"constraint\",{\"1\":{\"32\":1,\"47\":1}}],[\"constraints\",{\"1\":{\"31\":1}}],[\"constrain\",{\"1\":{\"18\":1}}],[\"consists\",{\"1\":{\"50\":1}}],[\"consider\",{\"1\":{\"72\":1}}],[\"considered\",{\"1\":{\"39\":1,\"50\":1}}],[\"considerations\",{\"1\":{\"31\":1}}],[\"considers\",{\"1\":{\"31\":1}}],[\"cons\",{\"1\":{\"49\":1}}],[\"consumed\",{\"1\":{\"43\":1}}],[\"context\",{\"1\":{\"47\":1}}],[\"contain\",{\"1\":{\"45\":1}}],[\"contribute\",{\"1\":{\"39\":1}}],[\"controller\",{\"1\":{\"30\":1}}],[\"continuous\",{\"1\":{\"23\":1,\"31\":2,\"48\":1}}],[\"convenience\",{\"1\":{\"37\":1,\"43\":1}}],[\"converge\",{\"1\":{\"9\":1,\"10\":2}}],[\"converted\",{\"1\":{\"6\":1,\"45\":1}}],[\"convolution\",{\"1\":{\"6\":5}}],[\"connected\",{\"1\":{\"6\":2,\"31\":1}}],[\"任何全连接层都能被转换为一个等价卷积层\",{\"1\":{\"6\":1}}],[\"其定义如下\",{\"1\":{\"84\":1}}],[\"其他道路使用者状态\",{\"1\":{\"80\":1}}],[\"其在城市规划\",{\"1\":{\"80\":1}}],[\"其元胞规则为\",{\"1\":{\"59\":1}}],[\"其状态可能是死亡\",{\"1\":{\"59\":1}}],[\"其中\",{\"1\":{\"16\":1,\"84\":2}}],[\"其中不变形性包括\",{\"1\":{\"6\":1}}],[\"其采用的是有放回的随机抽样方法\",{\"1\":{\"11\":1}}],[\"其能更好地捕获图像的空间特征\",{\"1\":{\"6\":1}}],[\"其实很早就萌生过写\",{\"1\":{\"1\":1}}],[\"卷积前后图像尺寸之间的关系是什么\",{\"1\":{\"14\":1}}],[\"卷积本质上也是一种对数据维度的变换\",{\"1\":{\"6\":1}}],[\"卷积核\",{\"1\":{\"6\":1}}],[\"卷积就是用一个可移动的窗口\",{\"1\":{\"6\":1}}],[\"卷积\",{\"0\":{\"5\":1},\"1\":{\"6\":1}}],[\"感谢你看到这里\",{\"1\":{\"4\":1}}],[\"❤️\",{\"1\":{\"4\":2}}],[\"博主的自我介绍\",{\"1\":{\"4\":1}}],[\"读研期间英语学习的纪录\",{\"1\":{\"4\":1}}],[\"纪录读研阶段学习内容\",{\"1\":{\"4\":1}}],[\"路径规划\",{\"1\":{\"4\":1}}],[\"笔记及代码\",{\"1\":{\"4\":1}}],[\"机器学习三个主要分类是什么\",{\"1\":{\"10\":1}}],[\"机器学习流程\",{\"1\":{\"10\":1}}],[\"机器学习是研究计算机怎样模拟或实现人类的学习行为\",{\"1\":{\"10\":1}}],[\"机器学习是一种实现人工智能的方法\",{\"1\":{\"10\":1}}],[\"机器学习\",{\"0\":{\"8\":1},\"1\":{\"4\":1}}],[\"乐评\",{\"1\":{\"4\":1}}],[\"有人\",{\"1\":{\"87\":1}}],[\"有时候很难找到一个合适的核函数\",{\"1\":{\"15\":1}}],[\"有时间也会加入书评\",{\"1\":{\"4\":1}}],[\"有导师的学习\",{\"1\":{\"14\":1}}],[\"有欠拟合风险\",{\"1\":{\"13\":1}}],[\"有些分支当前划分虽然不能提升泛化性能\",{\"1\":{\"13\":1}}],[\"有和环境交互的能力\",{\"1\":{\"10\":1}}],[\"有点变化\",{\"1\":{\"3\":1}}],[\"自主车辆\",{\"1\":{\"80\":1}}],[\"自动驾驶系统所需具良好的泛化能力\",{\"1\":{\"27\":1}}],[\"自底向上对所有非叶节点逐一考察\",{\"1\":{\"13\":1}}],[\"自助法主要面向数据集同规模的划分问题\",{\"1\":{\"11\":1}}],[\"自助法等\",{\"1\":{\"11\":1}}],[\"自编码器\",{\"1\":{\"10\":1}}],[\"自学内容的整理等\",{\"1\":{\"4\":1}}],[\"自我感觉是一个矛盾体\",{\"1\":{\"3\":1}}],[\"自我评价\",{\"1\":{\"3\":1}}],[\"小研究\",{\"1\":{\"4\":1}}],[\"国足进世界杯\",{\"1\":{\"3\":1}}],[\"国家队比赛\",{\"1\":{\"3\":1}}],[\"统一\",{\"1\":{\"3\":1}}],[\"two\",{\"1\":{\"37\":1,\"39\":1,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"47\":2,\"50\":3}}],[\"twin\",{\"1\":{\"3\":1}}],[\"tile\",{\"1\":{\"37\":3}}],[\"tiles\",{\"1\":{\"31\":1}}],[\"time\",{\"1\":{\"19\":1,\"31\":4,\"40\":2,\"43\":1,\"48\":2,\"60\":1,\"66\":1,\"69\":1,\"74\":1,\"86\":1}}],[\"times\",{\"1\":{\"19\":2,\"31\":1}}],[\"term\",{\"1\":{\"43\":3}}],[\"termination\",{\"1\":{\"42\":1,\"47\":4}}],[\"terminates\",{\"1\":{\"41\":1}}],[\"terms\",{\"1\":{\"18\":1}}],[\"tells\",{\"1\":{\"47\":1}}],[\"tell\",{\"1\":{\"39\":1}}],[\"template\",{\"1\":{\"39\":2,\"40\":1}}],[\"text\",{\"1\":{\"27\":1}}],[\"technology\",{\"0\":{\"25\":1}}],[\"techniques\",{\"1\":{\"26\":1}}],[\"technique\",{\"1\":{\"18\":1,\"19\":1,\"20\":1}}],[\"tests\",{\"1\":{\"42\":1}}],[\"test\",{\"1\":{\"10\":1,\"27\":1,\"39\":1}}],[\"taking\",{\"1\":{\"47\":1}}],[\"take\",{\"1\":{\"31\":1,\"45\":2,\"50\":1}}],[\"taken\",{\"1\":{\"31\":1}}],[\"takes\",{\"1\":{\"28\":2,\"37\":1,\"47\":1}}],[\"table\",{\"1\":{\"45\":1,\"50\":1}}],[\"target\",{\"1\":{\"23\":1}}],[\"tasks\",{\"1\":{\"22\":1,\"23\":1,\"26\":1}}],[\"task\",{\"1\":{\"11\":1}}],[\"talk\",{\"1\":{\"1\":1}}],[\"t\",{\"1\":{\"11\":1,\"47\":1,\"50\":1,\"87\":4}}],[\"tuning\",{\"1\":{\"10\":1,\"26\":1}}],[\"tune\",{\"1\":{\"9\":1}}],[\"trucks\",{\"1\":{\"74\":1}}],[\"true\",{\"1\":{\"47\":1,\"50\":2}}],[\"triggering\",{\"1\":{\"60\":1}}],[\"trivial\",{\"1\":{\"28\":1,\"42\":1}}],[\"try\",{\"1\":{\"46\":1}}],[\"treated\",{\"1\":{\"37\":1}}],[\"trees\",{\"1\":{\"41\":1,\"42\":1,\"50\":1}}],[\"tree\",{\"0\":{\"23\":1},\"1\":{\"10\":1,\"23\":3,\"31\":3,\"40\":1,\"41\":1,\"42\":1}}],[\"trajectory\",{\"1\":{\"80\":1}}],[\"track\",{\"1\":{\"38\":1}}],[\"transition\",{\"1\":{\"36\":1,\"37\":2,\"38\":1,\"43\":1,\"45\":1,\"84\":1}}],[\"transformer\",{\"1\":{\"26\":2}}],[\"transform\",{\"1\":{\"22\":1}}],[\"transforms\",{\"1\":{\"20\":1,\"31\":1,\"37\":1}}],[\"transformation\",{\"1\":{\"6\":1}}],[\"traffic\",{\"0\":{\"66\":1,\"71\":1,\"95\":1},\"1\":{\"27\":1,\"64\":1,\"66\":3,\"80\":1},\"2\":{\"78\":1,\"90\":1}}],[\"traversing\",{\"1\":{\"23\":1}}],[\"trained\",{\"1\":{\"19\":1,\"26\":1}}],[\"training\",{\"1\":{\"11\":1,\"19\":2,\"26\":1,\"27\":1}}],[\"train\",{\"1\":{\"10\":2}}],[\"than\",{\"1\":{\"46\":1,\"48\":1,\"70\":1}}],[\"that\",{\"1\":{\"6\":1,\"11\":1,\"19\":1,\"20\":2,\"21\":1,\"22\":1,\"23\":1,\"27\":1,\"28\":3,\"31\":6,\"37\":4,\"38\":3,\"39\":5,\"40\":3,\"41\":1,\"43\":1,\"45\":3,\"46\":4,\"47\":7,\"48\":3,\"49\":2,\"50\":14,\"70\":1}}],[\"thus\",{\"1\":{\"46\":2,\"48\":1,\"50\":1}}],[\"things\",{\"1\":{\"50\":1}}],[\"third\",{\"1\":{\"31\":1}}],[\"this\",{\"0\":{\"32\":1},\"1\":{\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"31\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":2,\"43\":3,\"44\":2,\"45\":3,\"47\":8,\"48\":1,\"50\":2,\"70\":1}}],[\"three\",{\"1\":{\"31\":1,\"39\":1}}],[\"through\",{\"1\":{\"31\":2,\"38\":1,\"45\":1}}],[\"theory\",{\"1\":{\"53\":1,\"60\":1}}],[\"theoretical\",{\"1\":{\"64\":1}}],[\"theoretic\",{\"1\":{\"32\":1}}],[\"their\",{\"1\":{\"45\":1,\"60\":1}}],[\"they\",{\"1\":{\"39\":1,\"45\":1,\"50\":1}}],[\"thereby\",{\"1\":{\"60\":1}}],[\"therefore\",{\"1\":{\"40\":1,\"49\":1}}],[\"there\",{\"1\":{\"31\":2,\"39\":3,\"42\":3,\"44\":1,\"45\":2,\"46\":1,\"47\":1,\"48\":2,\"50\":1,\"70\":1}}],[\"these\",{\"1\":{\"26\":1,\"39\":2,\"40\":1}}],[\"theme\",{\"1\":{\"28\":2}}],[\"them\",{\"1\":{\"21\":1,\"26\":1,\"45\":3}}],[\"then\",{\"1\":{\"21\":1,\"37\":1,\"40\":1,\"42\":3,\"48\":1}}],[\"the\",{\"0\":{\"42\":1},\"1\":{\"6\":11,\"10\":5,\"11\":14,\"18\":6,\"19\":9,\"20\":10,\"21\":7,\"22\":10,\"23\":10,\"27\":2,\"28\":3,\"30\":2,\"31\":30,\"37\":10,\"38\":6,\"39\":6,\"40\":10,\"41\":9,\"42\":5,\"43\":17,\"44\":2,\"45\":24,\"46\":12,\"47\":62,\"48\":11,\"49\":4,\"50\":46,\"60\":3,\"69\":4,\"70\":8,\"72\":4,\"80\":2}}],[\"total=960\",{\"1\":{\"86\":1}}],[\"total\",{\"1\":{\"47\":6,\"86\":1}}],[\"top\",{\"1\":{\"20\":1}}],[\"too\",{\"1\":{\"10\":2,\"48\":1,\"66\":1}}],[\"to\",{\"0\":{\"35\":1,\"49\":1},\"1\":{\"6\":3,\"18\":4,\"19\":1,\"20\":2,\"21\":4,\"22\":4,\"23\":3,\"26\":1,\"27\":2,\"31\":8,\"37\":3,\"39\":2,\"40\":5,\"41\":1,\"42\":4,\"43\":3,\"44\":4,\"45\":11,\"46\":8,\"47\":27,\"48\":20,\"49\":3,\"50\":21,\"66\":1,\"69\":1,\"70\":3,\"72\":2}}],[\"冰岛\",{\"1\":{\"3\":1}}],[\"欧洲游\",{\"1\":{\"3\":1}}],[\"欧洲杯\",{\"1\":{\"3\":1}}],[\"欧冠\",{\"1\":{\"3\":1}}],[\"亚冠\",{\"1\":{\"3\":1}}],[\"现场看一次球赛\",{\"1\":{\"3\":1}}],[\"现场看一场\",{\"1\":{\"3\":1}}],[\"看一次霉妈的演唱会\",{\"1\":{\"3\":1}}],[\"看待问题十分的现实\",{\"1\":{\"3\":1}}],[\"m和chowdhury\",{\"1\":{\"76\":1}}],[\"microscopic\",{\"1\":{\"80\":1}}],[\"michael\",{\"1\":{\"64\":2}}],[\"min\",{\"1\":{\"48\":1}}],[\"minimum\",{\"1\":{\"48\":1}}],[\"minimizing\",{\"1\":{\"47\":1}}],[\"minimizes\",{\"1\":{\"47\":1,\"48\":1}}],[\"minimize\",{\"1\":{\"21\":1,\"47\":3}}],[\"min​\",{\"1\":{\"47\":2}}],[\"might\",{\"1\":{\"41\":2,\"50\":2}}],[\"much\",{\"1\":{\"48\":1}}],[\"must\",{\"1\":{\"31\":1,\"38\":2,\"46\":2,\"50\":3}}],[\"multiple\",{\"1\":{\"19\":1,\"48\":1}}],[\"multiplication\",{\"1\":{\"6\":1}}],[\"moore邻居选择示意图\",{\"1\":{\"84\":1}}],[\"moore\",{\"1\":{\"56\":2,\"59\":2,\"83\":1}}],[\"motivation\",{\"1\":{\"48\":1}}],[\"motion\",{\"1\":{\"32\":1,\"80\":1}}],[\"motions\",{\"1\":{\"31\":1,\"37\":1}}],[\"modifications\",{\"1\":{\"48\":1}}],[\"modeling\",{\"1\":{\"80\":1}}],[\"modeled\",{\"1\":{\"31\":1}}],[\"models\",{\"1\":{\"26\":3}}],[\"model\",{\"0\":{\"64\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1},\"1\":{\"18\":2,\"19\":4,\"23\":1,\"26\":1,\"31\":1,\"50\":1,\"60\":2,\"64\":5,\"70\":1,\"80\":2}}],[\"momentum\",{\"1\":{\"31\":1}}],[\"moving\",{\"1\":{\"37\":1}}],[\"movement\",{\"1\":{\"80\":1}}],[\"moves\",{\"1\":{\"37\":1}}],[\"move\",{\"1\":{\"31\":1,\"66\":1}}],[\"movable\",{\"1\":{\"6\":1}}],[\"monotonicity\",{\"1\":{\"28\":1}}],[\"more\",{\"1\":{\"19\":1,\"27\":1,\"28\":1,\"31\":2,\"39\":1,\"41\":1,\"42\":1,\"48\":3,\"50\":5,\"66\":2}}],[\"most\",{\"1\":{\"19\":1,\"20\":1,\"40\":1,\"50\":1}}],[\"mesoscopic\",{\"1\":{\"80\":1}}],[\"mechanism\",{\"1\":{\"47\":1}}],[\"mechanical\",{\"1\":{\"31\":1}}],[\"meet\",{\"1\":{\"41\":1}}],[\"metric\",{\"1\":{\"48\":1}}],[\"metrics\",{\"1\":{\"23\":1}}],[\"methods\",{\"0\":{\"40\":1,\"42\":1},\"1\":{\"38\":1,\"42\":1}}],[\"method\",{\"1\":{\"11\":1,\"19\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1}}],[\"measured\",{\"1\":{\"23\":1,\"43\":1}}],[\"measures\",{\"1\":{\"11\":2}}],[\"meaningless\",{\"1\":{\"50\":1}}],[\"meaning\",{\"1\":{\"47\":1}}],[\"mean\",{\"1\":{\"21\":1}}],[\"means\",{\"0\":{\"21\":1},\"1\":{\"16\":7,\"21\":1,\"40\":1,\"43\":1,\"47\":1,\"50\":1}}],[\"m\",{\"1\":{\"11\":1,\"29\":2,\"69\":1,\"76\":1}}],[\"map=ones\",{\"1\":{\"86\":1}}],[\"map\",{\"1\":{\"80\":1,\"86\":6,\"87\":8}}],[\"macroscopic\",{\"1\":{\"80\":1}}],[\"machine\",{\"0\":{\"22\":1},\"1\":{\"10\":1,\"18\":1,\"19\":1,\"22\":1,\"26\":1}}],[\"made\",{\"1\":{\"50\":2}}],[\"maintain\",{\"1\":{\"48\":1}}],[\"maintaining\",{\"1\":{\"48\":1}}],[\"maintains\",{\"1\":{\"48\":1}}],[\"mainly\",{\"1\":{\"44\":2}}],[\"making\",{\"1\":{\"47\":1,\"48\":1}}],[\"maker\",{\"1\":{\"30\":1}}],[\"maximum\",{\"1\":{\"67\":1,\"72\":3}}],[\"maximize\",{\"1\":{\"22\":1,\"23\":1}}],[\"max\",{\"1\":{\"40\":1,\"87\":3}}],[\"mark\",{\"1\":{\"39\":2,\"41\":6}}],[\"margin\",{\"1\":{\"22\":1}}],[\"management\",{\"1\":{\"80\":1}}],[\"many\",{\"1\":{\"37\":1,\"41\":1,\"48\":1,\"49\":1,\"50\":3,\"60\":1}}],[\"manipulate\",{\"1\":{\"31\":1}}],[\"master\",{\"1\":{\"31\":1}}],[\"massive\",{\"1\":{\"26\":1}}],[\"may\",{\"1\":{\"31\":2,\"43\":1,\"45\":1,\"46\":1,\"48\":1,\"50\":2}}],[\"matrix\",{\"1\":{\"20\":1}}],[\"magnitude\",{\"1\":{\"9\":2,\"10\":1,\"18\":1}}],[\"ml\",{\"0\":{\"92\":1},\"1\":{\"4\":1},\"2\":{\"7\":1,\"24\":1}}],[\"msi\",{\"1\":{\"3\":1}}],[\"myself\",{\"1\":{\"1\":1,\"4\":1}}],[\"赛\",{\"1\":{\"3\":1}}],[\"✓\",{\"1\":{\"3\":1}}],[\"探究生命的意义\",{\"1\":{\"3\":1}}],[\"却也逐渐看清了生活的本质\",{\"1\":{\"3\":1}}],[\"梦想很多\",{\"1\":{\"3\":1}}],[\"⚽\",{\"1\":{\"3\":1}}],[\"足球\",{\"1\":{\"3\":1}}],[\"吉他\",{\"1\":{\"3\":1}}],[\"唱歌\",{\"1\":{\"3\":1}}],[\"听歌\",{\"1\":{\"3\":1}}],[\"爱好\",{\"1\":{\"3\":1}}],[\"绿老头一枚\",{\"1\":{\"3\":1}}],[\"🎸\",{\"1\":{\"3\":1}}],[\"🎤\",{\"1\":{\"3\":1}}],[\"🎧\",{\"1\":{\"3\":1}}],[\"🍓\",{\"1\":{\"3\":1}}],[\"🏫\",{\"1\":{\"3\":1}}],[\"sm\",{\"1\":{\"86\":6}}],[\"sm=ones\",{\"1\":{\"86\":1}}],[\"smaller\",{\"1\":{\"46\":1}}],[\"smallest\",{\"1\":{\"40\":1,\"45\":1,\"48\":1,\"50\":1}}],[\"small\",{\"1\":{\"10\":1,\"48\":1,\"66\":2}}],[\"slow\",{\"1\":{\"72\":1}}],[\"slowdown\",{\"1\":{\"70\":1}}],[\"slowly\",{\"1\":{\"10\":1,\"66\":1}}],[\"s=randsrc\",{\"1\":{\"87\":1}}],[\"s=\",{\"1\":{\"50\":1}}],[\"symmetrically\",{\"1\":{\"46\":2}}],[\"systematic\",{\"1\":{\"38\":1}}],[\"system\",{\"1\":{\"20\":1,\"47\":3,\"50\":1}}],[\"social\",{\"1\":{\"80\":1}}],[\"solver\",{\"1\":{\"50\":1}}],[\"solve\",{\"1\":{\"49\":2}}],[\"solving\",{\"1\":{\"47\":1}}],[\"solution\",{\"1\":{\"40\":2,\"42\":2,\"47\":1,\"50\":1}}],[\"so\",{\"1\":{\"45\":3,\"47\":2,\"48\":1,\"50\":2}}],[\"sorted\",{\"1\":{\"42\":1,\"48\":1}}],[\"sort\",{\"1\":{\"40\":2}}],[\"sorting\",{\"1\":{\"40\":1}}],[\"sora有助于提高交通管理系统的准备性和响应能力\",{\"1\":{\"27\":1}}],[\"sora可以用来模拟自然灾害\",{\"1\":{\"27\":1}}],[\"sora可以帮助预测和分析交通模式\",{\"1\":{\"27\":1}}],[\"sora生成的视频可以模拟各种决策场景\",{\"1\":{\"27\":1}}],[\"sora结合了gpt技术\",{\"1\":{\"27\":1}}],[\"sora\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"some\",{\"1\":{\"39\":1,\"42\":2,\"44\":1,\"47\":1,\"48\":2,\"50\":1}}],[\"shortest\",{\"1\":{\"48\":1}}],[\"short\",{\"1\":{\"40\":2,\"64\":1,\"72\":1,\"86\":1}}],[\"shown\",{\"1\":{\"37\":1,\"45\":1,\"48\":2,\"50\":1}}],[\"shape\",{\"1\":{\"6\":1}}],[\"safe\",{\"1\":{\"69\":1,\"70\":1}}],[\"says\",{\"1\":{\"50\":1}}],[\"saying\",{\"1\":{\"47\":1}}],[\"satisfied\",{\"1\":{\"42\":1}}],[\"satisfies\",{\"1\":{\"31\":1}}],[\"satisfying\",{\"1\":{\"31\":1}}],[\"same\",{\"1\":{\"11\":1,\"40\":1,\"46\":2,\"47\":1}}],[\"scenario\",{\"1\":{\"70\":1}}],[\"scenarios\",{\"1\":{\"27\":1}}],[\"schreckenberg\",{\"0\":{\"64\":1},\"1\":{\"64\":4}}],[\"schemes\",{\"0\":{\"41\":1}}],[\"scnarios\",{\"1\":{\"27\":1,\"80\":1}}],[\"spite\",{\"1\":{\"31\":1}}],[\"spent\",{\"1\":{\"48\":1}}],[\"special\",{\"1\":{\"40\":1,\"47\":1}}],[\"specific\",{\"1\":{\"42\":1,\"47\":1,\"50\":1}}],[\"specified\",{\"1\":{\"38\":1,\"47\":1}}],[\"specify\",{\"1\":{\"31\":2,\"40\":2}}],[\"speed逐渐降低\",{\"1\":{\"74\":1}}],[\"speed\",{\"1\":{\"67\":2,\"70\":6}}],[\"speed以及波次间隔时间wave\",{\"1\":{\"66\":1}}],[\"speeds\",{\"1\":{\"31\":1}}],[\"speech\",{\"1\":{\"26\":1}}],[\"splits\",{\"1\":{\"23\":1}}],[\"splitting\",{\"1\":{\"23\":1}}],[\"spaces\",{\"1\":{\"48\":1}}],[\"space\",{\"1\":{\"22\":1,\"31\":1,\"36\":2,\"44\":1,\"48\":1,\"49\":2,\"60\":1,\"66\":2,\"69\":1,\"74\":1}}],[\"spatial\",{\"1\":{\"6\":1,\"80\":1}}],[\"sensors\",{\"1\":{\"80\":1}}],[\"sense\",{\"1\":{\"39\":1}}],[\"semantic\",{\"1\":{\"80\":1}}],[\"self\",{\"1\":{\"66\":1}}],[\"select\",{\"1\":{\"42\":2,\"47\":1}}],[\"selecting\",{\"1\":{\"20\":1,\"47\":3}}],[\"serves\",{\"1\":{\"46\":1}}],[\"search\",{\"0\":{\"39\":1,\"40\":1,\"41\":1,\"42\":1},\"1\":{\"38\":2,\"39\":5,\"40\":8,\"41\":6,\"42\":5,\"48\":1}}],[\"searching\",{\"0\":{\"38\":1}}],[\"sections\",{\"1\":{\"48\":1}}],[\"section\",{\"1\":{\"38\":1,\"40\":1,\"43\":2,\"44\":1,\"46\":1,\"47\":1,\"48\":2}}],[\"second\",{\"1\":{\"31\":1}}],[\"seems\",{\"1\":{\"48\":1}}],[\"see\",{\"1\":{\"31\":1,\"45\":1}}],[\"sequence\",{\"1\":{\"31\":2,\"37\":1,\"43\":2}}],[\"several\",{\"1\":{\"28\":1,\"40\":1,\"50\":2}}],[\"separator\",{\"1\":{\"22\":1}}],[\"separates\",{\"1\":{\"22\":1}}],[\"separated\",{\"1\":{\"21\":1}}],[\"separable\",{\"1\":{\"22\":1}}],[\"setg\",{\"1\":{\"50\":1}}],[\"sets\",{\"1\":{\"19\":1,\"37\":1,\"50\":5}}],[\"set\",{\"1\":{\"11\":1,\"19\":2,\"31\":1,\"37\":2,\"47\":2,\"48\":4,\"50\":10,\"60\":1}}],[\"surrounding\",{\"1\":{\"80\":1}}],[\"sustained\",{\"1\":{\"66\":1}}],[\"summary\",{\"1\":{\"50\":2}}],[\"sum\",{\"1\":{\"43\":1,\"47\":1,\"87\":2}}],[\"success\",{\"1\":{\"39\":1,\"41\":4}}],[\"such\",{\"1\":{\"18\":1,\"20\":1,\"26\":1,\"39\":1,\"50\":2,\"66\":1}}],[\"suppose\",{\"1\":{\"37\":3,\"45\":1,\"46\":1}}],[\"support\",{\"0\":{\"22\":1},\"1\":{\"10\":1,\"22\":3}}],[\"superficial\",{\"1\":{\"28\":1}}],[\"supervised\",{\"1\":{\"22\":1,\"23\":1}}],[\"subroutine\",{\"1\":{\"31\":1}}],[\"subgroups\",{\"1\":{\"21\":1}}],[\"substantial\",{\"1\":{\"49\":1}}],[\"substantially\",{\"1\":{\"18\":1}}],[\"subsets\",{\"1\":{\"19\":1}}],[\"svm\",{\"0\":{\"15\":1},\"1\":{\"15\":20,\"22\":4}}],[\"si\",{\"1\":{\"84\":2}}],[\"sideback\",{\"1\":{\"76\":1}}],[\"sidefront\",{\"1\":{\"76\":1}}],[\"since\",{\"1\":{\"47\":2}}],[\"single\",{\"0\":{\"71\":1},\"1\":{\"42\":1,\"48\":2,\"73\":1}}],[\"simple\",{\"1\":{\"50\":1,\"70\":1}}],[\"simply\",{\"1\":{\"31\":1,\"47\":1,\"50\":1}}],[\"simultaneously\",{\"1\":{\"48\":2}}],[\"simulation\",{\"0\":{\"79\":1},\"1\":{\"31\":1,\"60\":1,\"64\":1,\"80\":1}}],[\"simulating\",{\"1\":{\"27\":1,\"80\":1}}],[\"similarity\",{\"1\":{\"47\":1}}],[\"similar\",{\"1\":{\"47\":1}}],[\"signal\",{\"1\":{\"80\":2}}],[\"significantly\",{\"1\":{\"21\":1}}],[\"sigmoid\",{\"1\":{\"6\":3}}],[\"sized\",{\"1\":{\"19\":1}}],[\"size\",{\"1\":{\"6\":1,\"11\":1,\"86\":3,\"87\":5}}],[\"studies\",{\"1\":{\"80\":1}}],[\"stca模型在应用过程中将一个时步分为两个相同的子时步\",{\"1\":{\"76\":1}}],[\"stca\",{\"1\":{\"76\":1}}],[\"stochastic\",{\"1\":{\"48\":1}}],[\"stop\",{\"1\":{\"47\":2,\"66\":2}}],[\"stopping\",{\"1\":{\"11\":1}}],[\"strips\",{\"0\":{\"50\":1},\"1\":{\"50\":3}}],[\"strategy\",{\"1\":{\"48\":1}}],[\"structure\",{\"1\":{\"23\":1,\"80\":1}}],[\"still\",{\"1\":{\"40\":1,\"46\":1}}],[\"star\",{\"1\":{\"86\":3}}],[\"start\",{\"1\":{\"41\":1,\"46\":1,\"48\":1,\"72\":2}}],[\"starting\",{\"1\":{\"31\":1,\"41\":1,\"42\":1}}],[\"static\",{\"1\":{\"84\":1}}],[\"stationary\",{\"1\":{\"72\":1}}],[\"statements\",{\"1\":{\"50\":1}}],[\"states\",{\"1\":{\"31\":3,\"38\":1,\"39\":6,\"42\":2,\"43\":1,\"48\":11,\"49\":1}}],[\"state\",{\"1\":{\"3\":1,\"31\":8,\"36\":7,\"37\":4,\"38\":1,\"39\":6,\"40\":4,\"41\":4,\"42\":1,\"43\":1,\"44\":1,\"45\":7,\"46\":1,\"47\":16,\"48\":8,\"49\":2,\"50\":2,\"60\":4,\"80\":1}}],[\"stanford\",{\"1\":{\"50\":1}}],[\"stage\",{\"1\":{\"43\":3,\"45\":1,\"46\":2,\"47\":4}}],[\"stages\",{\"1\":{\"43\":1,\"47\":2}}],[\"stack\",{\"1\":{\"40\":1}}],[\"stays\",{\"1\":{\"31\":1}}],[\"steven\",{\"1\":{\"29\":2}}],[\"step=1\",{\"1\":{\"86\":1}}],[\"stepping\",{\"1\":{\"37\":1}}],[\"steps\",{\"1\":{\"28\":2,\"37\":1,\"40\":3,\"42\":1,\"47\":2,\"50\":1}}],[\"step\",{\"0\":{\"70\":1},\"1\":{\"6\":1,\"40\":1,\"42\":2,\"43\":1,\"47\":1,\"60\":1,\"70\":5}}],[\"s\",{\"1\":{\"3\":1,\"18\":1,\"19\":1,\"20\":1,\"37\":1,\"40\":1,\"45\":3,\"48\":3,\"50\":3,\"72\":1,\"87\":6}}],[\"swiftie\",{\"1\":{\"3\":1}}],[\"成分\",{\"1\":{\"3\":1}}],[\"水瓶座\",{\"1\":{\"3\":1}}],[\"星座\",{\"1\":{\"3\":1}}],[\"urban\",{\"1\":{\"80\":1}}],[\"ulam和john\",{\"1\":{\"53\":1}}],[\"u−1\",{\"1\":{\"47\":5}}],[\"u∗=argu∈u\",{\"1\":{\"47\":1}}],[\"u∗\",{\"1\":{\"47\":3}}],[\"u2​\",{\"1\":{\"47\":2}}],[\"ut​\",{\"1\":{\"47\":4}}],[\"ud​b\",{\"1\":{\"45\":1}}],[\"ud​c\",{\"1\":{\"45\":1}}],[\"uc​d\",{\"1\":{\"45\":1}}],[\"ub​d\",{\"1\":{\"45\":1}}],[\"u4​\",{\"1\":{\"45\":3}}],[\"uk−1min​sumi=1k−1​l\",{\"1\":{\"46\":1}}],[\"uk\",{\"1\":{\"45\":1}}],[\"ukmin​sumi=kk​l\",{\"1\":{\"45\":1}}],[\"uk​\",{\"1\":{\"43\":8,\"45\":2,\"46\":2}}],[\"u1​\",{\"1\":{\"43\":1,\"47\":2}}],[\"u^\",{\"1\":{\"41\":4}}],[\"u∈u\",{\"1\":{\"37\":1,\"39\":1}}],[\"u=argu−1∈u−1\",{\"1\":{\"47\":1}}],[\"u=\",{\"1\":{\"37\":1}}],[\"u\",{\"1\":{\"36\":4,\"37\":4,\"39\":4,\"41\":5,\"42\":1,\"43\":1,\"47\":9,\"48\":5}}],[\"uiuc\",{\"1\":{\"29\":1}}],[\"us\",{\"1\":{\"47\":1}}],[\"usually\",{\"1\":{\"42\":1}}],[\"using\",{\"0\":{\"49\":1},\"1\":{\"19\":1,\"26\":1,\"37\":1}}],[\"users\",{\"1\":{\"80\":1}}],[\"user\",{\"1\":{\"30\":1}}],[\"uses\",{\"1\":{\"22\":1,\"48\":2}}],[\"used\",{\"1\":{\"18\":1,\"22\":1,\"23\":1,\"31\":1,\"45\":1,\"47\":3,\"50\":1}}],[\"use\",{\"1\":{\"6\":1,\"31\":1,\"40\":3,\"46\":1,\"48\":1}}],[\"unnecessary\",{\"1\":{\"47\":1}}],[\"unreasonable\",{\"1\":{\"47\":1}}],[\"unspecified\",{\"0\":{\"47\":1},\"1\":{\"47\":2}}],[\"unseen\",{\"1\":{\"18\":1}}],[\"unless\",{\"1\":{\"42\":1}}],[\"unvisited\",{\"1\":{\"39\":2}}],[\"unpredictable\",{\"1\":{\"31\":1}}],[\"understood\",{\"1\":{\"45\":1}}],[\"understand\",{\"1\":{\"27\":1}}],[\"understanding\",{\"1\":{\"26\":1,\"38\":1}}],[\"under\",{\"1\":{\"31\":3,\"32\":1,\"50\":4}}],[\"uncountably\",{\"1\":{\"31\":1}}],[\"unit\",{\"1\":{\"70\":2}}],[\"uniformly\",{\"1\":{\"47\":1}}],[\"unified\",{\"0\":{\"42\":1}}],[\"unimportant\",{\"1\":{\"28\":1}}],[\"university\",{\"1\":{\"3\":1,\"29\":2}}],[\"until\",{\"1\":{\"21\":1,\"31\":1,\"40\":1,\"41\":1}}],[\"upper\",{\"1\":{\"47\":1}}],[\"updating\",{\"1\":{\"21\":1}}],[\"updated\",{\"1\":{\"69\":1}}],[\"updates\",{\"1\":{\"48\":3,\"60\":1}}],[\"update\",{\"1\":{\"10\":1}}],[\"up\",{\"1\":{\"2\":1,\"28\":2,\"37\":1,\"50\":1,\"72\":1}}],[\"就无法选择\",{\"1\":{\"84\":1}}],[\"就会发生的\",{\"1\":{\"70\":1}}],[\"就是机器学习的其中一种方法\",{\"1\":{\"10\":1}}],[\"就是那个california\",{\"1\":{\"3\":1}}],[\"就显得非常合适\",{\"1\":{\"2\":1}}],[\"对元胞潜能进行归一化\",{\"1\":{\"84\":1}}],[\"对行人流仿真进一步了解可以移步此篇论文\",{\"1\":{\"80\":1}}],[\"对数据进行合适的编码\",{\"1\":{\"80\":1}}],[\"对数据集异常点不敏感\",{\"1\":{\"16\":1}}],[\"对交通规划\",{\"1\":{\"27\":1}}],[\"对簇形状和密度的适应性\",{\"1\":{\"16\":1}}],[\"对高维数据和不均匀密度数据的处理相对困难\",{\"1\":{\"16\":1}}],[\"对参数的选择敏感\",{\"1\":{\"16\":1}}],[\"对象总数\",{\"1\":{\"16\":1}}],[\"对不同形状的簇和噪声具有较好的鲁棒性\",{\"1\":{\"16\":1}}],[\"对偶问题将原始问题中的约束转为了对偶问题中的等式约束\",{\"1\":{\"15\":1}}],[\"对逻辑回归而言\",{\"1\":{\"15\":1}}],[\"对异常点非常敏感\",{\"1\":{\"15\":1}}],[\"对具有同一规律的学习集以外的数据\",{\"1\":{\"10\":1}}],[\"对于未到达最大速度的车辆\",{\"1\":{\"70\":1}}],[\"对于\",{\"1\":{\"59\":2}}],[\"对于自动驾驶\",{\"1\":{\"27\":1}}],[\"对于非球形簇或具有不同密度的簇效果较差\",{\"1\":{\"16\":1}}],[\"对于非线性特征\",{\"1\":{\"15\":1}}],[\"对于非线性可分的数据集\",{\"1\":{\"15\":2}}],[\"对于一个新的数据样本\",{\"1\":{\"10\":1}}],[\"对于深层网络\",{\"1\":{\"6\":1}}],[\"对伸缩的不变形\",{\"1\":{\"6\":1}}],[\"对\",{\"1\":{\"3\":1}}],[\"一般常用为固定型和周期型边界条件\",{\"1\":{\"57\":1}}],[\"一般为二维\",{\"1\":{\"54\":1}}],[\"一个完整的元胞自动机模型包含\",{\"1\":{\"53\":1}}],[\"一\",{\"0\":{\"10\":1}}],[\"一种下采样方式\",{\"1\":{\"6\":1}}],[\"一枚\",{\"1\":{\"3\":1}}],[\"一名在读\",{\"1\":{\"3\":1}}],[\"一时难以消化吸收\",{\"1\":{\"1\":1}}],[\"职业\",{\"1\":{\"3\":1}}],[\"我们使用的样本通常是多维数据\",{\"1\":{\"10\":1}}],[\"我们通常得等到测试集才可以知道我们模型真正得实力\",{\"1\":{\"10\":1}}],[\"我\",{\"0\":{\"3\":1}}],[\"我会逐步去完善\",{\"1\":{\"1\":1}}],[\"尝试新的记录生活的方式\",{\"1\":{\"2\":1}}],[\"走出舒适圈\",{\"1\":{\"2\":1}}],[\"写过的很多代码\",{\"1\":{\"2\":1}}],[\"写在前面\",{\"0\":{\"1\":1}}],[\"发现自己之前做过的很多小项目\",{\"1\":{\"2\":1}}],[\"准备夏令营过程中\",{\"1\":{\"2\":1}}],[\"主成分\",{\"1\":{\"20\":1}}],[\"主成分分析\",{\"1\":{\"10\":1,\"20\":1}}],[\"主要用来训练神经网络中的参数\",{\"1\":{\"10\":1}}],[\"主要有三个功效\",{\"1\":{\"6\":1}}],[\"主要为自学\",{\"1\":{\"4\":1}}],[\"主要记录本科专业一些相关学习内容\",{\"1\":{\"4\":1}}],[\"主\",{\"1\":{\"2\":1}}],[\"音乐区\",{\"1\":{\"2\":1}}],[\"想当一个知识区博主\",{\"1\":{\"2\":1}}],[\"缘由\",{\"0\":{\"2\":1}}],[\"布局\",{\"1\":{\"1\":1}}],[\"📝\",{\"1\":{\"3\":1}}],[\"💭\",{\"1\":{\"3\":1}}],[\"👐\",{\"1\":{\"2\":1}}],[\"💖\",{\"1\":{\"1\":1}}],[\"👋\",{\"1\":{\"0\":1}}],[\"back\",{\"1\":{\"50\":1}}],[\"backward\",{\"0\":{\"45\":1},\"1\":{\"41\":3,\"42\":2,\"44\":1,\"46\":1,\"47\":1}}],[\"battery\",{\"1\":{\"50\":1}}],[\"battery2\",{\"1\":{\"50\":6}}],[\"battery1\",{\"1\":{\"50\":7}}],[\"batteries\",{\"1\":{\"50\":6}}],[\"basic\",{\"0\":{\"31\":1},\"1\":{\"50\":1}}],[\"based\",{\"1\":{\"23\":3,\"31\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":3,\"60\":1,\"64\":1}}],[\"braking\",{\"1\":{\"66\":1,\"70\":1}}],[\"branching\",{\"1\":{\"41\":1}}],[\"branch\",{\"1\":{\"23\":1,\"30\":1}}],[\"broader\",{\"1\":{\"48\":2}}],[\"bring\",{\"1\":{\"47\":1}}],[\"breadth\",{\"1\":{\"40\":2}}],[\"breath\",{\"1\":{\"40\":2}}],[\"binary\",{\"1\":{\"50\":1}}],[\"bidirectional\",{\"1\":{\"41\":2,\"42\":1}}],[\"billions\",{\"1\":{\"26\":1}}],[\"bias\",{\"1\":{\"11\":1,\"18\":1}}],[\"border\",{\"1\":{\"86\":5,\"87\":3}}],[\"border=ones\",{\"1\":{\"86\":1}}],[\"books\",{\"1\":{\"50\":1}}],[\"book\",{\"0\":{\"32\":1},\"1\":{\"50\":2}}],[\"both\",{\"1\":{\"23\":1,\"31\":1,\"47\":1,\"50\":3}}],[\"boundary\",{\"1\":{\"60\":1,\"73\":1,\"80\":1}}],[\"bound\",{\"1\":{\"11\":1}}],[\"b\",{\"1\":{\"14\":1,\"45\":10,\"46\":3,\"47\":1}}],[\"belongs\",{\"1\":{\"48\":1}}],[\"below\",{\"1\":{\"48\":1}}],[\"begin\",{\"1\":{\"47\":1}}],[\"before\",{\"1\":{\"40\":2}}],[\"being\",{\"1\":{\"38\":1}}],[\"behavioral\",{\"1\":{\"80\":1}}],[\"behavior\",{\"1\":{\"31\":1,\"70\":2,\"80\":1}}],[\"been\",{\"1\":{\"31\":1,\"39\":5,\"41\":1,\"42\":1,\"49\":1,\"50\":1}}],[\"because\",{\"1\":{\"28\":1,\"39\":1,\"47\":1,\"50\":1}}],[\"become\",{\"1\":{\"28\":1,\"39\":1,\"48\":1,\"50\":1}}],[\"best\",{\"1\":{\"22\":1,\"40\":1,\"47\":1,\"48\":1}}],[\"between\",{\"1\":{\"11\":1,\"22\":1,\"40\":2,\"47\":1,\"48\":1,\"70\":1}}],[\"better\",{\"1\":{\"6\":1,\"18\":1,\"27\":1,\"31\":1}}],[\"be\",{\"1\":{\"6\":1,\"21\":1,\"22\":1,\"30\":1,\"31\":9,\"37\":3,\"38\":1,\"39\":1,\"40\":2,\"41\":2,\"42\":3,\"43\":2,\"44\":1,\"45\":8,\"46\":3,\"47\":5,\"48\":4,\"49\":1,\"50\":12,\"60\":1,\"66\":2,\"69\":1}}],[\"by\",{\"1\":{\"6\":1,\"11\":1,\"18\":2,\"20\":3,\"21\":1,\"22\":1,\"23\":3,\"29\":1,\"40\":1,\"45\":1,\"47\":3,\"48\":1,\"49\":1,\"50\":1,\"64\":1,\"69\":2,\"70\":2,\"80\":1}}],[\"bunch\",{\"1\":{\"50\":1}}],[\"but\",{\"1\":{\"38\":1,\"39\":1,\"47\":2,\"48\":1,\"50\":2}}],[\"building\",{\"1\":{\"31\":1}}],[\"bushi\",{\"1\":{\"3\":1}}],[\"bug\",{\"1\":{\"1\":1}}],[\"blog\",{\"1\":{\"1\":1,\"2\":2}}],[\"很容易就会出现梯度消失的情况\",{\"1\":{\"6\":1}}],[\"很早就有的想法\",{\"1\":{\"2\":1}}],[\"很多新东西从未见过\",{\"1\":{\"1\":1}}],[\"很麻烦\",{\"1\":{\"1\":1}}],[\"刚开始的过程确实很难\",{\"1\":{\"1\":1}}],[\"觉得还是要尝试些新东西\",{\"1\":{\"1\":1}}],[\"但在新环境中可能无法适应\",{\"1\":{\"27\":1}}],[\"但在其基础上进行的后续划分有可能使得性能显著提高\",{\"1\":{\"13\":1}}],[\"但训练集\",{\"1\":{\"11\":1}}],[\"但不能作为调参\",{\"1\":{\"10\":1}}],[\"但还是希望自己未来能成为一个有用之人\",{\"1\":{\"3\":1}}],[\"但还好有dream\",{\"1\":{\"1\":1}}],[\"但同时也是一个理想的完美主义者\",{\"1\":{\"3\":1}}],[\"但痛定思痛\",{\"1\":{\"1\":1}}],[\"但总感觉很难\",{\"1\":{\"1\":1}}],[\"欢迎来到我的博客\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
