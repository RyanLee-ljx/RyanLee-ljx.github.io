const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":94,\"nextId\":94,\"documentIds\":{\"0\":\"1\",\"1\":\"1#写在前面-prologue\",\"2\":\"1#缘由-reason\",\"3\":\"1#我-myself\",\"4\":\"1#指南-navigation\",\"5\":\"2\",\"6\":\"2#基本概念\",\"7\":\"2@0\",\"8\":\"3\",\"9\":\"3#基本概念\",\"10\":\"3#一、绪论\",\"11\":\"3#二、模型评估与选择\",\"12\":\"3#三、线型模型\",\"13\":\"3#四、决策树\",\"14\":\"3#五、神经网络\",\"15\":\"3#六、支持向量机-svm\",\"16\":\"3#七、聚类\",\"17\":\"3#八、降维\",\"18\":\"3@0\",\"19\":\"4\",\"20\":\"5\",\"21\":\"5#heading-2\",\"22\":\"5#heading-3\",\"23\":\"5@0\",\"24\":\"5@1\",\"25\":\"6\",\"26\":\"6#定义-definition\",\"27\":\"6#元胞-cell\",\"28\":\"6#元胞空间-space\",\"29\":\"6#元胞邻居-neighbour\",\"30\":\"6#边界条件-boundary\",\"31\":\"6#元胞规则-rule\",\"32\":\"6#生命游戏-the-game-of-life\",\"33\":\"6#应用-application\",\"34\":\"6@0\",\"35\":\"7\",\"36\":\"7#heading-2\",\"37\":\"7#heading-3\",\"38\":\"7@0\",\"39\":\"7@1\",\"40\":\"8\",\"41\":\"8#heading-2\",\"42\":\"8#heading-3\",\"43\":\"8@0\",\"44\":\"8@1\",\"45\":\"9\",\"46\":\"9#heading-2\",\"47\":\"9#heading-3\",\"48\":\"9@0\",\"49\":\"9@1\",\"50\":\"10\",\"51\":\"10#heading-2\",\"52\":\"10#heading-3\",\"53\":\"10@0\",\"54\":\"10@1\",\"55\":\"11\",\"56\":\"11#概述\",\"57\":\"11#问题描述\",\"58\":\"11#模型设置\",\"59\":\"11#基本设置\",\"60\":\"11#更新规则\",\"61\":\"11#部分代码解释\",\"62\":\"11#参数设置\",\"63\":\"11#参数计算\",\"64\":\"11#结果\",\"65\":\"11@0\",\"66\":\"11@1\",\"67\":\"12\",\"68\":\"12#heading-2\",\"69\":\"12#heading-3\",\"70\":\"12@0\",\"71\":\"12@1\",\"72\":\"14\",\"73\":\"14@0\",\"74\":\"14@1\",\"75\":\"15\",\"76\":\"16\",\"77\":\"17\",\"78\":\"17#大语言模型-foudation-model\",\"79\":\"17#sora-模型对于交通行业影响\",\"80\":\"18\",\"81\":\"19\",\"82\":\"20\",\"83\":\"21\",\"84\":\"22\",\"85\":\"23\",\"86\":\"24\",\"87\":\"25\",\"88\":\"26\",\"89\":\"27\",\"90\":\"28\",\"91\":\"29\",\"92\":\"30\",\"93\":\"31\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,3],\"1\":[1,30],\"2\":[1,21],\"3\":[1,62],\"4\":[1,27],\"5\":[1,1],\"6\":[1,91],\"7\":[null,null,1],\"8\":[1,1],\"9\":[1],\"10\":[2,178],\"11\":[2,130],\"12\":[2,34],\"13\":[2,28],\"14\":[2,50],\"15\":[3,123],\"16\":[2,83],\"17\":[2,26],\"18\":[null,null,1],\"19\":[1],\"20\":[2],\"21\":[2,5],\"22\":[2,5],\"23\":[null,null,1],\"24\":[null,null,1],\"25\":[3,6],\"26\":[1,28],\"27\":[1,12],\"28\":[1,10],\"29\":[1,26],\"30\":[1,17],\"31\":[1,22],\"32\":[1,40],\"33\":[1,63],\"34\":[null,null,1],\"35\":[2],\"36\":[2,5],\"37\":[2,5],\"38\":[null,null,1],\"39\":[null,null,1],\"40\":[1],\"41\":[2,5],\"42\":[2,5],\"43\":[null,null,1],\"44\":[null,null,1],\"45\":[1],\"46\":[2,5],\"47\":[2,5],\"48\":[null,null,1],\"49\":[null,null,1],\"50\":[1],\"51\":[2,5],\"52\":[2,5],\"53\":[null,null,1],\"54\":[null,null,1],\"55\":[3,7],\"56\":[1,78],\"57\":[1,21],\"58\":[1],\"59\":[1,15],\"60\":[1,64],\"61\":[1,3],\"62\":[1,111],\"63\":[1,138],\"64\":[1,6],\"65\":[null,null,1],\"66\":[null,null,1],\"67\":[2],\"68\":[2,5],\"69\":[2,5],\"70\":[null,null,1],\"71\":[null,null,1],\"72\":[2],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[3],\"76\":[4,88],\"77\":[4,2],\"78\":[1,59],\"79\":[2,76],\"80\":[2],\"81\":[2],\"82\":[2],\"83\":[1,3],\"84\":[1],\"85\":[1],\"86\":[1],\"87\":[1],\"88\":[1],\"89\":[1],\"90\":[1],\"91\":[2],\"92\":[2],\"93\":[2]},\"averageFieldLength\":[1.5841572347188548,37.56446911013167,0.4288432526338008],\"storedFields\":{\"0\":{\"h\":\"简介 Introduction\",\"t\":[\"👋 欢迎来到我的博客！\"]},\"1\":{\"h\":\"写在前面\",\"t\":[\"其实很早就萌生过写 blog 的想法，但总感觉很难，很麻烦，不想走出舒适圈，所以迟迟不肯行动。\",\"但痛定思痛，觉得还是要尝试些新东西，所以便有了现在这个页面。\",\"刚开始的过程确实很难，很多新东西从未见过，一时难以消化吸收，过程中还遇到很多莫名其妙的小 bug。\",\"但还好有dream-oyh的帮助，让我顺利解决了很多问题，在此表示十分感谢！💖\",\"目前还是处于入门小白阶段，还有很多排版、布局、内容方面有待优化，我会逐步去完善。\",\"下面来 talk about myself。\"]},\"2\":{\"h\":\"缘由\",\"t\":[\"👐 决定写 blog 原因大致有以下几点：\",\"很早就有的想法（想当一个知识区博主、音乐区 up 主），目前先尝试一个。\",\"准备夏令营过程中，发现自己之前做过的很多小项目、写过的很多代码、学过的知识都记不清了，如果之前有所记录就很便于回忆，而且复习过程中也苦于没有地方整理，blog 就显得非常合适。\",\"周边盆友的影响👬。\",\"走出舒适圈，尝试新的记录生活的方式。\"]},\"3\":{\"h\":\"我\",\"t\":[\"职业： 一名在读 CSUer 🏫，对，就是那个California State University(bushi)。\",\"星座： 水瓶座 \",\"成分： Swiftie 🍓 一枚。\",\"人格： INFJ 绿老头一枚。\",\"爱好： LOL、听歌 🎧、唱歌 🎤、吉他 🎸、足球 ⚽。\",\"自我评价：自我感觉是一个矛盾体，看待问题十分的现实，但同时也是一个理想的完美主义者；绝对的宿命论主义倾向；梦想很多，却也逐渐看清了生活的本质，但还是希望自己未来能成为一个有用之人，探究生命的意义，世界之本质 💭 。\",\"📝 目前小小的愿望清单\",\" 进入到梦中情组\",\" 现场看一场 LOL 比赛(S 赛/MSI/EDG 比赛)\",\" 看一次霉妈的演唱会\",\" 现场看一次球赛（世界杯/国家队比赛/亚冠/欧冠/欧洲杯......）\",\" 冰岛/欧洲游\",\"twin flame who？\",\" 统一\",\" 国足进世界杯\"]},\"4\":{\"h\":\"指南\",\"t\":[\"目前博客内容主要为过去做过的一些项目、小研究、自学内容的整理等，有时间也会加入书评、乐评、随笔等其他内容。\",\"交通 主要记录本专业一些相关内容，如常见模型、算法讲解与实现。\",\"机器学习 主要为自学 ML 笔记及代码。\",\"数模 总结自己参加数模比赛过程中，常见的模型、算法整理。\",\"英语 交通方向的英文文献、交通方面的专业名词、理论知识、前沿技术发展等。\",\"Myself 博主的自我介绍。\",\"❤️ 感谢你看到这里 ❤️\"]},\"5\":{\"h\":\"卷积\",\"t\":[\"本节整理卷积方面基本概念\"]},\"6\":{\"h\":\"基本概念\",\"t\":[\"卷积：卷积就是用一个可移动的窗口（卷积核），按一定步长，与图像对应元素进行点乘相加的操作。卷积本质上也是一种对数据维度的变换，提取图像的特征，相较于全连接层直接把图像展开成一个行向量，其能更好地捕获图像的空间特征，当然通过改变参数的形状，任何全连接层都能被转换为一个等价卷积层。\",\"池化：一种下采样方式，池化层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象。主要有三个功效：\",\"特征不变性：池化操作是模型更加关注是否存在某些特征而不是特征具体的位置。其中不变形性包括，平移不变性、旋转不变性和尺度不变性。平移不变性是指输出结果对输入对小量平移基本保持不变，例如，输入为(1, 5, 3), 最大池化将会取 5，如果将输入右移一位得到(0, 1, 5)，输出的结果仍将为 5。对伸缩的不变形，如果原先的神经元在最大池化操作后输出 5，那么经过伸缩（尺度变换）后，最大池化操作在该神经元上很大概率的输出仍是 5；\",\"特征降维（下采样）：池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。\",\"在一定程度上防止过拟合，更方便优化。\",\"实现非线性（类似 relu）。\",\"扩大感受野。\",\"上采样：放大图像，反卷积/转置卷积。\",\"下采样：缩小图像，如池化与步长为 2 的卷积。\",\"relu 激活函数：负为 0，正 y=x\",\"采用原因： -第一，采用 sigmoid 等函数，算激活函数时（指数运算），**计算量大**，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用 Relu 激活函数，整个过程的计算量节省很多。\",\"-第二，对于深层网络，sigmoid 函数反向传播时，很容易就会出现梯度消失的情况（在 sigmoid 接近饱和区时，变换太缓慢，导数趋于 0，这种情况会造成信息丢失），从而无法完成深层网络的训练。\",\"-第三，ReLu 会使一部分神经元的输出为 0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。\"]},\"7\":{\"c\":[\"ML\"]},\"8\":{\"h\":\"机器学习\",\"t\":[\"本节整理机器学习的基本问题\"]},\"9\":{\"h\":\"基本概念\"},\"10\":{\"h\":\"一、绪论\",\"t\":[\"什么是机器学习和深度学习？ 机器学习是一种实现人工智能的方法。人工智能是想要达成的目标，而机器学习是想要达成目标的手段：希望机器通过学习的手段，可以跟人一样聪明。机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构，使不断改善自身的性能。而深度学习，就是机器学习的其中一种方法。\",\"机器学习流程？ **表示：**将数据对象进行特征(feature)化表示\",\"**训练：**给定一个数据样本集，从中学习出规律（模型），目标：该规律不仅适用于训练数据，也适用于未知数据(称为泛化能力)\",\"**测试：**对于一个新的数据样本，利用学到的模型进行预测\",\"在机器学习中，学习率这种参数叫什么？学习率太大和太小的可能影响？\",\"学习率也叫步长，指更新参数步幅。表征了参数每次更新的幅度. 学习率过大，梯度下降算法不会收敛，会发散或振荡；学习率过小，梯度下降算法收敛很慢。\",\"根据学习方式的划分，机器学习三个主要分类是什么？请简要说明他们之间的关系。 划分为三个主要分类：监督学习、非监督学习、强化学习。关系见下\",\"简述监督学习，非监督学习以及强化学习的定义和区别？ 定义：\",\"（1）监督学习：是一种通过使用已知输出来训练模型的学习方式。在监督学习中，训练数据包括输入数据和对应的输出数据（也称为标签或目标），算法通过学习这些数据，建立输入和输出之间的映射关系，以预测新的输入数据的输出。监督学习通常用于分类（分类器）和回归（回归器）问题。\",\"（2）非监督学习：是一种在没有标签或目标的情况下，从数据中发现模式或结构的学习方式。在非监督学习中，算法只能使用输入数据进行学习，目标是找到输入数据之间的相似性和区别，以便对数据进行聚类、降维、异常检测等操作。\",\"（3）强化学习：又称为再励学习，是指从环境状态到行为映射的学习，使系统行为从环境中获得的累积奖励值最大的一种机器学习方法。\",\"区别：\",\"（1）监督学习有反馈，无监督学习无反馈，强化学习执行多步后反馈；\",\"（2）强化学习的目标与监督学习目标不同，强化学习看重行为序列下的长期收益，监督学习关注与标签或已知输出的误差；\",\"（3）强化学习的奖惩概念没有正确和错误之分，而监督学习的标签是正确的。 强化学习是一个学习+决策的过程，有和环境交互的能力，监督学习不具备。\",\"简要说明监督学习和非监督学习之间的区别，并分别给出监督和非监督学习的两种算法。\",\"区别\",\"监督学习和非监督学习是机器学习中两种不同的学习方式。监督学习需要已知的输入和输出数据，目标是学习输入 和输出之间的映射关系。非监督学习只需要输入数据，目标是从数据中发现模式和结构，而不需要预先定义的目标 变量。在实际应用中，监督学习和非监督学习常常结合使用，以提高机器学习的效果和性能。\",\"举例\",\"常见的监督学习算法包括线性回归、逻辑回归、决策树、支持向量机、朴素贝叶斯、神经网络等。\",\"常见的非监督学习算法包括聚类、主成分分析（PCA）、独立成分分析（ICA）、自编码器、变分自编码器等。\",\"训练集、测试集、验证集区别联系？\",\"训练集:用于模型拟合的数据样本,即用于训练的样本集合,主要用来训练神经网络中的参数;\",\"验证集：模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估;\",\"测试集：用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。 各数据集的作用\",\"训练集的作用\",\"拟合模型，调整网络权重。\",\"验证集的作用\",\"作用 1：快速调参，也就是通过验证集我们可以选择超参数（网络层数、网络节点数、迭代次数 epoch、学习率 learning rate、优化器）等。\",\"作用 2：选择超参数，为了让我们的模型在测试集表现得更好，调参是不可避免地一部分，如果把测试集当验证集，调参去拟合测试集合，是不可行地，这相当于作弊。\",\"作用 3：监控模型是否正常\",\"验证集的重要性\",\"如果没有设置验证集，我们通常得等到测试集才可以知道我们模型真正得实力，然后再来调整参数，这样子时间代价较高，通过验证集我们可以训练几个 epoch 后查看模型的训练效果及我们的网络是否出现异常，然后决定怎么调整我们的超参数。\",\"测试集的作用\",\"仅仅用来评估模最终模型的泛化能力，确认网络的实际预测能力。\",\"什么是泛化性能？ 是指机器学习算法对新鲜样本的适应能力。 学习的目的是学到隐含在数据背后的规律，对具有同一规律的学习集以外的数据，经过训练的网络也能给出合适的输出，该能力称为泛化能力。\",\"在数据处理时，为什么通常要进行标准化处理 在实际问题中，我们使用的样本通常是多维数据，每一维对应一个特征，这些特征的量纲和数量级都是不一样的 这时需要对数据进行标准化处理，使得所有的特征具有同样的尺度。\"]},\"11\":{\"h\":\"二、模型评估与选择\",\"t\":[\"过拟合、欠拟合定义、原因、解决办法？\",\"（1）定义：\",\"过拟合：学习器把训练样本学习的“太好”，将训练样本本身的特点当做所有（潜在）样本（都会具有）的一般性质，导致泛化性能下降。\",\"欠拟合：训练样本的一般性质尚未学好，在训练样本上都存在较大的经验误差。\",\"（2）原因：\",\"过拟合原因： 1）模型复杂度过低 2）特征量过少 3）训练样本过少\",\"欠拟合原因： 1）训练集的数量级 N 与模型复杂度 M 不匹配 2）训练集与测试集的特征分布不一致 3）样本噪声过多，模型过分记住了噪声，忽略了真实的输入输出 4）权值学习迭代次数过多，拟合了不具代表性的特征\",\"（3）解决办法：\",\"过拟合: 1）清洗数据 2）减小模型复杂度 3）增广训练集 4）交叉验证 5）正则化，约束模型特征 6）early stopping 迭代次数截断 7）dropout，让一些神经元以一定的概率不工作.\",\"欠拟合应对： 1）增加新特征 2）增加模型复杂度，如决策树的扩展分支，神经网络的训练轮数等 3）扩大训练集。\",\"错误率及误差概念？\",\"错误率 & 误差：\",\"（1）错误率：错分样本的占比\",\"（2）误差：样本真实输出与预测输出之间的差异\",\"（3）训练(经验)误差： 训练集上\",\"（4）测试误差： 测试集上\",\"（5）泛化误差： 除训练集外所有样本\",\"评估方法\",\"留出法、交叉验证法（k=m 时是留一法）、自助法等。\",\"交叉验证法和自助法异同？\",\"相同点\",\"交叉验证法和自助法都是随机采样法。它们作为人工智能中评估模型的方法，根据一定规则从数据集 D 中划分训练集和测试（验证）集，从而评价模型在数据集上的表现，便于我们选择合适的模型。\",\"不同点\",\"这两种方法最大的不同点在于每次划分过程中每个样本点是否只有一次被划入训练集或测试集的机会。下面将针对这方面详细展开论述：\",\"交叉验证法采用的是无放回的随机采样方式，这种方式可以保持数据分布的一致性条件，并严格划分训练集与测试集的界限，从而增强测试评估的稳定性和可靠性。\",\"自助法主要面向数据集同规模的划分问题。其采用的是有放回的随机抽样方法，可以使得得到的模型更为稳健，解决了交叉验证法中模型选择阶段和最终模型训练阶段的训练集规模差异问题；但训练集 T 和原始数据集 D 中数据的分布未必相一致，因此对一些对数据分布敏感的模型选择并不适用。\",\"偏差、方差、噪声含义？\",\"偏差度量了学习算法期望预测与真实结果的偏离程度: 即刻画了学习法本身的拟合能力;\",\"方差度量了同样大小训练集的变动所导致的学习性能的变化: 即刻画了数据扰动所造成的影响;\",\"噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界即刻画了学习问题本身的难度。\",\"偏差-方差分解角度解释泛化性能 泛化性能是出学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。给定学习任务为了取得好的泛化性能，需要使偏差小(充分拟合数据)而且方差较小(减少数据扰动产生的影响)。\",\"偏差方差冲突 PPT P9\",\"8．请给出你对泛化误差的理解\",\"泛化误差 = 偏差+方差+噪声\",\"偏差：度量了学习算法的期望预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力\",\"方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响\",\"噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度\"]},\"12\":{\"h\":\"三、线型模型\",\"t\":[\"线型模型优势与不足？ 优势：第三章 3.1.2 P1 不足： 第三章 3.2.7 P10\",\"什么是回归（分析）？ 第三章 3.2 P2\",\"简述 LDA 算法的基本思想及算法流程。\",\"基本思想是将高维的模式样本投影到最佳鉴别矢量空间，以达到抽取分类信息和压缩特征空间维数的效果，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离,即模式在该空间中有最佳的可分离性。 流程：\",\"逻辑回归和线性回归的异同\",\"不同之处：\",\"（1）逻辑回归解决的是分类问题，因此因变量是离散的；而线性回归解决的是回归问题，因此因变量是连续的。这是两者最本质的区别；\",\"（2）在自变量和超参数确定的情况下逻辑回归可看作广义的线性模型在因变量下服从二元分布的一个特殊情况\",\"（3）使用最小二乘法求解线性回归时我们认为因变量服从正态分布。\",\"相同之处：\",\"（1）二者在求解超参数的过程中都使用梯度下降的方法 ；\",\"（2）二者都使用了极大似然估计对训练样本进行建模。\"]},\"13\":{\"h\":\"四、决策树\",\"t\":[\"决策树三种导致递归返回的情况\",\"PPT 第四章 4.1 P1\",\"决策树中剪枝方式分为哪两种？请简述这两种方式的优缺点？\",\"预剪枝和后剪枝。\",\"预剪枝\",\"优点：降低过拟合风险，显著降低训练时间和测试时间的开销。\",\"缺点：有些分支当前划分虽然不能提升泛化性能，但在其基础上进行的后续划分有可能使得性能显著提高，预剪枝基于“贪心”，禁止这些分支展开，有欠拟合风险。\",\"后剪枝\",\"优点：比预剪枝保留了更多分支，欠拟合风险小，泛化性能更好。\",\"缺点：训练时间开销大，后剪枝过程是在生成完全的决策树之后，自底向上对所有非叶节点逐一考察。\"]},\"14\":{\"h\":\"五、神经网络\",\"t\":[\"在神经网络中，非线性激活函数的主要作用是什么？请给出常用的几种非线性激活函数及其导数；\",\"激活函数可以加入非线性因素，解决线性模型所不能解决的问题。激活函数是神经网络的一个重要组成部分。如果不使用激活函数，则无论该神经网络有多少层，最终的输出都是输入的线性组合，与没有隐藏层的效果相当，这种情况就是最原始的感知机，无法解决线性不可分问题。\",\"神经网络分类\",\"神经网络根据是否存在网络回路（联接方式），可以分为：前向型和反馈型。 按学习方式：有导师的学习（监督学习）、无导师的学习（无监督学习）、再励学习（强化学习），具体解释： PPT 第五章 P6-7\",\"神经网络与人脑相比计算特能力特点： PPT 第五章 P5\",\"简述神经网络的学习过程 PPT 第五章 P5\",\"简要介绍卷积概念及其作用、池化的作用是什么？卷积前后图像尺寸之间的关系是什么？\",\"简述神经网络中梯度下降方法的原理和作用（作用请从机器学习训练阶段的三个步骤的角度来阐述）。 梯度下降方法的原理：梯度下降方法通过求出损失函数在某点对于参数 θ 的微分值，并以负梯度方向为搜索方向，沿着梯度下降的方向求解极小值；作用是在训练阶段的第三个步骤中，通过梯度下降来寻找更优的学习参数 b 和 w，达到优化模型的效果。\"]},\"15\":{\"h\":\"六、支持向量机 SVM\",\"t\":[\"试述硬间隔、软间隔、基于核函数的 SVM 的原理、优缺点、三者最终计算方式以及限制条件。 硬间隔 SVM：\",\"原理：硬间隔 SVM 假设数据本身是线性可分的，即存在一个超平面可以将不同类别的样本完全分开。这个超平面需要满足离其最近的点到其的距离最大化。\",\"优点：简单明了，适用于线性可分的数据集。\",\"缺点：对于非线性可分的数据集，硬间隔 SVM 无法找到一个有效的超平面。此外，硬间隔 SVM 对异常点非常敏感，因为异常点可能导致无法找到一个满足所有约束条件的超平面。\",\"软间隔 SVM：\",\"原理：软间隔 SVM 放松了对数据线性可分的假设，允许在某些情况下出现分类错误。软间隔 SVM 通过引入松弛变量来处理噪声和异常点。通过调整这些变量，可以控制对分类错误的容忍程度。\",\"优点：能够处理非线性可分的数据集和噪声数据。\",\"缺点：需要调整松弛变量和惩罚参数，以找到最佳的分类效果。\",\"基于核函数的 SVM：\",\"原理：对于非线性可分的数据集，基于核函数的 SVM 通过使用核函数将输入空间映射到高维特征空间，使得在高维特征空间中数据变得线性可分。常用的核函数有线性核、多项式核和 RBF 核（高斯核）。\",\"优点：能够处理非线性可分的数据集。\",\"缺点：选择合适的核函数和参数是一个挑战，同时计算复杂度可能会较高。\",\"SVM 与 logistic 回归区别联系\",\"相同点:\",\"都是分类算法 如果不考虑核函数，LR 和 SVM 都是线性分类算法 LR 和 SVM 都是监督学习算法。 LR 和 SVM 都是判别模型.\",\"不同点:\",\"本质上是其 loss function 不同 支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局. 在解决非线性问题时，支持向量机采用核函数的机制，而 LR 通常不采用核函数的方法 线性 SVM 依赖数据表达的距离测度，所以需要对数据先做 normalization，LR 不受其影响。 SVM 的损失函数就自带正则。\",\"SVM、logistic 回归、决策树各自优缺点\",\"逻辑回归\",\"逻辑回归的优点：\",\"（1）便利的观测样本概率分数；\",\"（2）已有工具的高效实现；\",\"（3）对逻辑回归而言，多重共线性并不是问题，它可以结合 L2 正则化来解决；\",\"（4）逻辑回归广泛的应用于工业问题上（这一点很重要）。\",\"逻辑回归的缺点： （1）当特征空间很大时，逻辑回归的性能不是很好；\",\"（2）不能很好地处理大量多类特征或变量；\",\"（3）对于非线性特征，需要进行转换；\",\"（4）依赖于全部的数据（个人觉得这并不是一个很严重的缺点）。\",\"决策树\",\"（1）直观的决策规则\",\"（2）可以处理非线性特征\",\"（3）考虑了变量之间的相互作用\",\"（4）训练集上的效果高度优于测试集，即过拟合[随机森林克服了此缺点\",\"（5）没有将排名分数作为直接结果\",\"SVM\",\"SVM 的优点：\",\"（1）能够处理大型特征空间\",\"（2）能够处理非线性特征之间的相互作用\",\"（3）无需依赖整个数据\",\"SVM 的缺点：\",\"（1）当观测样本很多时，效率并不是很高\",\"（2）有时候很难找到一个合适的核函数\",\"为什么要引入对偶问题? （1）对偶问题将原始问题中的约束转为了对偶问题中的等式约束。\",\"（2）改变了问题的复杂度。由求特征向量转化为求比例系数。在原始问题下，求解的复杂度与样本的维度有关即 w 的维度。在对偶问题下，求解的是 a，复杂度只与样本数量有关。\",\"（3）可以自然地引入核函数，从而推广到非线性分类问题\"]},\"16\":{\"h\":\"七、聚类\",\"t\":[\"聚类方法分类？\",\"无监督学习方法主要有两大类：基于概率密度函数的估计方法和基于样本间相似性度量的间接聚类方法。\",\"K-means、层次聚类、DBSCAN 聚类方法原理、区别、优缺点\",\"K-means 聚类\",\"工作原理： K-means 算法将数据划分为 K 个簇，每个簇包含最接近其质心的数据点。它通过迭代地将数据点分配给最近的质心并更新质心来执行聚类。\",\"优点： 简单且高效，适用于大型数据集。它的结果易于解释和可视化。\",\"缺点：需要事先指定簇数 K。对于非球形簇或具有不同密度的簇效果较差。\",\"层次聚类\",\"工作原理： 层次聚类将数据集逐渐分割或合并成不同的层次簇。它可以是自底向上的聚合聚类（凝聚型）或自顶向下的分裂聚类（分裂型）。\",\"优点： 不需要预先指定簇数，可视化结果以树状结构呈现，对不同形状的簇和噪声具有较好的鲁棒性。\",\"缺点：不具有很好的可伸缩性: 时间复杂性至少是 0(n^2)，其中 n 对象总数。合并或分裂的决定需要检查和估算大量的对象或簇。不能撤消已做的处理，聚类之间不能交换对象。如果某一步没有很好地选择合并或分裂的决定，可能会导致低质量的聚类结果\",\"DBSCAN（密度聚类）\",\"工作原理： DBSCAN 根据数据点的密度将它们分为核心点、边界点和噪声点。核心点是在指定半径范围内有足够多邻居的点，它们被用于扩展簇。\",\"优点： 可以对任意形状的稠密数据集进行聚类。可以在聚类的同时发现异常点，对数据集异常点不敏感。聚类结果没有偏倚。\",\"缺点： 对参数的选择敏感，可能需要调整半径参数和最小邻居数。对高维数据和不均匀密度数据的处理相对困难。样本集较大时，聚类收敛时间较长。\",\"区别：\",\"（1）簇数的预先指定： K-means 需要提前指定簇数 K，而层次聚类和 DBSCAN 不需要。层次聚类会生成层次结构，可以根据需要切割簇。DBSCAN 通过密度自动确定簇的数量。\",\"（2）对簇形状和密度的适应性： K-means 假定簇是球形且密度均匀，不适合不规则形状和不同密度的簇。层次聚类和 DBSCAN 能够发现各种形状和密度的簇。\",\"（3）计算复杂度： K-means 通常是最快的，DBSCAN 次之，而层次聚类较慢，特别是在大型数据集上。\",\"（4）噪声处理： DBSCAN 在处理噪声点时比较鲁棒，可以将它们识别为噪声。K-means 和层次聚类通常需要额外的后处理步骤来处理噪声点。\"]},\"17\":{\"h\":\"八、降维\",\"t\":[\"请简要说明主成分分析（PCA）和线性判别分析（LDA）之间的区别和联系\",\"相同点：\",\"（1）两者均可以对数据进行降维。\",\"（2）两者在降维时均使用了矩阵特征分解的思想。\",\"（3）两者都假设数据符合高斯分布。\",\"不同点：\",\"（1）LDA 是有监督的降维方法，而 PCA 是无监督的降维方法\",\"（2）LDA 降维最多降到类别数 k-1 的维数，而 PCA 没有这个限制。\",\"（3）LDA 除了可以用于降维，还可以用于分类。\",\"（4）LDA 选择分类性能最好的投影方向，而 PCA 选择样本点投影具有最大方差的方向。\"]},\"18\":{\"c\":[\"ML\"]},\"19\":{\"h\":\"数学建模\"},\"20\":{\"h\":\"A*算法\"},\"21\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"22\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"23\":{\"c\":[\"交通\"]},\"24\":{\"c\":[\"traffic\"]},\"25\":{\"h\":\"元胞自动机 Cellular Automata\",\"t\":[\"本节简单介绍一下元胞自动机模型，包括其定义、基本概念、应用等方面，具体讲解可以看这篇文章与这篇文章。\"]},\"26\":{\"h\":\"定义\",\"t\":[\"元胞自动机（Cellular Automata, CA）是自动机理论（Theory of automata）中的一种离散计算模型，最初由Stanislaw Ulam和John von Neumann 于 20 世纪 40 年代在洛斯阿拉莫斯国家实验室同时提出[1]。一个完整的元胞自动机模型包含 元胞、元胞空间、元胞邻居、元胞边界、元胞规则 五大部分，下面将分别做进一步阐述。\"]},\"27\":{\"h\":\"元胞\",\"t\":[\"元胞是 CA 模型的基本单元，是模型迭代的直接参与者，从概念上就可以理解元胞就好似生物体的细胞。每一个元胞都有一个状态,一般为二维（如 0-1），复杂情况下也有多维。\"]},\"28\":{\"h\":\"元胞空间\",\"t\":[\"元胞空间为空间内元胞的集合，即按一定方式对空间划分，元胞呈一定形状。元胞空间划分方式大致有 正方形（类似栅格化）、三角形、正六边形 等类型。\"]},\"29\":{\"h\":\"元胞邻居\",\"t\":[\"元胞邻居是某一元胞周围的元胞，是否为邻居，取决于元胞状态更新时所要搜索的空间域，在二维空间下，最常用的邻居类型是 Moore 型和 Von Neumann 型，如图一所示：\",\"图1 元胞类型\",\"Moore 邻居定义为下式：\",\"NM​(x0​,y0​)={(x,y):∣x−x0​∣<=r,∣y−y0​∣<=r}\",\"Von Neumann 邻居定义为：\",\"NV​(x0​,y0​)={(x,y):∣x−x0​∣+∣y−y0​∣<=r}\"]},\"30\":{\"h\":\"边界条件\",\"t\":[\"边界条件是元胞空间外的部分，是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞。常用的邻居边界条件类型有：固定型，周期型，绝热型和映射型这四种，常用为固定型和周期型。\",\"注\",\"固定型：在外围补上固定不变的、虚拟的元胞。\",\"周期型：每个维度的第一个元胞与最后一个元胞互为边界。\",\"绝热型：边界元胞与自己相同。\",\"映射型：边界元胞为元胞每个维度内侧邻近元胞。 一般常用为固定型和周期型边界条件。\"]},\"31\":{\"h\":\"元胞规则\",\"t\":[\"元胞规则即每次迭代，每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态，每个元胞按照该规则进行状态更新，相互作用，由局部到整体，从而引起全局的变化。元胞规则是整个 CA 模型最为关键的部分。\",\"相关信息\",\"元胞自动机更新规则特征[2]：\",\"离散型：空间、时间及状态都是离散的;\",\"同质性：服从相同的规律分布方式相同；\",\"并行性：元胞的状态更新规则变化是同步进行的；\",\"高维度：元胞自动机是一类无穷维动力系统。\"]},\"32\":{\"h\":\"生命游戏\",\"t\":[\"生命游戏是最著名的二维元胞自动机生命游戏，由John Conway于 1970 年设计。它由二维元胞网格组成，其状态可能是死亡 (0) 或活着 (1)。该游戏采用标准 Moore 邻居，其元胞规则为：\",\"对于“活着”的格子，若它的 8 个 Moore 邻居中有 2-3 个为“活着”，则该格继续保持“活着”，否则就变为“死亡”。 对于“死亡”的格子，若它的 8 个邻居中有 3 个“生”，则该格变为“生”，否则继续保持“死”。\",\"用函数表示如下：\",\"vt+1(α)=⎩⎨⎧​0,νt(α),1,​S<2∨S>3S=2S=3​\",\"图2 生命游戏\"]},\"33\":{\"h\":\"应用\",\"t\":[\"元胞自动机的应用大致有以下几类：\",\"作为物理、化学、生物过程的基础模型\",\"计算单元\",\"模拟现实复杂动态系统\",\"英文总结\",\"Cellular automaton is a discrete computing model in the Theory of automata. A complete cellular automaton model includes five parts: cell, cell space, cell neighbor, cell boundary, and cell rules. Each cell has a state which can be 0 or 1, alive or dead. Each cell follows a set of rules and updates the state at every time step based on the current state and their neighbors' state, thereby triggering global changes. It has many applications in computing and simulation.\"]},\"34\":{\"c\":[\"交通\"]},\"35\":{\"h\":\"改进A*算法\"},\"36\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"37\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"38\":{\"c\":[\"交通\"]},\"39\":{\"c\":[\"traffic\"]},\"40\":{\"h\":\"迪杰斯特拉算法\"},\"41\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"42\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"43\":{\"c\":[\"交通\"]},\"44\":{\"c\":[\"traffic\"]},\"45\":{\"h\":\"佛洛依德算法\"},\"46\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"47\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"48\":{\"c\":[\"交通\"]},\"49\":{\"c\":[\"traffic\"]},\"50\":{\"h\":\"NS模型\"},\"51\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"52\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"53\":{\"c\":[\"交通\"]},\"54\":{\"c\":[\"traffic\"]},\"55\":{\"h\":\"行人流仿真 Pedestrian Simulation\",\"t\":[\"本文探讨基于 CA 模型的行人流仿真，如果你还不了解 CA 模型，请先移步这篇文章。\"]},\"56\":{\"h\":\"概述\",\"t\":[\"行人流仿真是通过模拟人群在不同环境下的移动，研究行人行为及心理的特点的研究，其在城市规划、交通管理、疏散计划、建筑平面设计等方面有着广泛的应用。\",\"Pedestrian simulation studies pedestrians' behavioral patterns and psychological aspects by modeling and simulating the movement of crowds in various scnarios. It finds extensive applications in urban planning, traffic management, evacuation planning, and architectural layout design.\",\"分类\",\"行人流仿真按仿真规模可以大致分为三种，即 宏观(macroscopic) 、 微观(microscopic) 、介于宏微观之间(mesoscopic) 这三种。\",\"宏观：以整个人群为研究对象，研究整体移动特征如速度、密度、流向等，每个个体没有行为特征，最为常见方法为流体动力学模型(fluid dynamic model)。\",\"微观：以个体为研究对象，研究个体行为，每个个体有着独特的行为特征，常见模型是社会力模型（social force model）。\",\"介观：介于宏微观之间，人群中每个个体有着相同的行为特征，既研究整体特征也研究个体特征，常见是元胞自动机模型（cellular automata, CA）。\",\"⏩ 不同方法并非只适用于一个规模，如 CA 模型也可以在微观层面研究。此外，其他方法还有网络模型、自然模型、格子气模型以及基于机器学习的模型等，对行人流仿真进一步了解可以移步此篇论文\"]},\"57\":{\"h\":\"问题描述\",\"t\":[\"模拟行人穿过以平台\",\"相关信息\",\"平台基本信息：\",\"平台 16×30，左三个入口，大小分别为 1×1,1×4,1×1，右四个出口，均为 1×1，中间设有障碍，行人不得通过障碍。\",\"行人每秒走一格，每个行人占一格。\",\"行人随机从各个入口进入。\",\"规定仿真时间为 960s\",\"图1 平面示意图 \"]},\"58\":{\"h\":\"模型设置\"},\"59\":{\"h\":\"基本设置\",\"t\":[\"元胞：状态设置为占有（0）与不占有（1）\",\"元胞空间：划分为方格形。\",\"元胞邻居：采用基本 Moore 型（r=1）\",\"边界条件：采用固定型。\"]},\"60\":{\"h\":\"更新规则\",\"t\":[\"更新规则即行人如何选择下一步走到哪里一个方格，这里引入元胞潜能，其定义如下：\",\"Ni,j​=Ei,j​exp(kS​Si,j​+kD​Di,j​)\",\"其中，Ei,j​ 代表位置(i, j)处元胞状态，0 代表占有，1 代表不占有，Ni,j​ 代表位置(i, j)处的元胞潜能，可以发现，当元胞占有时 Ei,j​=0 ，即该处元胞潜能为 0，反应了元胞有人占据，就无法选择。Si,j​ 为元胞静态势能，Di,j​ 为元胞动态势能， kS​ 和 kD​ 分别为对应系数。\",\"元胞静态势能反应了行人在选择下一步时，环境中静止物体的影响，这里主要考虑为出口与障碍物，定义为：\",\"Si,j​=kL​Li,j​+kO​Oi,j​\",\"其中，Li,j​ 为位置为(i, j)的元胞距出口的距离，Oi,j​ 为位置为(i, j)的元胞周边的非障碍数目。\",\"元胞动态势能反应行人在选择下一步时，环境的动态影响，这里以位置为(i, j)的元胞周围空元胞数目 Di,j​ 为指标。\",\"所以最后，元胞潜能可以写为：\",\"Ni,j​=Ei,j​exp(k1​Li,j​+k2​Oi,j​+k3​Di,j​)\",\"最后对 9 个位置进行标号、对元胞潜能进行归一化，即可得到选择 9 个位置的选择概率 Pi,j​。\",\"图2 Moore邻居选择示意图\"]},\"61\":{\"h\":\"部分代码解释\",\"t\":[\"代码整体思路如下：\",\"图3 代码流程图\"]},\"62\":{\"h\":\"参数设置\",\"t\":[\"clc,clear format short; n=16; %平台宽度 h=30; %平台长度 star_x = ones(1,6); % 入口横坐标 star_y = [4,7:10,13]; % 入口纵坐标 hurdle_x = repelem(14:16,2); % 障碍 hurdle_x = cat(2,hurdle_x,[20 20]); hurdle_y = repmat(8:9,1,3); hurdle_y = cat(2,hurdle_y,[5 12]); final_x = ones(1,4)\\\\*h; % 出口 final_y = [3,6,11,14]; x=n+2; % 边界矩阵宽 y=h+2; % 边界矩阵长 platform=ones(n,h); %初始化平台 obstacle_map=ones(n+4,h+4); %设置非障碍矩阵 obstacle_map(1:2,:)=0; obstacle_map(end-1:end,:)=0; obstacle_map(:,1:2)=0; obstacle_map(:,end-1:end); border=ones(x,y); %边界矩阵 border(1,:)=0; border(end,:)=0; border(:,1)=0; border(:,end)=0; Sm=ones(n+4,h+4); % 图 Sm(1:2,:)=0; Sm(end-1:end,:)=0; Sm(:,1:2)=0; Sm(:,end-1:end); for i = 1:size(hurdle_y,2) Sm(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 obstacle_map(hurdle_y(i)+2,hurdle_x(i)+2)=0; %设置障碍 end step=1; %初始迭代次数 po=1:1:9; %位置矩阵 pp = zeros(1,9); neigh = [-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1]; L=zeros(n,h,size(final_y,2)); % 不含边界距离矩阵 N=zeros(n+2,h+2,size(final_y,2)); % 元胞潜力 N_choose=zeros(n+2,h+2); % 最终选择 P=zeros(n+2,h+2); %预留内存 prob=zeros(1,9); %概率矩阵、预留内存 go=0; % 出发人数 arrive=0; % 到达终点人数 total=960; % 迭代时间 time_people_star = zeros(n,h,total); % 记录时刻平台信息 \",\"这里设置了 4 个 map：\",\"platform：反应平台实时状态\",\"border：在 platform 外加了一圈障碍，表示边界条件。\",\"Sm 与 obstacle：在 platform 外加了两圈障碍，分别用计算 $ O*{i, j} $ 与 $ D_{i, j} $。\"]},\"63\":{\"h\":\"参数计算\",\"t\":[\"Li,j​ 的计算：\",\"Dis = zeros(n+2,h+2,size(final_y,2)); Dis = Dis + inf; % 分别计算边界内每个原胞到出口的距离 for f=1:size(final_y,2) for i=1:n for j=1:h L(i,j,f)=sqrt((i-final_y(f))^2+(j-final_x(f))^2); %不含边界的距离矩阵 Lij end end end Dis(2:n+1,2:h+1,:)=L; for i = 1:size(hurdle_y,2) Dis(hurdle_y(i)+1,hurdle_x(i)+1,:)=inf; %障碍视为距离无穷 end \",\"Oi,j​ 与 Di,j​ 的计算：\",\"O=obstacle_map(1:x,2:y+1)+obstacle_map(3:x+2,2:y+1)+obstacle_map(2:x+1,1:y)+obstacle_map(2:x+1,3:y+2)+obstacle_map(1:x,1:y)+obstacle_map(3:x+2,1:y)+obstacle_map(1:x,3:y+2)+obstacle_map(3:x+2,3:y+2); D=Sm(1:x,2:y+1)+Sm(3:x+2,2:y+1)+Sm(2:x+1,1:y)+Sm(2:x+1,3:y+2)+Sm(1:x,1:y)+Sm(3:x+2,1:y)+Sm(1:x,3:y+2)+Sm(3:x+2,3:y+2); \",\"这段代码思想为用一个 n-2×n-2 大小的滑动窗口在 n×n 的平台上，依次从需要计算的 8 个周边位置滑动，最后得到所求，可以自己手动画一个图验证一下。\",\"计算元胞潜力：\",\"% 计算原胞潜力 N for f = 1:size(final_y,2) for i=1:x for j=1:y N(i,j,f)=border(i,j)*exp(-5*Dis(i,j,f)+D(i,j)+O(i,j)); end end end for i = 1:size(final_y,2) N(final_y(i)+1,final_x(i)+1)=1e10; % 设置出口原胞潜力为 1e10，可视为无穷大 end N_1 = max(N(:,:,1),N(:,:,2)); %最大作为原胞潜力 N N_2 = max(N(:,:,3),N(:,:,4)); N_choose = max(N_1,N_2); \",\"这里因为有四个入口，所以需要分别计算四个出口的元胞潜力大小，最后取最大。\",\"位置更新：\",\"for j=h+1:-1:2 for i=2:n+1 if(border(i,j)==0) %如果位置（即原胞）有人，计算所有邻居原胞的原胞潜力N % 计算位置1到9各原胞潜力大小，并进行归一化处理 for xy = po pp(1,xy) = N_choose(i+neigh(xy,2),j+neigh(xy,1)); end prob = pp/sum(pp); if sum([pp(2),pp(3),pp(6),pp(8),pp(9)]~=0) % 上下前三个方向不全都有人 S=randsrc(1,1,[po;prob]); %依原胞潜力N，选择下一位置，即进行位置更新 else S = 5; end k = i + neigh(S,2); t = j + neigh(S,1); if platform(k-1,t-1)==0 % 选择新位置已占，则选回原位置 S = 5; k = i + neigh(S,2); t = j + neigh(S,1); end platform(i-1,j-1)=1; % 位置更新，原来原胞更新为空状态 platform(k-1,t-1)=0; % 位置更新，新选择原胞更新为占有状态 end end end \",\"这里用 border 矩阵进行计算，然后在 platform 上进行更新，最后把再 border = platform ，从而实现每一次迭代的整体更新。此外，代码设定，如果上下和前面三个位置共 5 个位置没有人的话才进行选择，否则就待在原地，贴近现实中人是向前走的；如果选择的位置被占，则待在原地。代码从离平台近的位置向远处开始遍历，反应人流变化的方向与源头。\"]},\"64\":{\"h\":\"结果\",\"t\":[\"图4 动态演示\",\"图5 热力图（迭代周期960s）\",\"完整代码\"]},\"65\":{\"c\":[\"交通\"]},\"66\":{\"c\":[\"traffic\"]},\"67\":{\"h\":\"0-1规划模型最短路\"},\"68\":{\"h\":\"Heading 2\",\"t\":[\"Here is the content.\"]},\"69\":{\"h\":\"Heading 3\",\"t\":[\"Here is the content.\"]},\"70\":{\"c\":[\"交通\"]},\"71\":{\"c\":[\"traffic\"]},\"72\":{\"h\":\"增长系数法 GUI\"},\"73\":{\"c\":[\"交通\"]},\"74\":{\"c\":[\"traffic\"]},\"75\":{\"h\":\"Paper Reading 文献导读\"},\"76\":{\"h\":\"交通术语 Terminology of Traffic\",\"t\":[\"Distinguish\",\"traffic: refers to the movement of vehicles and pedestrians on roadways, and is often associated with the analysis of flow and congestion. It’s about the operational aspect of vehicles moving on the road and the interactions that occur.\",\"transport: is a broader term that can refer to the movement of people or goods by any means, including road, rail, air, or water. It encompasses the vehicles and systems involved in such movement.\",\"transportation: is similar to transport but is often used in a more formal context to describe the entire system or infrastructure that supports the movement of people and goods. It’s the overarching concept that includes all aspects of transport systems, policies, and regulations.\",\"transit:specifically, refers to the public transportation systems designed for moving people within or between urban areas, such as buses, subways, and light rail systems. It’s a subset of transportation focused on public modes of transport.\",\"traffic planning scheme: 交通规划方案\"]},\"77\":{\"h\":\"Cutting-edge Technology 前沿科技\",\"t\":[\"本文不定期更新前沿科技简介及对交通领域发展影响.\"]},\"78\":{\"h\":\"\",\"t\":[\"大语言模型是利用深度学习技术，如预训练、微调、Transformer 架构等，通过海量多样化数据训练，得到的具有 数以亿计参数的，具有学习、理解、适应能力的，能够处理多任务如自然语言处理、计算机视觉、语音识别等任务的机器学习模型。\",\"Foudation models are machine learning models, trained on massive and diverse datasets using deep learning techniques such as pre-training, fine-tuning, and Transformer architectures, which possess billions of parameters. These models are capable of learning, understanding, and adapting, enabling them to handle various tasks, including natural language processing, computer vision, and speech recognition.\",\"!Foudation Model\"]},\"79\":{\"h\":\"Sora 模型对于交通行业影响\",\"t\":[\"Sora结合了GPT技术，能够理解和生成高质量的文本提示（prompts），这些提示用于指导视频内容的生成。\",\"Sora integrates GPT, enabling it to understand and produce high-quality text prompts that guide the creation of videos.\",\"1.对于自动驾驶\",\"提供高质量的真实数据用于训练与模拟 Provide high-quality datasets including real scnarios for training and simulating.\",\"提供新的开发算法思路、帮助开发更为智能的决策方案（自动驾驶系统所需具良好的泛化能力，在复杂环境中做出快速决策的，目前的系统往往在特定场景下表现良好，但在新环境中可能无法适应。Sora生成的视频可以模拟各种决策场景，以帮助开发更为智能的决策制定算法。）Offer more adaptive algorithms to better handle the complex issues in real-world scenarios.\",\"提供虚拟测试的平台 Offer platforms for virtual test\",\"2.对交通规划\",\"交通规划模拟与分析（通过生成不同交通规划方案，模拟拟不同的交通规划方案，帮助规划者评估其对交通流量、拥堵和行人安全的影响。通过模拟特定时间段的交通流，Sora可以帮助预测和分析交通模式，为交通规划提供数据支持）\",\"提供应急响应与安全管理案例（在应急响应规划中，Sora可以用来模拟自然灾害、事故等紧急情况下的交通状况，帮助制定有效的应急响应策略。通过模拟不同紧急情况下的交通流动，Sora有助于提高交通管理系统的准备性和响应能力）\\n*Generating videos of traffic fomular\"]},\"80\":{\"h\":\"Traffic Engineering\"},\"81\":{\"h\":\"Transportation Engineering\"},\"82\":{\"h\":\"Traffic Theory\"},\"83\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"84\":{\"h\":\"ML\"},\"85\":{\"h\":\"Shumo\"},\"86\":{\"h\":\"Traffic\"},\"87\":{\"h\":\"Paper\"},\"88\":{\"h\":\"English\"},\"89\":{\"h\":\"Shuyu\"},\"90\":{\"h\":\"Tec\"},\"91\":{\"h\":\"Traffic En\"},\"92\":{\"h\":\"Traffic Planning\"},\"93\":{\"h\":\"Traffic Theory\"}},\"dirtCount\":0,\"index\":[[\"事故等紧急情况下的交通状况\",{\"1\":{\"79\":1}}],[\"拥堵和行人安全的影响\",{\"1\":{\"79\":1}}],[\"帮助制定有效的应急响应策略\",{\"1\":{\"79\":1}}],[\"帮助规划者评估其对交通流量\",{\"1\":{\"79\":1}}],[\"帮助开发更为智能的决策方案\",{\"1\":{\"79\":1}}],[\"提供应急响应与安全管理案例\",{\"1\":{\"79\":1}}],[\"提供虚拟测试的平台\",{\"1\":{\"79\":1}}],[\"提供新的开发算法思路\",{\"1\":{\"79\":1}}],[\"提供高质量的真实数据用于训练与模拟\",{\"1\":{\"79\":1}}],[\"提取图像的特征\",{\"1\":{\"6\":1}}],[\"quality\",{\"1\":{\"79\":2}}],[\"语音识别等任务的机器学习模型\",{\"1\":{\"78\":1}}],[\"适应能力的\",{\"1\":{\"78\":1}}],[\"适用于大型数据集\",{\"1\":{\"16\":1}}],[\"适用于线性可分的数据集\",{\"1\":{\"15\":1}}],[\"理解\",{\"1\":{\"78\":1}}],[\"理论知识\",{\"1\":{\"4\":1}}],[\"具有学习\",{\"1\":{\"78\":1}}],[\"具体讲解可以看这篇文章与这篇文章\",{\"1\":{\"25\":1}}],[\"具体解释\",{\"1\":{\"14\":1}}],[\"得到的具有\",{\"1\":{\"78\":1}}],[\"架构等\",{\"1\":{\"78\":1}}],[\"微调\",{\"1\":{\"78\":1}}],[\"微观\",{\"1\":{\"56\":2}}],[\"大语言模型是利用深度学习技术\",{\"1\":{\"78\":1}}],[\"大小的滑动窗口在\",{\"1\":{\"63\":1}}],[\"大小分别为\",{\"1\":{\"57\":1}}],[\"文献导读\",{\"0\":{\"75\":1}}],[\"完整代码\",{\"1\":{\"64\":1}}],[\"热力图\",{\"1\":{\"64\":1}}],[\"动态演示\",{\"1\":{\"64\":1}}],[\"结果\",{\"0\":{\"64\":1}}],[\"贴近现实中人是向前走的\",{\"1\":{\"63\":1}}],[\"矩阵进行计算\",{\"1\":{\"63\":1}}],[\"新选择原胞更新为占有状态\",{\"1\":{\"63\":1}}],[\"上进行更新\",{\"1\":{\"63\":1}}],[\"上下前三个方向不全都有人\",{\"1\":{\"63\":1}}],[\"上采样\",{\"1\":{\"6\":1}}],[\"~=0\",{\"1\":{\"63\":1}}],[\"位置更新\",{\"1\":{\"63\":3}}],[\"位置矩阵\",{\"1\":{\"62\":1}}],[\"依原胞潜力n\",{\"1\":{\"63\":1}}],[\"依次从需要计算的\",{\"1\":{\"63\":1}}],[\"依赖于全部的数据\",{\"1\":{\"15\":1}}],[\"依赖数据表达的距离测度\",{\"1\":{\"15\":1}}],[\"^2\",{\"1\":{\"63\":1}}],[\"^2+\",{\"1\":{\"63\":1}}],[\"+o\",{\"1\":{\"63\":1}}],[\"+obstacle\",{\"1\":{\"63\":7}}],[\"+d\",{\"1\":{\"63\":1}}],[\"+sm\",{\"1\":{\"63\":7}}],[\"+1\",{\"1\":{\"63\":4}}],[\"+\",{\"1\":{\"63\":5}}],[\"+2\",{\"1\":{\"62\":4}}],[\"参数计算\",{\"0\":{\"63\":1}}],[\"参数设置\",{\"0\":{\"62\":1}}],[\"$\",{\"1\":{\"62\":4}}],[\"外加了两圈障碍\",{\"1\":{\"62\":1}}],[\"外加了一圈障碍\",{\"1\":{\"62\":1}}],[\"记录时刻平台信息\",{\"1\":{\"62\":1}}],[\"迭代周期960s\",{\"1\":{\"64\":1}}],[\"迭代时间\",{\"1\":{\"62\":1}}],[\"迭代次数截断\",{\"1\":{\"11\":1}}],[\"迭代次数\",{\"1\":{\"10\":1}}],[\"到达终点人数\",{\"1\":{\"62\":1}}],[\"出发人数\",{\"1\":{\"62\":1}}],[\"出口\",{\"1\":{\"62\":1}}],[\"generating\",{\"1\":{\"79\":1}}],[\"gpt\",{\"1\":{\"79\":1}}],[\"goods\",{\"1\":{\"76\":2}}],[\"go=0\",{\"1\":{\"62\":1}}],[\"guide\",{\"1\":{\"79\":1}}],[\"gui\",{\"0\":{\"72\":1}}],[\"global\",{\"1\":{\"33\":1}}],[\"概率矩阵\",{\"1\":{\"62\":1}}],[\"概述\",{\"0\":{\"56\":1}}],[\"预留内存\",{\"1\":{\"62\":2}}],[\"预剪枝基于\",{\"1\":{\"13\":1}}],[\"预剪枝\",{\"1\":{\"13\":1}}],[\"预剪枝和后剪枝\",{\"1\":{\"13\":1}}],[\"zeros\",{\"1\":{\"62\":2,\"63\":1}}],[\"初始迭代次数\",{\"1\":{\"62\":1}}],[\"初始化平台\",{\"1\":{\"62\":1}}],[\"设置出口原胞潜力为\",{\"1\":{\"63\":1}}],[\"设置障碍\",{\"1\":{\"62\":2}}],[\"设置非障碍矩阵\",{\"1\":{\"62\":1}}],[\"障碍视为距离无穷\",{\"1\":{\"63\":1}}],[\"障碍\",{\"1\":{\"62\":1}}],[\"入口纵坐标\",{\"1\":{\"62\":1}}],[\"入口横坐标\",{\"1\":{\"62\":1}}],[\"代码从离平台近的位置向远处开始遍历\",{\"1\":{\"63\":1}}],[\"代码设定\",{\"1\":{\"63\":1}}],[\"代码流程图\",{\"1\":{\"61\":1}}],[\"代码整体思路如下\",{\"1\":{\"61\":1}}],[\"代表不占有\",{\"1\":{\"60\":1}}],[\"代表占有\",{\"1\":{\"60\":1}}],[\"代表位置\",{\"1\":{\"60\":2}}],[\"部分代码解释\",{\"0\":{\"61\":1}}],[\"9\",{\"1\":{\"60\":2,\"62\":4,\"63\":1}}],[\"960s\",{\"1\":{\"57\":1}}],[\"环境的动态影响\",{\"1\":{\"60\":1}}],[\"环境中静止物体的影响\",{\"1\":{\"60\":1}}],[\"处的元胞潜能\",{\"1\":{\"60\":1}}],[\"处元胞状态\",{\"1\":{\"60\":1}}],[\"j+neigh\",{\"1\":{\"63\":1}}],[\"j=h+1\",{\"1\":{\"63\":1}}],[\"j=1\",{\"1\":{\"63\":2}}],[\"j\",{\"1\":{\"60\":5,\"62\":2,\"63\":11}}],[\"j​+k3​di\",{\"1\":{\"60\":1}}],[\"j​+k2​oi\",{\"1\":{\"60\":1}}],[\"j​+ko​oi\",{\"1\":{\"60\":1}}],[\"j​+kd​di\",{\"1\":{\"60\":1}}],[\"j​=kl​li\",{\"1\":{\"60\":1}}],[\"j​=0\",{\"1\":{\"60\":1}}],[\"j​=ei\",{\"1\":{\"60\":2}}],[\"j​\",{\"1\":{\"60\":11,\"63\":3}}],[\"j​exp\",{\"1\":{\"60\":2}}],[\"更新规则即行人如何选择下一步走到哪里一个方格\",{\"1\":{\"60\":1}}],[\"更新规则\",{\"0\":{\"60\":1}}],[\"更方便优化\",{\"1\":{\"6\":1}}],[\"划分为方格形\",{\"1\":{\"59\":1}}],[\"划分为三个主要分类\",{\"1\":{\"10\":1}}],[\"状态设置为占有\",{\"1\":{\"59\":1}}],[\"规定仿真时间为\",{\"1\":{\"57\":1}}],[\"行人随机从各个入口进入\",{\"1\":{\"57\":1}}],[\"行人每秒走一格\",{\"1\":{\"57\":1}}],[\"行人不得通过障碍\",{\"1\":{\"57\":1}}],[\"行人流仿真按仿真规模可以大致分为三种\",{\"1\":{\"56\":1}}],[\"行人流仿真是通过模拟人群在不同环境下的移动\",{\"1\":{\"56\":1}}],[\"行人流仿真\",{\"0\":{\"55\":1}}],[\"均为\",{\"1\":{\"57\":1}}],[\"右四个出口\",{\"1\":{\"57\":1}}],[\"左三个入口\",{\"1\":{\"57\":1}}],[\"平面示意图\",{\"1\":{\"57\":1}}],[\"平台长度\",{\"1\":{\"62\":1}}],[\"平台宽度\",{\"1\":{\"62\":1}}],[\"平台\",{\"1\":{\"57\":1}}],[\"平台基本信息\",{\"1\":{\"57\":1}}],[\"平移不变性是指输出结果对输入对小量平移基本保持不变\",{\"1\":{\"6\":1}}],[\"平移不变性\",{\"1\":{\"6\":1}}],[\"格子气模型以及基于机器学习的模型等\",{\"1\":{\"56\":1}}],[\"⏩\",{\"1\":{\"56\":1}}],[\"既研究整体特征也研究个体特征\",{\"1\":{\"56\":1}}],[\"介观\",{\"1\":{\"56\":1}}],[\"介于宏微观之间\",{\"1\":{\"56\":2}}],[\"流向等\",{\"1\":{\"56\":1}}],[\"流程\",{\"1\":{\"12\":1}}],[\"密度\",{\"1\":{\"56\":1}}],[\"密度聚类\",{\"1\":{\"16\":1}}],[\"研究个体行为\",{\"1\":{\"56\":1}}],[\"研究整体移动特征如速度\",{\"1\":{\"56\":1}}],[\"研究行人行为及心理的特点的研究\",{\"1\":{\"56\":1}}],[\"宏观\",{\"1\":{\"56\":2}}],[\"建筑平面设计等方面有着广泛的应用\",{\"1\":{\"56\":1}}],[\"建立输入和输出之间的映射关系\",{\"1\":{\"10\":1}}],[\"疏散计划\",{\"1\":{\"56\":1}}],[\"佛洛依德算法\",{\"0\":{\"45\":1}}],[\"迪杰斯特拉算法\",{\"0\":{\"40\":1}}],[\"改进a\",{\"0\":{\"35\":1}}],[\"改变了问题的复杂度\",{\"1\":{\"15\":1}}],[\"high\",{\"1\":{\"79\":2}}],[\"handle\",{\"1\":{\"78\":1,\"79\":1}}],[\"has\",{\"1\":{\"33\":2}}],[\"h+1\",{\"1\":{\"63\":1}}],[\"h+2\",{\"1\":{\"62\":3,\"63\":1}}],[\"h+4\",{\"1\":{\"62\":2}}],[\"h\",{\"1\":{\"62\":4,\"63\":1}}],[\"hurdle\",{\"1\":{\"62\":11,\"63\":3}}],[\"h=30\",{\"1\":{\"62\":1}}],[\"here\",{\"1\":{\"21\":1,\"22\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"51\":1,\"52\":1,\"68\":1,\"69\":1}}],[\"heading\",{\"0\":{\"21\":1,\"22\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"51\":1,\"52\":1,\"68\":1,\"69\":1}}],[\"英文总结\",{\"1\":{\"33\":1}}],[\"英语\",{\"1\":{\"4\":1}}],[\"模拟拟不同的交通规划方案\",{\"1\":{\"79\":1}}],[\"模拟行人穿过以平台\",{\"1\":{\"57\":1}}],[\"模拟现实复杂动态系统\",{\"1\":{\"33\":1}}],[\"模型对于交通行业影响\",{\"0\":{\"79\":1}}],[\"模型设置\",{\"0\":{\"58\":1}}],[\"模型也可以在微观层面研究\",{\"1\":{\"56\":1}}],[\"模型的行人流仿真\",{\"1\":{\"55\":1}}],[\"模型的基本单元\",{\"1\":{\"27\":1}}],[\"模型最为关键的部分\",{\"1\":{\"31\":1}}],[\"模型过分记住了噪声\",{\"1\":{\"11\":1}}],[\"模型复杂度过低\",{\"1\":{\"11\":1}}],[\"模型评估与选择\",{\"0\":{\"11\":1}}],[\"模型训练过程中单独留出的样本集\",{\"1\":{\"10\":1}}],[\"模型\",{\"1\":{\"10\":1,\"55\":1}}],[\"化学\",{\"1\":{\"33\":1}}],[\"化表示\",{\"1\":{\"10\":1}}],[\"作为物理\",{\"1\":{\"33\":1}}],[\"作用是在训练阶段的第三个步骤中\",{\"1\":{\"14\":1}}],[\"作用请从机器学习训练阶段的三个步骤的角度来阐述\",{\"1\":{\"14\":1}}],[\"作用\",{\"1\":{\"10\":3}}],[\"应用\",{\"0\":{\"33\":1}}],[\"应用等方面\",{\"1\":{\"25\":1}}],[\"图5\",{\"1\":{\"64\":1}}],[\"图4\",{\"1\":{\"64\":1}}],[\"图\",{\"1\":{\"62\":1}}],[\"图3\",{\"1\":{\"61\":1}}],[\"图2\",{\"1\":{\"32\":1,\"60\":1}}],[\"图1\",{\"1\":{\"29\":1,\"57\":1}}],[\"​s<2∨s>3s=2s=3​\",{\"1\":{\"32\":1}}],[\"νt\",{\"1\":{\"32\":1}}],[\"α\",{\"1\":{\"32\":2}}],[\"virtual\",{\"1\":{\"79\":1}}],[\"videos\",{\"1\":{\"79\":2}}],[\"vision\",{\"1\":{\"78\":1}}],[\"vehicles\",{\"1\":{\"76\":3}}],[\"various\",{\"1\":{\"56\":1,\"78\":1}}],[\"vt+1\",{\"1\":{\"32\":1}}],[\"von\",{\"1\":{\"26\":1,\"29\":2}}],[\"死\",{\"1\":{\"32\":1}}],[\"死亡\",{\"1\":{\"32\":2}}],[\"否则就待在原地\",{\"1\":{\"63\":1}}],[\"否则就变为\",{\"1\":{\"32\":1}}],[\"否则继续保持\",{\"1\":{\"32\":1}}],[\"生物过程的基础模型\",{\"1\":{\"33\":1}}],[\"生\",{\"1\":{\"32\":2}}],[\"生命游戏是最著名的二维元胞自动机生命游戏\",{\"1\":{\"32\":1}}],[\"生命游戏\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"则待在原地\",{\"1\":{\"63\":1}}],[\"则选回原位置\",{\"1\":{\"63\":1}}],[\"则该格变为\",{\"1\":{\"32\":1}}],[\"则该格继续保持\",{\"1\":{\"32\":1}}],[\"则无论该神经网络有多少层\",{\"1\":{\"14\":1}}],[\"若它的\",{\"1\":{\"32\":2}}],[\"活着\",{\"1\":{\"32\":3}}],[\"邻居中有\",{\"1\":{\"32\":1}}],[\"邻居\",{\"1\":{\"32\":1}}],[\"邻居定义为\",{\"1\":{\"29\":1}}],[\"邻居定义为下式\",{\"1\":{\"29\":1}}],[\"或活着\",{\"1\":{\"32\":1}}],[\"或自顶向下的分裂聚类\",{\"1\":{\"16\":1}}],[\"年设计\",{\"1\":{\"32\":1}}],[\"年代在洛斯阿拉莫斯国家实验室同时提出\",{\"1\":{\"26\":1}}],[\"高维度\",{\"1\":{\"31\":1}}],[\"高斯核\",{\"1\":{\"15\":1}}],[\"服从相同的规律分布方式相同\",{\"1\":{\"31\":1}}],[\"同质性\",{\"1\":{\"31\":1}}],[\"同时计算复杂度可能会较高\",{\"1\":{\"15\":1}}],[\"同时减小了下一层的输入大小\",{\"1\":{\"6\":1}}],[\"空间\",{\"1\":{\"31\":1}}],[\"离散型\",{\"1\":{\"31\":1}}],[\"由john\",{\"1\":{\"32\":1}}],[\"由局部到整体\",{\"1\":{\"31\":1}}],[\"由求特征向量转化为求比例系数\",{\"1\":{\"15\":1}}],[\"映射型\",{\"1\":{\"30\":1}}],[\"虚拟的元胞\",{\"1\":{\"30\":1}}],[\"注\",{\"1\":{\"30\":1}}],[\"绝热型\",{\"1\":{\"30\":1}}],[\"绝热型和映射型这四种\",{\"1\":{\"30\":1}}],[\"绝对的宿命论主义倾向\",{\"1\":{\"3\":1}}],[\"周期型\",{\"1\":{\"30\":2}}],[\"周边盆友的影响👬\",{\"1\":{\"2\":1}}],[\"固定型\",{\"1\":{\"30\":2}}],[\"边界矩阵\",{\"1\":{\"62\":1}}],[\"边界矩阵长\",{\"1\":{\"62\":1}}],[\"边界矩阵宽\",{\"1\":{\"62\":1}}],[\"边界元胞为元胞每个维度内侧邻近元胞\",{\"1\":{\"30\":1}}],[\"边界元胞与自己相同\",{\"1\":{\"30\":1}}],[\"边界条件是元胞空间外的部分\",{\"1\":{\"30\":1}}],[\"边界条件\",{\"0\":{\"30\":1},\"1\":{\"59\":1}}],[\"边界点和噪声点\",{\"1\":{\"16\":1}}],[\"∣x−x0​∣+∣y−y0​∣<=r\",{\"1\":{\"29\":1}}],[\"∣x−x0​∣<=r\",{\"1\":{\"29\":1}}],[\"∣y−y0​∣<=r\",{\"1\":{\"29\":1}}],[\"xy\",{\"1\":{\"63\":4}}],[\"x+1\",{\"1\":{\"63\":4}}],[\"x+2\",{\"1\":{\"63\":6}}],[\"x=n+2\",{\"1\":{\"62\":1}}],[\"x\",{\"1\":{\"29\":2,\"62\":8,\"63\":10}}],[\"x0​\",{\"1\":{\"29\":2}}],[\"y+2\",{\"1\":{\"63\":6}}],[\"y+1\",{\"1\":{\"63\":4}}],[\"y=h+2\",{\"1\":{\"62\":1}}],[\"y=x\",{\"1\":{\"6\":1}}],[\"y\",{\"1\":{\"29\":2,\"62\":11,\"63\":15}}],[\"y0​\",{\"1\":{\"29\":2}}],[\"型\",{\"1\":{\"29\":1,\"59\":1}}],[\"型和\",{\"1\":{\"29\":1}}],[\"取决于元胞状态更新时所要搜索的空间域\",{\"1\":{\"29\":1}}],[\"复杂情况下也有多维\",{\"1\":{\"27\":1}}],[\"复杂度只与样本数量有关\",{\"1\":{\"15\":1}}],[\"元胞潜力\",{\"1\":{\"62\":1}}],[\"元胞潜能可以写为\",{\"1\":{\"60\":1}}],[\"元胞动态势能反应行人在选择下一步时\",{\"1\":{\"60\":1}}],[\"元胞静态势能反应了行人在选择下一步时\",{\"1\":{\"60\":1}}],[\"元胞的状态更新规则变化是同步进行的\",{\"1\":{\"31\":1}}],[\"元胞类型\",{\"1\":{\"29\":1}}],[\"元胞呈一定形状\",{\"1\":{\"28\":1}}],[\"元胞是\",{\"1\":{\"27\":1}}],[\"元胞规则是整个\",{\"1\":{\"31\":1}}],[\"元胞规则即每次迭代\",{\"1\":{\"31\":1}}],[\"元胞规则\",{\"0\":{\"31\":1},\"1\":{\"26\":1}}],[\"元胞边界\",{\"1\":{\"26\":1}}],[\"元胞邻居是某一元胞周围的元胞\",{\"1\":{\"29\":1}}],[\"元胞邻居\",{\"0\":{\"29\":1},\"1\":{\"26\":1,\"59\":1}}],[\"元胞空间划分方式大致有\",{\"1\":{\"28\":1}}],[\"元胞空间为空间内元胞的集合\",{\"1\":{\"28\":1}}],[\"元胞空间\",{\"0\":{\"28\":1},\"1\":{\"26\":1,\"59\":1}}],[\"元胞\",{\"0\":{\"27\":1},\"1\":{\"26\":1,\"59\":1}}],[\"元胞自动机的应用大致有以下几类\",{\"1\":{\"33\":1}}],[\"元胞自动机是一类无穷维动力系统\",{\"1\":{\"31\":1}}],[\"元胞自动机更新规则特征\",{\"1\":{\"31\":1}}],[\"元胞自动机\",{\"0\":{\"25\":1},\"1\":{\"26\":1}}],[\"世纪\",{\"1\":{\"26\":1}}],[\"世界杯\",{\"1\":{\"3\":1}}],[\"世界之本质\",{\"1\":{\"3\":1}}],[\"于\",{\"1\":{\"26\":1}}],[\"overarching\",{\"1\":{\"76\":1}}],[\"occur\",{\"1\":{\"76\":1}}],[\"operational\",{\"1\":{\"76\":1}}],[\"o=obstacle\",{\"1\":{\"63\":1}}],[\"o\",{\"1\":{\"62\":1}}],[\"obstacle\",{\"1\":{\"62\":7}}],[\"oi\",{\"1\":{\"60\":1,\"63\":1}}],[\"ones\",{\"1\":{\"62\":2}}],[\"on\",{\"1\":{\"33\":1,\"76\":3,\"78\":1}}],[\"or\",{\"1\":{\"33\":2,\"76\":4}}],[\"offer\",{\"1\":{\"79\":2}}],[\"often\",{\"1\":{\"76\":2}}],[\"of\",{\"0\":{\"76\":1},\"1\":{\"26\":1,\"33\":2,\"56\":1,\"76\":8,\"78\":2,\"79\":2}}],[\"oyh的帮助\",{\"1\":{\"1\":1}}],[\"包括其定义\",{\"1\":{\"25\":1}}],[\"creation\",{\"1\":{\"79\":1}}],[\"crowds\",{\"1\":{\"56\":1}}],[\"cutting\",{\"0\":{\"77\":1}}],[\"current\",{\"1\":{\"33\":1}}],[\"choose\",{\"1\":{\"63\":2}}],[\"choose=zeros\",{\"1\":{\"62\":1}}],[\"changes\",{\"1\":{\"33\":1}}],[\"clear\",{\"1\":{\"62\":1}}],[\"clc\",{\"1\":{\"62\":1}}],[\"cell\",{\"1\":{\"33\":7}}],[\"cellular\",{\"0\":{\"25\":1},\"1\":{\"26\":1,\"33\":2,\"56\":1}}],[\"complex\",{\"1\":{\"79\":1}}],[\"complete\",{\"1\":{\"33\":1}}],[\"computer\",{\"1\":{\"78\":1}}],[\"computing\",{\"1\":{\"33\":2}}],[\"concept\",{\"1\":{\"76\":1}}],[\"context\",{\"1\":{\"76\":1}}],[\"content\",{\"1\":{\"21\":1,\"22\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"51\":1,\"52\":1,\"68\":1,\"69\":1}}],[\"congestion\",{\"1\":{\"76\":1}}],[\"conway于\",{\"1\":{\"32\":1}}],[\"capable\",{\"1\":{\"78\":1}}],[\"cat\",{\"1\":{\"62\":2}}],[\"can\",{\"1\":{\"33\":1,\"76\":1}}],[\"ca\",{\"1\":{\"26\":1,\"27\":1,\"31\":1,\"55\":2,\"56\":2}}],[\"csuer\",{\"1\":{\"3\":1}}],[\"还可以用于分类\",{\"1\":{\"17\":1}}],[\"还有很多排版\",{\"1\":{\"1\":1}}],[\"除了可以用于降维\",{\"1\":{\"17\":1}}],[\"除训练集外所有样本\",{\"1\":{\"11\":1}}],[\"没有这个限制\",{\"1\":{\"17\":1}}],[\"没有将排名分数作为直接结果\",{\"1\":{\"15\":1}}],[\"两者都假设数据符合高斯分布\",{\"1\":{\"17\":1}}],[\"两者在降维时均使用了矩阵特征分解的思想\",{\"1\":{\"17\":1}}],[\"两者均可以对数据进行降维\",{\"1\":{\"17\":1}}],[\"之间的区别和联系\",{\"1\":{\"17\":1}}],[\"八\",{\"0\":{\"17\":1}}],[\"特别是在大型数据集上\",{\"1\":{\"16\":1}}],[\"特征量过少\",{\"1\":{\"11\":1}}],[\"特征降维\",{\"1\":{\"6\":1}}],[\"特征不变性\",{\"1\":{\"6\":1}}],[\"次之\",{\"1\":{\"16\":1}}],[\"计算机视觉\",{\"1\":{\"78\":1}}],[\"计算位置1到9各原胞潜力大小\",{\"1\":{\"63\":1}}],[\"计算所有邻居原胞的原胞潜力n\",{\"1\":{\"63\":1}}],[\"计算原胞潜力\",{\"1\":{\"63\":1}}],[\"计算元胞潜力\",{\"1\":{\"63\":1}}],[\"计算单元\",{\"1\":{\"33\":1}}],[\"计算复杂度\",{\"1\":{\"16\":1}}],[\"计算量相对大\",{\"1\":{\"6\":1}}],[\"计算量大\",{\"1\":{\"6\":1}}],[\"能够理解和生成高质量的文本提示\",{\"1\":{\"79\":1}}],[\"能够发现各种形状和密度的簇\",{\"1\":{\"16\":1}}],[\"能够处理多任务如自然语言处理\",{\"1\":{\"78\":1}}],[\"能够处理非线性特征之间的相互作用\",{\"1\":{\"15\":1}}],[\"能够处理非线性可分的数据集\",{\"1\":{\"15\":1}}],[\"能够处理非线性可分的数据集和噪声数据\",{\"1\":{\"15\":1}}],[\"能够处理大型特征空间\",{\"1\":{\"15\":1}}],[\"假定簇是球形且密度均匀\",{\"1\":{\"16\":1}}],[\"假设数据本身是线性可分的\",{\"1\":{\"15\":1}}],[\"簇数的预先指定\",{\"1\":{\"16\":1}}],[\"合并或分裂的决定需要检查和估算大量的对象或簇\",{\"1\":{\"16\":1}}],[\"时间及状态都是离散的\",{\"1\":{\"31\":1}}],[\"时间复杂性至少是\",{\"1\":{\"16\":1}}],[\"时是留一法\",{\"1\":{\"11\":1}}],[\"可视为无穷大\",{\"1\":{\"63\":1}}],[\"可视化结果以树状结构呈现\",{\"1\":{\"16\":1}}],[\"可能需要调整半径参数和最小邻居数\",{\"1\":{\"16\":1}}],[\"可能会导致低质量的聚类结果\",{\"1\":{\"16\":1}}],[\"可以自己手动画一个图验证一下\",{\"1\":{\"63\":1}}],[\"可以自然地引入核函数\",{\"1\":{\"15\":1}}],[\"可以发现\",{\"1\":{\"60\":1}}],[\"可以将它们识别为噪声\",{\"1\":{\"16\":1}}],[\"可以根据需要切割簇\",{\"1\":{\"16\":1}}],[\"可以在聚类的同时发现异常点\",{\"1\":{\"16\":1}}],[\"可以对任意形状的稠密数据集进行聚类\",{\"1\":{\"16\":1}}],[\"可以处理非线性特征\",{\"1\":{\"15\":1}}],[\"可以控制对分类错误的容忍程度\",{\"1\":{\"15\":1}}],[\"可以分为\",{\"1\":{\"14\":1}}],[\"可以使得得到的模型更为稳健\",{\"1\":{\"11\":1}}],[\"可以跟人一样聪明\",{\"1\":{\"10\":1}}],[\"凝聚型\",{\"1\":{\"16\":1}}],[\"每个行人占一格\",{\"1\":{\"57\":1}}],[\"每个个体有着独特的行为特征\",{\"1\":{\"56\":1}}],[\"每个个体没有行为特征\",{\"1\":{\"56\":1}}],[\"每个元胞按照该规则进行状态更新\",{\"1\":{\"31\":1}}],[\"每个元胞按照当前状态及周围邻居的状态来更新下一时刻该元胞状态\",{\"1\":{\"31\":1}}],[\"每个维度的第一个元胞与最后一个元胞互为边界\",{\"1\":{\"30\":1}}],[\"每个簇包含最接近其质心的数据点\",{\"1\":{\"16\":1}}],[\"每一个元胞都有一个状态\",{\"1\":{\"27\":1}}],[\"每一维对应一个特征\",{\"1\":{\"10\":1}}],[\"个周边位置滑动\",{\"1\":{\"63\":1}}],[\"个位置没有人的话才进行选择\",{\"1\":{\"63\":1}}],[\"个位置的选择概率\",{\"1\":{\"60\":1}}],[\"个位置进行标号\",{\"1\":{\"60\":1}}],[\"个邻居中有\",{\"1\":{\"32\":1}}],[\"个为\",{\"1\":{\"32\":1}}],[\"个\",{\"1\":{\"32\":2,\"62\":1}}],[\"个簇\",{\"1\":{\"16\":1}}],[\"个人觉得这并不是一个很严重的缺点\",{\"1\":{\"15\":1}}],[\"工作原理\",{\"1\":{\"16\":3}}],[\"层次聚类和\",{\"1\":{\"16\":1}}],[\"层次聚类会生成层次结构\",{\"1\":{\"16\":1}}],[\"层次聚类将数据集逐渐分割或合并成不同的层次簇\",{\"1\":{\"16\":1}}],[\"层次聚类\",{\"1\":{\"16\":2}}],[\"k1​li\",{\"1\":{\"60\":1}}],[\"kd​\",{\"1\":{\"60\":1}}],[\"ks​\",{\"1\":{\"60\":1}}],[\"ks​si\",{\"1\":{\"60\":1}}],[\"k\",{\"1\":{\"16\":10,\"17\":1,\"63\":4}}],[\"k=m\",{\"1\":{\"11\":1}}],[\"聚类收敛时间较长\",{\"1\":{\"16\":1}}],[\"聚类结果没有偏倚\",{\"1\":{\"16\":1}}],[\"聚类之间不能交换对象\",{\"1\":{\"16\":1}}],[\"聚类方法原理\",{\"1\":{\"16\":1}}],[\"聚类方法分类\",{\"1\":{\"16\":1}}],[\"聚类\",{\"0\":{\"16\":1},\"1\":{\"16\":1}}],[\"七\",{\"0\":{\"16\":1}}],[\"adaptive\",{\"1\":{\"79\":1}}],[\"adapting\",{\"1\":{\"78\":1}}],[\"algorithms\",{\"1\":{\"79\":1}}],[\"all\",{\"1\":{\"76\":1}}],[\"alive\",{\"1\":{\"33\":1}}],[\"air\",{\"1\":{\"76\":1}}],[\"any\",{\"1\":{\"76\":1}}],[\"analysis\",{\"1\":{\"76\":1}}],[\"and\",{\"1\":{\"33\":4,\"56\":3,\"76\":8,\"78\":4,\"79\":2}}],[\"as\",{\"1\":{\"76\":1,\"78\":1}}],[\"aspect\",{\"1\":{\"76\":1}}],[\"aspects\",{\"1\":{\"56\":1,\"76\":1}}],[\"associated\",{\"1\":{\"76\":1}}],[\"architectures\",{\"1\":{\"78\":1}}],[\"architectural\",{\"1\":{\"56\":1}}],[\"are\",{\"1\":{\"78\":2}}],[\"areas\",{\"1\":{\"76\":1}}],[\"arrive=0\",{\"1\":{\"62\":1}}],[\"applications\",{\"1\":{\"33\":1,\"56\":1}}],[\"at\",{\"1\":{\"33\":1}}],[\"automaton\",{\"1\":{\"33\":2}}],[\"automata\",{\"0\":{\"25\":1},\"1\":{\"26\":2,\"33\":1,\"56\":1}}],[\"a\",{\"0\":{\"20\":1},\"1\":{\"15\":1,\"33\":4,\"76\":3}}],[\"about\",{\"1\":{\"1\":1,\"76\":1}}],[\"求解的是\",{\"1\":{\"15\":1}}],[\"求解的复杂度与样本的维度有关即\",{\"1\":{\"15\":1}}],[\"求导涉及除法\",{\"1\":{\"6\":1}}],[\"效率并不是很高\",{\"1\":{\"15\":1}}],[\"随机森林克服了此缺点\",{\"1\":{\"15\":1}}],[\"随笔等其他内容\",{\"1\":{\"4\":1}}],[\"考虑了变量之间的相互作用\",{\"1\":{\"15\":1}}],[\"直观的决策规则\",{\"1\":{\"15\":1}}],[\"当元胞占有时\",{\"1\":{\"60\":1}}],[\"当观测样本很多时\",{\"1\":{\"15\":1}}],[\"当特征空间很大时\",{\"1\":{\"15\":1}}],[\"当然通过改变参数的形状\",{\"1\":{\"6\":1}}],[\"多重共线性并不是问题\",{\"1\":{\"15\":1}}],[\"多项式核和\",{\"1\":{\"15\":1}}],[\"已有工具的高效实现\",{\"1\":{\"15\":1}}],[\"便利的观测样本概率分数\",{\"1\":{\"15\":1}}],[\"便于我们选择合适的模型\",{\"1\":{\"11\":1}}],[\"线性\",{\"1\":{\"15\":1}}],[\"线型模型优势与不足\",{\"1\":{\"12\":1}}],[\"线型模型\",{\"0\":{\"12\":1}}],[\"通常是最快的\",{\"1\":{\"16\":1}}],[\"通常不采用核函数的方法\",{\"1\":{\"15\":1}}],[\"通过模拟不同紧急情况下的交通流动\",{\"1\":{\"79\":1}}],[\"通过模拟特定时间段的交通流\",{\"1\":{\"79\":1}}],[\"通过生成不同交通规划方案\",{\"1\":{\"79\":1}}],[\"通过海量多样化数据训练\",{\"1\":{\"78\":1}}],[\"通过密度自动确定簇的数量\",{\"1\":{\"16\":1}}],[\"通过使用核函数将输入空间映射到高维特征空间\",{\"1\":{\"15\":1}}],[\"通过调整这些变量\",{\"1\":{\"15\":1}}],[\"通过引入松弛变量来处理噪声和异常点\",{\"1\":{\"15\":1}}],[\"通过梯度下降来寻找更优的学习参数\",{\"1\":{\"14\":1}}],[\"通过验证集我们可以训练几个\",{\"1\":{\"10\":1}}],[\"本文不定期更新前沿科技简介及对交通领域发展影响\",{\"1\":{\"77\":1}}],[\"本文探讨基于\",{\"1\":{\"55\":1}}],[\"本节简单介绍一下元胞自动机模型\",{\"1\":{\"25\":1}}],[\"本节整理机器学习的基本问题\",{\"1\":{\"8\":1}}],[\"本节整理卷积方面基本概念\",{\"1\":{\"5\":1}}],[\"本质上是其\",{\"1\":{\"15\":1}}],[\"都是判别模型\",{\"1\":{\"15\":1}}],[\"都是监督学习算法\",{\"1\":{\"15\":1}}],[\"都是线性分类算法\",{\"1\":{\"15\":1}}],[\"都是分类算法\",{\"1\":{\"15\":1}}],[\"都会具有\",{\"1\":{\"11\":1}}],[\"回归\",{\"1\":{\"15\":1}}],[\"回归区别联系\",{\"1\":{\"15\":1}}],[\"回归器\",{\"1\":{\"10\":1}}],[\"核心点是在指定半径范围内有足够多邻居的点\",{\"1\":{\"16\":1}}],[\"核\",{\"1\":{\"15\":1}}],[\"常见是元胞自动机模型\",{\"1\":{\"56\":1}}],[\"常见模型是社会力模型\",{\"1\":{\"56\":1}}],[\"常见的非监督学习算法包括聚类\",{\"1\":{\"10\":1}}],[\"常见的监督学习算法包括线性回归\",{\"1\":{\"10\":1}}],[\"常见的模型\",{\"1\":{\"4\":1}}],[\"常用为固定型和周期型\",{\"1\":{\"30\":1}}],[\"常用的邻居边界条件类型有\",{\"1\":{\"30\":1}}],[\"常用的核函数有线性核\",{\"1\":{\"15\":1}}],[\"需要提前指定簇数\",{\"1\":{\"16\":1}}],[\"需要事先指定簇数\",{\"1\":{\"16\":1}}],[\"需要进行转换\",{\"1\":{\"15\":1}}],[\"需要调整松弛变量和惩罚参数\",{\"1\":{\"15\":1}}],[\"需要使偏差小\",{\"1\":{\"11\":1}}],[\"允许在某些情况下出现分类错误\",{\"1\":{\"15\":1}}],[\"放松了对数据线性可分的假设\",{\"1\":{\"15\":1}}],[\"放大图像\",{\"1\":{\"6\":1}}],[\"因为异常点可能导致无法找到一个满足所有约束条件的超平面\",{\"1\":{\"15\":1}}],[\"因此因变量是连续的\",{\"1\":{\"12\":1}}],[\"因此因变量是离散的\",{\"1\":{\"12\":1}}],[\"因此对一些对数据分布敏感的模型选择并不适用\",{\"1\":{\"11\":1}}],[\"此外\",{\"1\":{\"15\":1,\"56\":1,\"63\":1}}],[\"原来原胞更新为空状态\",{\"1\":{\"63\":1}}],[\"原理\",{\"1\":{\"15\":3}}],[\"原因\",{\"1\":{\"11\":2}}],[\"原因大致有以下几点\",{\"1\":{\"2\":1}}],[\"硬间隔\",{\"1\":{\"15\":4}}],[\"基于概率密度函数的估计方法和基于样本间相似性度量的间接聚类方法\",{\"1\":{\"16\":1}}],[\"基于核函数的\",{\"1\":{\"15\":3}}],[\"基本设置\",{\"0\":{\"59\":1}}],[\"基本思想是将高维的模式样本投影到最佳鉴别矢量空间\",{\"1\":{\"12\":1}}],[\"基本概念\",{\"0\":{\"6\":1,\"9\":1},\"1\":{\"25\":1}}],[\"软间隔\",{\"1\":{\"15\":4}}],[\"试述硬间隔\",{\"1\":{\"15\":1}}],[\"六\",{\"0\":{\"15\":1}}],[\"达到优化模型的效果\",{\"1\":{\"14\":1}}],[\"world\",{\"1\":{\"79\":1}}],[\"water\",{\"1\":{\"76\":1}}],[\"within\",{\"1\":{\"76\":1}}],[\"with\",{\"1\":{\"76\":1}}],[\"which\",{\"1\":{\"33\":1,\"78\":1}}],[\"who\",{\"1\":{\"3\":1}}],[\"w\",{\"1\":{\"14\":1,\"15\":1}}],[\"沿着梯度下降的方向求解极小值\",{\"1\":{\"14\":1}}],[\"θ\",{\"1\":{\"14\":1}}],[\"梯度下降方法通过求出损失函数在某点对于参数\",{\"1\":{\"14\":1}}],[\"梯度下降方法的原理\",{\"1\":{\"14\":1}}],[\"梯度下降算法收敛很慢\",{\"1\":{\"10\":1}}],[\"梯度下降算法不会收敛\",{\"1\":{\"10\":1}}],[\"再励学习\",{\"1\":{\"14\":1}}],[\"按学习方式\",{\"1\":{\"14\":1}}],[\"按一定步长\",{\"1\":{\"6\":1}}],[\"前沿科技\",{\"0\":{\"77\":1}}],[\"前沿技术发展等\",{\"1\":{\"4\":1}}],[\"前向型和反馈型\",{\"1\":{\"14\":1}}],[\"联接方式\",{\"1\":{\"14\":1}}],[\"无需依赖整个数据\",{\"1\":{\"15\":1}}],[\"无法找到一个有效的超平面\",{\"1\":{\"15\":1}}],[\"无法解决线性不可分问题\",{\"1\":{\"14\":1}}],[\"无监督学习方法主要有两大类\",{\"1\":{\"16\":1}}],[\"无监督学习\",{\"1\":{\"14\":1}}],[\"无监督学习无反馈\",{\"1\":{\"10\":1}}],[\"无导师的学习\",{\"1\":{\"14\":1}}],[\"最大作为原胞潜力\",{\"1\":{\"63\":1}}],[\"最大池化操作在该神经元上很大概率的输出仍是\",{\"1\":{\"6\":1}}],[\"最大池化将会取\",{\"1\":{\"6\":1}}],[\"最后把再\",{\"1\":{\"63\":1}}],[\"最后取最大\",{\"1\":{\"63\":1}}],[\"最后得到所求\",{\"1\":{\"63\":1}}],[\"最后对\",{\"1\":{\"60\":1}}],[\"最终选择\",{\"1\":{\"62\":1}}],[\"最终的输出都是输入的线性组合\",{\"1\":{\"14\":1}}],[\"最为常见方法为流体动力学模型\",{\"1\":{\"56\":1}}],[\"最常用的邻居类型是\",{\"1\":{\"29\":1}}],[\"最初由stanislaw\",{\"1\":{\"26\":1}}],[\"非线性激活函数的主要作用是什么\",{\"1\":{\"14\":1}}],[\"非监督学习只需要输入数据\",{\"1\":{\"10\":1}}],[\"非监督学习以及强化学习的定义和区别\",{\"1\":{\"10\":1}}],[\"非监督学习\",{\"1\":{\"10\":2}}],[\"五大部分\",{\"1\":{\"26\":1}}],[\"五\",{\"0\":{\"14\":1}}],[\"比预剪枝保留了更多分支\",{\"1\":{\"13\":1}}],[\"比赛\",{\"1\":{\"3\":2}}],[\"禁止这些分支展开\",{\"1\":{\"13\":1}}],[\"贪心\",{\"1\":{\"13\":1}}],[\"缺点\",{\"1\":{\"13\":2,\"15\":3,\"16\":3}}],[\"显著降低训练时间和测试时间的开销\",{\"1\":{\"13\":1}}],[\"降低过拟合风险\",{\"1\":{\"13\":1}}],[\"降维最多降到类别数\",{\"1\":{\"17\":1}}],[\"降维\",{\"0\":{\"17\":1},\"1\":{\"10\":1}}],[\"四\",{\"0\":{\"13\":1}}],[\"投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离\",{\"1\":{\"12\":1}}],[\"分别计算边界内每个原胞到出口的距离\",{\"1\":{\"63\":1}}],[\"分别用计算\",{\"1\":{\"62\":1}}],[\"分别为对应系数\",{\"1\":{\"60\":1}}],[\"分类\",{\"1\":{\"56\":1}}],[\"分类器\",{\"1\":{\"10\":1}}],[\"分裂型\",{\"1\":{\"16\":1}}],[\"分析\",{\"1\":{\"12\":1}}],[\"优缺点\",{\"1\":{\"15\":1,\"16\":1}}],[\"优点\",{\"1\":{\"13\":2,\"15\":3,\"16\":3}}],[\"优势\",{\"1\":{\"12\":1}}],[\"优化器\",{\"1\":{\"10\":1}}],[\"三角形\",{\"1\":{\"28\":1}}],[\"三者最终计算方式以及限制条件\",{\"1\":{\"15\":1}}],[\"三\",{\"0\":{\"12\":1}}],[\"度量了同样大小的训练集的变动所导致的学习性能的变化\",{\"1\":{\"11\":1}}],[\"度量了学习算法的期望预测与真实结果的偏离程度\",{\"1\":{\"11\":1}}],[\"刻画了学习算法本身的拟合能力\",{\"1\":{\"11\":1}}],[\"=1\",{\"1\":{\"63\":1}}],[\"=1e10\",{\"1\":{\"63\":1}}],[\"==0\",{\"1\":{\"63\":2}}],[\"=border\",{\"1\":{\"63\":1}}],[\"=inf\",{\"1\":{\"63\":1}}],[\"=l\",{\"1\":{\"63\":1}}],[\"=sqrt\",{\"1\":{\"63\":1}}],[\"=0\",{\"1\":{\"62\":12,\"63\":1}}],[\"=⎩⎨⎧​0\",{\"1\":{\"32\":1}}],[\"=\",{\"1\":{\"11\":1,\"29\":2,\"62\":12,\"63\":18}}],[\"请先移步这篇文章\",{\"1\":{\"55\":1}}],[\"请给出常用的几种非线性激活函数及其导数\",{\"1\":{\"14\":1}}],[\"请给出你对泛化误差的理解\",{\"1\":{\"11\":1}}],[\"请简要说明主成分分析\",{\"1\":{\"17\":1}}],[\"请简要说明他们之间的关系\",{\"1\":{\"10\":1}}],[\"请简述这两种方式的优缺点\",{\"1\":{\"13\":1}}],[\"8\",{\"1\":{\"11\":1,\"32\":2,\"62\":1,\"63\":2}}],[\"provide\",{\"1\":{\"79\":1}}],[\"produce\",{\"1\":{\"79\":1}}],[\"prompts\",{\"1\":{\"79\":2}}],[\"processing\",{\"1\":{\"78\":1}}],[\"prob\",{\"1\":{\"63\":2}}],[\"prob=zeros\",{\"1\":{\"62\":1}}],[\"pre\",{\"1\":{\"78\":1}}],[\"public\",{\"1\":{\"76\":2}}],[\"possess\",{\"1\":{\"78\":1}}],[\"policies\",{\"1\":{\"76\":1}}],[\"po\",{\"1\":{\"63\":2}}],[\"po=1\",{\"1\":{\"62\":1}}],[\"people\",{\"1\":{\"62\":1,\"76\":3}}],[\"pedestrians\",{\"1\":{\"56\":1,\"76\":1}}],[\"pedestrian\",{\"0\":{\"55\":1},\"1\":{\"56\":1}}],[\"p=zeros\",{\"1\":{\"62\":1}}],[\"pp\",{\"1\":{\"62\":1,\"63\":8}}],[\"ppt\",{\"1\":{\"11\":1,\"13\":1,\"14\":3}}],[\"platforms\",{\"1\":{\"79\":1}}],[\"platform\",{\"1\":{\"62\":3,\"63\":5}}],[\"platform=ones\",{\"1\":{\"62\":1}}],[\"planning\",{\"0\":{\"92\":1},\"1\":{\"56\":2,\"76\":1}}],[\"pi\",{\"1\":{\"60\":1}}],[\"psychological\",{\"1\":{\"56\":1}}],[\"parameters\",{\"1\":{\"78\":1}}],[\"parts\",{\"1\":{\"33\":1}}],[\"paper\",{\"0\":{\"75\":1,\"87\":1}}],[\"patterns\",{\"1\":{\"56\":1}}],[\"p5\",{\"1\":{\"14\":2}}],[\"p6\",{\"1\":{\"14\":1}}],[\"p2\",{\"1\":{\"12\":1}}],[\"p10\",{\"1\":{\"12\":1}}],[\"p1\",{\"1\":{\"12\":1,\"13\":1}}],[\"p9\",{\"1\":{\"11\":1}}],[\"pca\",{\"1\":{\"10\":1,\"17\":4}}],[\"减少数据扰动产生的影响\",{\"1\":{\"11\":1}}],[\"减小模型复杂度\",{\"1\":{\"11\":1}}],[\"充分拟合数据\",{\"1\":{\"11\":1}}],[\"给定学习任务为了取得好的泛化性能\",{\"1\":{\"11\":1}}],[\"给定一个数据样本集\",{\"1\":{\"10\":1}}],[\"数以亿计参数的\",{\"1\":{\"78\":1}}],[\"数学建模\",{\"0\":{\"19\":1}}],[\"数据的充分性以及学习任务本身的难度所共同决定的\",{\"1\":{\"11\":1}}],[\"数模\",{\"1\":{\"4\":1}}],[\"泛化性能更好\",{\"1\":{\"13\":1}}],[\"泛化性能是出学习算法的能力\",{\"1\":{\"11\":1}}],[\"泛化误差\",{\"1\":{\"11\":2}}],[\"噪声处理\",{\"1\":{\"16\":1}}],[\"噪声\",{\"1\":{\"11\":1}}],[\"噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界即刻画了学习问题本身的难度\",{\"1\":{\"11\":1}}],[\"噪声含义\",{\"1\":{\"11\":1}}],[\"即进行位置更新\",{\"1\":{\"63\":1}}],[\"即原胞\",{\"1\":{\"63\":1}}],[\"即可得到选择\",{\"1\":{\"60\":1}}],[\"即该处元胞潜能为\",{\"1\":{\"60\":1}}],[\"即\",{\"1\":{\"56\":1}}],[\"即按一定方式对空间划分\",{\"1\":{\"28\":1}}],[\"即过拟合\",{\"1\":{\"15\":1}}],[\"即存在一个超平面可以将不同类别的样本完全分开\",{\"1\":{\"15\":1}}],[\"即模式在该空间中有最佳的可分离性\",{\"1\":{\"12\":1}}],[\"即刻画了学习问题本身的难度\",{\"1\":{\"11\":1}}],[\"即刻画了学习法本身的拟合能力\",{\"1\":{\"11\":1}}],[\"即刻画了数据扰动所造成的影响\",{\"1\":{\"11\":2}}],[\"即用于训练的样本集合\",{\"1\":{\"10\":1}}],[\"方差分解角度解释泛化性能\",{\"1\":{\"11\":1}}],[\"方差度量了同样大小训练集的变动所导致的学习性能的变化\",{\"1\":{\"11\":1}}],[\"方差\",{\"1\":{\"11\":2}}],[\"偏差+方差+噪声\",{\"1\":{\"11\":1}}],[\"偏差方差冲突\",{\"1\":{\"11\":1}}],[\"偏差度量了学习算法期望预测与真实结果的偏离程度\",{\"1\":{\"11\":1}}],[\"偏差\",{\"1\":{\"11\":3}}],[\"中间设有障碍\",{\"1\":{\"57\":1}}],[\"中的一种离散计算模型\",{\"1\":{\"26\":1}}],[\"中数据的分布未必相一致\",{\"1\":{\"11\":1}}],[\"中划分训练集和测试\",{\"1\":{\"11\":1}}],[\"解决线性模型所不能解决的问题\",{\"1\":{\"14\":1}}],[\"解决了交叉验证法中模型选择阶段和最终模型训练阶段的训练集规模差异问题\",{\"1\":{\"11\":1}}],[\"解决办法\",{\"1\":{\"11\":2}}],[\"集\",{\"1\":{\"11\":1}}],[\"验证\",{\"1\":{\"11\":1}}],[\"验证集的重要性\",{\"1\":{\"10\":1}}],[\"验证集的作用\",{\"1\":{\"10\":1}}],[\"验证集\",{\"1\":{\"10\":1}}],[\"验证集区别联系\",{\"1\":{\"10\":1}}],[\"datasets\",{\"1\":{\"78\":1,\"79\":1}}],[\"d=sm\",{\"1\":{\"63\":1}}],[\"diverse\",{\"1\":{\"78\":1}}],[\"distinguish\",{\"1\":{\"76\":1}}],[\"dis\",{\"1\":{\"63\":6}}],[\"discrete\",{\"1\":{\"33\":1}}],[\"di\",{\"1\":{\"60\":2,\"63\":1}}],[\"dynamic\",{\"1\":{\"56\":1}}],[\"deep\",{\"1\":{\"78\":1}}],[\"describe\",{\"1\":{\"76\":1}}],[\"designed\",{\"1\":{\"76\":1}}],[\"design\",{\"1\":{\"56\":1}}],[\"dead\",{\"1\":{\"33\":1}}],[\"dbscan\",{\"1\":{\"16\":8}}],[\"d\",{\"1\":{\"11\":2,\"62\":1}}],[\"dropout\",{\"1\":{\"11\":1}}],[\"根据数据点的密度将它们分为核心点\",{\"1\":{\"16\":1}}],[\"根据一定规则从数据集\",{\"1\":{\"11\":1}}],[\"根据学习方式的划分\",{\"1\":{\"10\":1}}],[\"它由二维元胞网格组成\",{\"1\":{\"32\":1}}],[\"它们被用于扩展簇\",{\"1\":{\"16\":1}}],[\"它们作为人工智能中评估模型的方法\",{\"1\":{\"11\":1}}],[\"它的结果易于解释和可视化\",{\"1\":{\"16\":1}}],[\"它通过迭代地将数据点分配给最近的质心并更新质心来执行聚类\",{\"1\":{\"16\":1}}],[\"它可以是自底向上的聚合聚类\",{\"1\":{\"16\":1}}],[\"它可以结合\",{\"1\":{\"15\":1}}],[\"它可以用于调整模型的超参数和用于对模型的能力进行初步评估\",{\"1\":{\"10\":1}}],[\"相关信息\",{\"1\":{\"31\":1,\"57\":1}}],[\"相互作用\",{\"1\":{\"31\":1}}],[\"相同之处\",{\"1\":{\"12\":1}}],[\"相同点\",{\"1\":{\"11\":1,\"15\":1,\"17\":1}}],[\"相较于全连接层直接把图像展开成一个行向量\",{\"1\":{\"6\":1}}],[\"留出法\",{\"1\":{\"11\":1}}],[\"评估方法\",{\"1\":{\"11\":1}}],[\"经验\",{\"1\":{\"11\":1}}],[\"经过训练的网络也能给出合适的输出\",{\"1\":{\"10\":1}}],[\"错分样本的占比\",{\"1\":{\"11\":1}}],[\"错误率\",{\"1\":{\"11\":2}}],[\"错误率及误差概念\",{\"1\":{\"11\":1}}],[\"误差\",{\"1\":{\"11\":3}}],[\"扩大训练集\",{\"1\":{\"11\":1}}],[\"扩大感受野\",{\"1\":{\"6\":1}}],[\"神经网络与人脑相比计算特能力特点\",{\"1\":{\"14\":1}}],[\"神经网络根据是否存在网络回路\",{\"1\":{\"14\":1}}],[\"神经网络分类\",{\"1\":{\"14\":1}}],[\"神经网络\",{\"0\":{\"14\":1}}],[\"神经网络的训练轮数等\",{\"1\":{\"11\":1}}],[\"神经网络等\",{\"1\":{\"10\":1}}],[\"增长系数法\",{\"0\":{\"72\":1}}],[\"增加模型复杂度\",{\"1\":{\"11\":1}}],[\"增加新特征\",{\"1\":{\"11\":1}}],[\"增广训练集\",{\"1\":{\"11\":1}}],[\"让一些神经元以一定的概率不工作\",{\"1\":{\"11\":1}}],[\"让我顺利解决了很多问题\",{\"1\":{\"1\":1}}],[\"7\",{\"1\":{\"11\":1,\"12\":1,\"14\":1,\"62\":1}}],[\"6\",{\"1\":{\"11\":1,\"62\":2,\"63\":1}}],[\"约束模型特征\",{\"1\":{\"11\":1}}],[\"交叉验证法采用的是无放回的随机采样方式\",{\"1\":{\"11\":1}}],[\"交叉验证法和自助法都是随机采样法\",{\"1\":{\"11\":1}}],[\"交叉验证法和自助法异同\",{\"1\":{\"11\":1}}],[\"交叉验证法\",{\"1\":{\"11\":1}}],[\"交叉验证\",{\"1\":{\"11\":1}}],[\"交通规划模拟与分析\",{\"1\":{\"79\":1}}],[\"交通规划方案\",{\"1\":{\"76\":1}}],[\"交通术语\",{\"0\":{\"76\":1}}],[\"交通管理\",{\"1\":{\"56\":1}}],[\"交通方面的专业名词\",{\"1\":{\"4\":1}}],[\"交通方向的英文文献\",{\"1\":{\"4\":1}}],[\"交通\",{\"1\":{\"4\":1},\"2\":{\"23\":1,\"34\":1,\"38\":1,\"43\":1,\"48\":1,\"53\":1,\"65\":1,\"70\":1,\"73\":1}}],[\"清洗数据\",{\"1\":{\"11\":1}}],[\"拟合了不具代表性的特征\",{\"1\":{\"11\":1}}],[\"拟合模型\",{\"1\":{\"10\":1}}],[\"权值学习迭代次数过多\",{\"1\":{\"11\":1}}],[\"404\",{\"1\":{\"83\":1}}],[\"40\",{\"1\":{\"26\":1}}],[\"4\",{\"1\":{\"11\":3,\"13\":1,\"15\":3,\"16\":1,\"17\":1,\"62\":3,\"63\":1}}],[\"忽略了真实的输入输出\",{\"1\":{\"11\":1}}],[\"不含边界的距离矩阵\",{\"1\":{\"63\":1}}],[\"不含边界距离矩阵\",{\"1\":{\"62\":1}}],[\"不适合不规则形状和不同密度的簇\",{\"1\":{\"16\":1}}],[\"不需要\",{\"1\":{\"16\":1}}],[\"不需要预先指定簇数\",{\"1\":{\"16\":1}}],[\"不能撤消已做的处理\",{\"1\":{\"16\":1}}],[\"不能很好地处理大量多类特征或变量\",{\"1\":{\"15\":1}}],[\"不具有很好的可伸缩性\",{\"1\":{\"16\":1}}],[\"不受其影响\",{\"1\":{\"15\":1}}],[\"不同方法并非只适用于一个规模\",{\"1\":{\"56\":1}}],[\"不同\",{\"1\":{\"15\":1}}],[\"不同之处\",{\"1\":{\"12\":1}}],[\"不同点\",{\"1\":{\"11\":1,\"15\":1,\"17\":1}}],[\"不足\",{\"1\":{\"12\":1}}],[\"不匹配\",{\"1\":{\"11\":1}}],[\"不想走出舒适圈\",{\"1\":{\"1\":1}}],[\"与不占有\",{\"1\":{\"59\":1}}],[\"与\",{\"1\":{\"15\":1,\"62\":2,\"63\":1}}],[\"与没有隐藏层的效果相当\",{\"1\":{\"14\":1}}],[\"与模型复杂度\",{\"1\":{\"11\":1}}],[\"与图像对应元素进行点乘相加的操作\",{\"1\":{\"6\":1}}],[\"not\",{\"1\":{\"83\":1}}],[\"normalization\",{\"1\":{\"15\":1}}],[\"natural\",{\"1\":{\"78\":1}}],[\"n×n\",{\"1\":{\"63\":1}}],[\"n+1\",{\"1\":{\"63\":2}}],[\"n+2\",{\"1\":{\"62\":3,\"63\":1}}],[\"n+4\",{\"1\":{\"62\":2}}],[\"n=zeros\",{\"1\":{\"62\":1}}],[\"n=16\",{\"1\":{\"62\":1}}],[\"ni\",{\"1\":{\"60\":3}}],[\"ns模型\",{\"0\":{\"50\":1}}],[\"neigh\",{\"1\":{\"62\":1,\"63\":4}}],[\"neighbors\",{\"1\":{\"33\":1}}],[\"neighbor\",{\"1\":{\"33\":1}}],[\"neumann\",{\"1\":{\"26\":1,\"29\":2}}],[\"nv​\",{\"1\":{\"29\":1}}],[\"nm​\",{\"1\":{\"29\":1}}],[\"n^2\",{\"1\":{\"16\":1}}],[\"n\",{\"1\":{\"11\":1,\"16\":1,\"62\":4,\"63\":16}}],[\"欠拟合风险小\",{\"1\":{\"13\":1}}],[\"欠拟合应对\",{\"1\":{\"11\":1}}],[\"欠拟合原因\",{\"1\":{\"11\":1}}],[\"欠拟合\",{\"1\":{\"11\":1}}],[\"欠拟合定义\",{\"1\":{\"11\":1}}],[\"导致泛化性能下降\",{\"1\":{\"11\":1}}],[\"导数趋于\",{\"1\":{\"6\":1}}],[\"样本集较大时\",{\"1\":{\"16\":1}}],[\"样本真实输出与预测输出之间的差异\",{\"1\":{\"11\":1}}],[\"样本噪声过多\",{\"1\":{\"11\":1}}],[\"样本\",{\"1\":{\"11\":1}}],[\"潜在\",{\"1\":{\"11\":1}}],[\"将训练样本本身的特点当做所有\",{\"1\":{\"11\":1}}],[\"将数据对象进行特征\",{\"1\":{\"10\":1}}],[\"太好\",{\"1\":{\"11\":1}}],[\"过拟合原因\",{\"1\":{\"11\":1}}],[\"过拟合\",{\"1\":{\"11\":3}}],[\"过程中还遇到很多莫名其妙的小\",{\"1\":{\"1\":1}}],[\"二者都使用了极大似然估计对训练样本进行建模\",{\"1\":{\"12\":1}}],[\"二者在求解超参数的过程中都使用梯度下降的方法\",{\"1\":{\"12\":1}}],[\"二\",{\"0\":{\"11\":1}}],[\"为交通规划提供数据支持\",{\"1\":{\"79\":1}}],[\"为指标\",{\"1\":{\"60\":1}}],[\"为位置为\",{\"1\":{\"60\":2}}],[\"为元胞动态势能\",{\"1\":{\"60\":1}}],[\"为元胞静态势能\",{\"1\":{\"60\":1}}],[\"为什么要引入对偶问题\",{\"1\":{\"15\":1}}],[\"为什么通常要进行标准化处理\",{\"1\":{\"10\":1}}],[\"为了让我们的模型在测试集表现得更好\",{\"1\":{\"10\":1}}],[\"该游戏采用标准\",{\"1\":{\"32\":1}}],[\"该能力称为泛化能力\",{\"1\":{\"10\":1}}],[\"该规律不仅适用于训练数据\",{\"1\":{\"10\":1}}],[\"什么是回归\",{\"1\":{\"12\":1}}],[\"什么是泛化性能\",{\"1\":{\"10\":1}}],[\"什么是机器学习和深度学习\",{\"1\":{\"10\":1}}],[\"确认网络的实际预测能力\",{\"1\":{\"10\":1}}],[\"仅仅用来评估模最终模型的泛化能力\",{\"1\":{\"10\":1}}],[\"然后在\",{\"1\":{\"63\":1}}],[\"然后决定怎么调整我们的超参数\",{\"1\":{\"10\":1}}],[\"然后再来调整参数\",{\"1\":{\"10\":1}}],[\"监控模型是否正常\",{\"1\":{\"10\":1}}],[\"监督学习和非监督学习常常结合使用\",{\"1\":{\"10\":1}}],[\"监督学习和非监督学习是机器学习中两种不同的学习方式\",{\"1\":{\"10\":1}}],[\"监督学习需要已知的输入和输出数据\",{\"1\":{\"10\":1}}],[\"监督学习不具备\",{\"1\":{\"10\":1}}],[\"监督学习关注与标签或已知输出的误差\",{\"1\":{\"10\":1}}],[\"监督学习有反馈\",{\"1\":{\"10\":1}}],[\"监督学习通常用于分类\",{\"1\":{\"10\":1}}],[\"监督学习\",{\"1\":{\"10\":2,\"14\":1}}],[\"调参去拟合测试集合\",{\"1\":{\"10\":1}}],[\"调参是不可避免地一部分\",{\"1\":{\"10\":1}}],[\"调整网络权重\",{\"1\":{\"10\":1}}],[\"选择新位置已占\",{\"1\":{\"63\":1}}],[\"选择下一位置\",{\"1\":{\"63\":1}}],[\"选择样本点投影具有最大方差的方向\",{\"1\":{\"17\":1}}],[\"选择分类性能最好的投影方向\",{\"1\":{\"17\":1}}],[\"选择合适的核函数和参数是一个挑战\",{\"1\":{\"15\":1}}],[\"选择超参数\",{\"1\":{\"10\":1}}],[\"选择特征等算法相关的选择的依据\",{\"1\":{\"10\":1}}],[\"等类型\",{\"1\":{\"28\":1}}],[\"等\",{\"1\":{\"10\":1}}],[\"等函数\",{\"1\":{\"6\":1}}],[\"rail\",{\"1\":{\"76\":2}}],[\"rate\",{\"1\":{\"10\":1}}],[\"road\",{\"1\":{\"76\":2}}],[\"roadways\",{\"1\":{\"76\":1}}],[\"real\",{\"1\":{\"79\":2}}],[\"reading\",{\"0\":{\"75\":1}}],[\"recognition\",{\"1\":{\"78\":1}}],[\"regulations\",{\"1\":{\"76\":1}}],[\"refer\",{\"1\":{\"76\":1}}],[\"refers\",{\"1\":{\"76\":2}}],[\"repmat\",{\"1\":{\"62\":1}}],[\"repelem\",{\"1\":{\"62\":1}}],[\"relu\",{\"1\":{\"6\":4}}],[\"r=1\",{\"1\":{\"59\":1}}],[\"rules\",{\"1\":{\"33\":2}}],[\"rbf\",{\"1\":{\"15\":1}}],[\"language\",{\"1\":{\"78\":1}}],[\"layout\",{\"1\":{\"56\":1}}],[\"l\",{\"1\":{\"63\":1}}],[\"l=zeros\",{\"1\":{\"62\":1}}],[\"light\",{\"1\":{\"76\":1}}],[\"lij\",{\"1\":{\"63\":1}}],[\"li\",{\"1\":{\"60\":1,\"63\":1}}],[\"l2\",{\"1\":{\"15\":1}}],[\"lr\",{\"1\":{\"15\":5}}],[\"loss\",{\"1\":{\"15\":1}}],[\"logistic\",{\"1\":{\"15\":2}}],[\"lol\",{\"1\":{\"3\":2}}],[\"lda\",{\"1\":{\"12\":1,\"17\":5}}],[\"learning\",{\"1\":{\"10\":1,\"78\":3}}],[\"en\",{\"0\":{\"91\":1}}],[\"english\",{\"0\":{\"88\":1}}],[\"engineering\",{\"0\":{\"80\":1,\"81\":1}}],[\"enabling\",{\"1\":{\"78\":1,\"79\":1}}],[\"entire\",{\"1\":{\"76\":1}}],[\"encompasses\",{\"1\":{\"76\":1}}],[\"end\",{\"1\":{\"62\":11,\"63\":14}}],[\"else\",{\"1\":{\"63\":1}}],[\"exp\",{\"1\":{\"63\":1}}],[\"extensive\",{\"1\":{\"56\":1}}],[\"ei\",{\"1\":{\"60\":2}}],[\"evacuation\",{\"1\":{\"56\":1}}],[\"every\",{\"1\":{\"33\":1}}],[\"each\",{\"1\":{\"33\":2}}],[\"early\",{\"1\":{\"11\":1}}],[\"epoch\",{\"1\":{\"10\":2}}],[\"edge\",{\"0\":{\"77\":1}}],[\"edg\",{\"1\":{\"3\":1}}],[\"网络节点数\",{\"1\":{\"10\":1}}],[\"网络层数\",{\"1\":{\"10\":1}}],[\"快速调参\",{\"1\":{\"10\":1}}],[\"各数据集的作用\",{\"1\":{\"10\":1}}],[\"用函数表示如下\",{\"1\":{\"32\":1}}],[\"用来评估模最终模型的泛化能力\",{\"1\":{\"10\":1}}],[\"用于模型拟合的数据样本\",{\"1\":{\"10\":1}}],[\"i+neigh\",{\"1\":{\"63\":1}}],[\"if\",{\"1\":{\"63\":3}}],[\"i=2\",{\"1\":{\"63\":1}}],[\"i=1\",{\"1\":{\"63\":2}}],[\"i\",{\"1\":{\"60\":5,\"62\":7,\"63\":17}}],[\"it\",{\"1\":{\"33\":1,\"56\":1,\"76\":4,\"79\":1}}],[\"issues\",{\"1\":{\"79\":1}}],[\"is\",{\"1\":{\"21\":1,\"22\":1,\"33\":1,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"51\":1,\"52\":1,\"68\":1,\"69\":1,\"76\":4}}],[\"ica\",{\"1\":{\"10\":1}}],[\"involved\",{\"1\":{\"76\":1}}],[\"including\",{\"1\":{\"76\":1,\"78\":1,\"79\":1}}],[\"includes\",{\"1\":{\"33\":1,\"76\":1}}],[\"integrates\",{\"1\":{\"79\":1}}],[\"interactions\",{\"1\":{\"76\":1}}],[\"introduction\",{\"0\":{\"0\":1}}],[\"infrastructure\",{\"1\":{\"76\":1}}],[\"inf\",{\"1\":{\"63\":1}}],[\"infj\",{\"1\":{\"3\":1}}],[\"in\",{\"1\":{\"33\":2,\"56\":2,\"76\":2,\"79\":1}}],[\"独立成分分析\",{\"1\":{\"10\":1}}],[\"朴素贝叶斯\",{\"1\":{\"10\":1}}],[\"支持向量机采用核函数的机制\",{\"1\":{\"15\":1}}],[\"支持向量机只考虑局部的边界线附近的点\",{\"1\":{\"15\":1}}],[\"支持向量机\",{\"0\":{\"15\":1},\"1\":{\"10\":1}}],[\"决策树各自优缺点\",{\"1\":{\"15\":1}}],[\"决策树中剪枝方式分为哪两种\",{\"1\":{\"13\":1}}],[\"决策树三种导致递归返回的情况\",{\"1\":{\"13\":1}}],[\"决策树\",{\"0\":{\"13\":1},\"1\":{\"10\":1,\"15\":1}}],[\"决定写\",{\"1\":{\"2\":1}}],[\"逻辑回归的性能不是很好\",{\"1\":{\"15\":1}}],[\"逻辑回归的缺点\",{\"1\":{\"15\":1}}],[\"逻辑回归的优点\",{\"1\":{\"15\":1}}],[\"逻辑回归广泛的应用于工业问题上\",{\"1\":{\"15\":1}}],[\"逻辑回归解决的是分类问题\",{\"1\":{\"12\":1}}],[\"逻辑回归和线性回归的异同\",{\"1\":{\"12\":1}}],[\"逻辑回归\",{\"1\":{\"10\":1,\"15\":1}}],[\"举例\",{\"1\":{\"10\":1}}],[\"变分自编码器等\",{\"1\":{\"10\":1}}],[\"变量\",{\"1\":{\"10\":1}}],[\"变换太缓慢\",{\"1\":{\"6\":1}}],[\"和线性判别分析\",{\"1\":{\"17\":1}}],[\"和层次聚类通常需要额外的后处理步骤来处理噪声点\",{\"1\":{\"16\":1}}],[\"和\",{\"1\":{\"14\":1,\"15\":3,\"60\":1}}],[\"和原始数据集\",{\"1\":{\"11\":1}}],[\"和输出之间的映射关系\",{\"1\":{\"10\":1}}],[\"和回归\",{\"1\":{\"10\":1}}],[\"并进行归一化处理\",{\"1\":{\"63\":1}}],[\"并行性\",{\"1\":{\"31\":1}}],[\"并以负梯度方向为搜索方向\",{\"1\":{\"14\":1}}],[\"并严格划分训练集与测试集的界限\",{\"1\":{\"11\":1}}],[\"并分别给出监督和非监督学习的两种算法\",{\"1\":{\"10\":1}}],[\"并且减少了参数的相互依存关系\",{\"1\":{\"6\":1}}],[\"有人\",{\"1\":{\"63\":1}}],[\"有时候很难找到一个合适的核函数\",{\"1\":{\"15\":1}}],[\"有时间也会加入书评\",{\"1\":{\"4\":1}}],[\"有导师的学习\",{\"1\":{\"14\":1}}],[\"有欠拟合风险\",{\"1\":{\"13\":1}}],[\"有些分支当前划分虽然不能提升泛化性能\",{\"1\":{\"13\":1}}],[\"有和环境交互的能力\",{\"1\":{\"10\":1}}],[\"区别\",{\"1\":{\"10\":2,\"16\":2}}],[\"使得在高维特征空间中数据变得线性可分\",{\"1\":{\"15\":1}}],[\"使得所有的特征具有同样的尺度\",{\"1\":{\"10\":1}}],[\"使用最小二乘法求解线性回归时我们认为因变量服从正态分布\",{\"1\":{\"12\":1}}],[\"使系统行为从环境中获得的累积奖励值最大的一种机器学习方法\",{\"1\":{\"10\":1}}],[\"使不断改善自身的性能\",{\"1\":{\"10\":1}}],[\"是为了让最外围元胞能够有像内部元胞一样的邻域条件所创建的虚拟元胞\",{\"1\":{\"30\":1}}],[\"是否为邻居\",{\"1\":{\"29\":1}}],[\"是模型迭代的直接参与者\",{\"1\":{\"27\":1}}],[\"是自动机理论\",{\"1\":{\"26\":1}}],[\"是无监督的降维方法\",{\"1\":{\"17\":1}}],[\"是有监督的降维方法\",{\"1\":{\"17\":1}}],[\"是指机器学习算法对新鲜样本的适应能力\",{\"1\":{\"10\":1}}],[\"是指从环境状态到行为映射的学习\",{\"1\":{\"10\":1}}],[\"是不可行地\",{\"1\":{\"10\":1}}],[\"是一种在没有标签或目标的情况下\",{\"1\":{\"10\":1}}],[\"是一种通过使用已知输出来训练模型的学习方式\",{\"1\":{\"10\":1}}],[\"又称为再励学习\",{\"1\":{\"10\":1}}],[\"异常检测等操作\",{\"1\":{\"10\":1}}],[\"问题描述\",{\"0\":{\"57\":1}}],[\"问题\",{\"1\":{\"10\":1}}],[\"以帮助开发更为智能的决策制定算法\",{\"1\":{\"79\":1}}],[\"以个体为研究对象\",{\"1\":{\"56\":1}}],[\"以整个人群为研究对象\",{\"1\":{\"56\":1}}],[\"以找到最佳的分类效果\",{\"1\":{\"15\":1}}],[\"以达到抽取分类信息和压缩特征空间维数的效果\",{\"1\":{\"12\":1}}],[\"以提高机器学习的效果和性能\",{\"1\":{\"10\":1}}],[\"以便对数据进行聚类\",{\"1\":{\"10\":1}}],[\"以预测新的输入数据的输出\",{\"1\":{\"10\":1}}],[\"以获取新的知识或技能\",{\"1\":{\"10\":1}}],[\"也就是通过验证集我们可以选择超参数\",{\"1\":{\"10\":1}}],[\"也称为标签或目标\",{\"1\":{\"10\":1}}],[\"也适用于未知数据\",{\"1\":{\"10\":1}}],[\"定义为\",{\"1\":{\"60\":1}}],[\"定义\",{\"0\":{\"26\":1},\"1\":{\"10\":1,\"11\":1}}],[\"简单且高效\",{\"1\":{\"16\":1}}],[\"简单明了\",{\"1\":{\"15\":1}}],[\"简要介绍卷积概念及其作用\",{\"1\":{\"14\":1}}],[\"简要说明监督学习和非监督学习之间的区别\",{\"1\":{\"10\":1}}],[\"简述神经网络中梯度下降方法的原理和作用\",{\"1\":{\"14\":1}}],[\"简述神经网络的学习过程\",{\"1\":{\"14\":1}}],[\"简述\",{\"1\":{\"12\":1}}],[\"简述监督学习\",{\"1\":{\"10\":1}}],[\"简介\",{\"0\":{\"0\":1}}],[\"关系见下\",{\"1\":{\"10\":1}}],[\"强化学习是一个学习+决策的过程\",{\"1\":{\"10\":1}}],[\"强化学习的奖惩概念没有正确和错误之分\",{\"1\":{\"10\":1}}],[\"强化学习的目标与监督学习目标不同\",{\"1\":{\"10\":1}}],[\"强化学习看重行为序列下的长期收益\",{\"1\":{\"10\":1}}],[\"强化学习执行多步后反馈\",{\"1\":{\"10\":1}}],[\"强化学习\",{\"1\":{\"10\":2,\"14\":1}}],[\"会发散或振荡\",{\"1\":{\"10\":1}}],[\"会使一部分神经元的输出为\",{\"1\":{\"6\":1}}],[\"表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界\",{\"1\":{\"11\":1}}],[\"表征了参数每次更新的幅度\",{\"1\":{\"10\":1}}],[\"表示边界条件\",{\"1\":{\"62\":1}}],[\"表示\",{\"1\":{\"10\":1}}],[\"学习器把训练样本学习的\",{\"1\":{\"11\":1}}],[\"学习的目的是学到隐含在数据背后的规律\",{\"1\":{\"10\":1}}],[\"学习率\",{\"1\":{\"10\":1}}],[\"学习率过小\",{\"1\":{\"10\":1}}],[\"学习率过大\",{\"1\":{\"10\":1}}],[\"学习率也叫步长\",{\"1\":{\"10\":1}}],[\"学习率太大和太小的可能影响\",{\"1\":{\"10\":1}}],[\"学习率这种参数叫什么\",{\"1\":{\"10\":1}}],[\"学过的知识都记不清了\",{\"1\":{\"2\":1}}],[\"利用学到的模型进行预测\",{\"1\":{\"10\":1}}],[\"测试误差\",{\"1\":{\"11\":1}}],[\"测试集上\",{\"1\":{\"11\":1}}],[\"测试集的作用\",{\"1\":{\"10\":1}}],[\"测试集\",{\"1\":{\"10\":2}}],[\"测试\",{\"1\":{\"10\":1}}],[\"称为泛化能力\",{\"1\":{\"10\":1}}],[\"目标是从数据中发现模式和结构\",{\"1\":{\"10\":1}}],[\"目标是学习输入\",{\"1\":{\"10\":1}}],[\"目标是找到输入数据之间的相似性和区别\",{\"1\":{\"10\":1}}],[\"目标\",{\"1\":{\"10\":1}}],[\"目前的系统往往在特定场景下表现良好\",{\"1\":{\"79\":1}}],[\"目前博客内容主要为过去做过的一些项目\",{\"1\":{\"4\":1}}],[\"目前小小的愿望清单\",{\"1\":{\"3\":1}}],[\"目前先尝试一个\",{\"1\":{\"2\":1}}],[\"目前还是处于入门小白阶段\",{\"1\":{\"1\":1}}],[\"从概念上就可以理解元胞就好似生物体的细胞\",{\"1\":{\"27\":1}}],[\"从数据中发现模式或结构的学习方式\",{\"1\":{\"10\":1}}],[\"从中学习出规律\",{\"1\":{\"10\":1}}],[\"从而实现每一次迭代的整体更新\",{\"1\":{\"63\":1}}],[\"从而引起全局的变化\",{\"1\":{\"31\":1}}],[\"从而推广到非线性分类问题\",{\"1\":{\"15\":1}}],[\"从而增强测试评估的稳定性和可靠性\",{\"1\":{\"11\":1}}],[\"从而评价模型在数据集上的表现\",{\"1\":{\"11\":1}}],[\"从而无法完成深层网络的训练\",{\"1\":{\"6\":1}}],[\"从而使模型可以抽取更加广范围的特征\",{\"1\":{\"6\":1}}],[\"训练时间开销大\",{\"1\":{\"13\":1}}],[\"训练样本过少\",{\"1\":{\"11\":1}}],[\"训练样本的一般性质尚未学好\",{\"1\":{\"11\":1}}],[\"训练集上的效果高度优于测试集\",{\"1\":{\"15\":1}}],[\"训练集上\",{\"1\":{\"11\":1}}],[\"训练集与测试集的特征分布不一致\",{\"1\":{\"11\":1}}],[\"训练集的数量级\",{\"1\":{\"11\":1}}],[\"训练集的作用\",{\"1\":{\"10\":1}}],[\"训练集\",{\"1\":{\"10\":2}}],[\"训练数据包括输入数据和对应的输出数据\",{\"1\":{\"10\":1}}],[\"训练\",{\"1\":{\"10\":1,\"11\":1}}],[\"f\",{\"1\":{\"63\":6}}],[\"f=1\",{\"1\":{\"63\":1}}],[\"found\",{\"1\":{\"83\":1}}],[\"foudation\",{\"1\":{\"78\":2}}],[\"fomular\",{\"1\":{\"79\":1}}],[\"focused\",{\"1\":{\"76\":1}}],[\"formal\",{\"1\":{\"76\":1}}],[\"format\",{\"1\":{\"62\":1}}],[\"for\",{\"1\":{\"62\":1,\"63\":11,\"76\":1,\"79\":2}}],[\"force\",{\"1\":{\"56\":1}}],[\"follows\",{\"1\":{\"33\":1}}],[\"flow\",{\"1\":{\"76\":1}}],[\"fluid\",{\"1\":{\"56\":1}}],[\"flame\",{\"1\":{\"3\":1}}],[\"fine\",{\"1\":{\"78\":1}}],[\"final\",{\"1\":{\"62\":4,\"63\":8}}],[\"finds\",{\"1\":{\"56\":1}}],[\"five\",{\"1\":{\"33\":1}}],[\"function\",{\"1\":{\"15\":1}}],[\"feature\",{\"1\":{\"10\":1}}],[\"重新组织已有的知识结构\",{\"1\":{\"10\":1}}],[\"希望机器通过学习的手段\",{\"1\":{\"10\":1}}],[\"人群中每个个体有着相同的行为特征\",{\"1\":{\"56\":1}}],[\"人工智能是想要达成的目标\",{\"1\":{\"10\":1}}],[\"人格\",{\"1\":{\"3\":1}}],[\"绪论\",{\"0\":{\"10\":1}}],[\"缓解了过拟合问题的发生\",{\"1\":{\"6\":1}}],[\"这些提示用于指导视频内容的生成\",{\"1\":{\"79\":1}}],[\"这些特征的量纲和数量级都是不一样的\",{\"1\":{\"10\":1}}],[\"这段代码思想为用一个\",{\"1\":{\"63\":1}}],[\"这里用\",{\"1\":{\"63\":1}}],[\"这里因为有四个入口\",{\"1\":{\"63\":1}}],[\"这里设置了\",{\"1\":{\"62\":1}}],[\"这里以位置为\",{\"1\":{\"60\":1}}],[\"这里主要考虑为出口与障碍物\",{\"1\":{\"60\":1}}],[\"这里引入元胞潜能\",{\"1\":{\"60\":1}}],[\"这三种\",{\"1\":{\"56\":1}}],[\"这一点很重要\",{\"1\":{\"15\":1}}],[\"这个超平面需要满足离其最近的点到其的距离最大化\",{\"1\":{\"15\":1}}],[\"这是两者最本质的区别\",{\"1\":{\"12\":1}}],[\"这种情况就是最原始的感知机\",{\"1\":{\"14\":1}}],[\"这种情况会造成信息丢失\",{\"1\":{\"6\":1}}],[\"这种方式可以保持数据分布的一致性条件\",{\"1\":{\"11\":1}}],[\"这两种方法最大的不同点在于每次划分过程中每个样本点是否只有一次被划入训练集或测试集的机会\",{\"1\":{\"11\":1}}],[\"这时需要对数据进行标准化处理\",{\"1\":{\"10\":1}}],[\"这样子时间代价较高\",{\"1\":{\"10\":1}}],[\"这样就造成了网络的稀疏性\",{\"1\":{\"6\":1}}],[\"这相当于作弊\",{\"1\":{\"10\":1}}],[\"接近饱和区时\",{\"1\":{\"6\":1}}],[\"函数反向传播时\",{\"1\":{\"6\":1}}],[\"第五章\",{\"1\":{\"14\":3}}],[\"第四章\",{\"1\":{\"13\":1}}],[\"第三章\",{\"1\":{\"12\":3}}],[\"第三\",{\"1\":{\"6\":1}}],[\"第二\",{\"1\":{\"6\":1}}],[\"第一\",{\"1\":{\"6\":1}}],[\"整个过程的计算量节省很多\",{\"1\":{\"6\":1}}],[\"而层次聚类较慢\",{\"1\":{\"16\":1}}],[\"而层次聚类和\",{\"1\":{\"16\":1}}],[\"而\",{\"1\":{\"15\":1,\"17\":3}}],[\"而逻辑回归考虑全局\",{\"1\":{\"15\":1}}],[\"而线性回归解决的是回归问题\",{\"1\":{\"12\":1}}],[\"而且方差较小\",{\"1\":{\"11\":1}}],[\"而且复习过程中也苦于没有地方整理\",{\"1\":{\"2\":1}}],[\"而不需要预先定义的目标\",{\"1\":{\"10\":1}}],[\"而监督学习的标签是正确的\",{\"1\":{\"10\":1}}],[\"而深度学习\",{\"1\":{\"10\":1}}],[\"而机器学习是想要达成目标的手段\",{\"1\":{\"10\":1}}],[\"而采用\",{\"1\":{\"6\":1}}],[\"反应人流变化的方向与源头\",{\"1\":{\"63\":1}}],[\"反应平台实时状态\",{\"1\":{\"62\":1}}],[\"反应了元胞有人占据\",{\"1\":{\"60\":1}}],[\"反向传播求误差梯度时\",{\"1\":{\"6\":1}}],[\"反卷积\",{\"1\":{\"6\":1}}],[\"指更新参数步幅\",{\"1\":{\"10\":1}}],[\"指数运算\",{\"1\":{\"6\":1}}],[\"指南\",{\"0\":{\"4\":1}}],[\"算激活函数时\",{\"1\":{\"6\":1}}],[\"算法\",{\"0\":{\"20\":1,\"35\":1}}],[\"算法将数据划分为\",{\"1\":{\"16\":1}}],[\"算法的基本思想及算法流程\",{\"1\":{\"12\":1}}],[\"算法只能使用输入数据进行学习\",{\"1\":{\"10\":1}}],[\"算法通过学习这些数据\",{\"1\":{\"10\":1}}],[\"算法整理\",{\"1\":{\"4\":1}}],[\"算法讲解与实现\",{\"1\":{\"4\":1}}],[\"采用固定型\",{\"1\":{\"59\":1}}],[\"采用基本\",{\"1\":{\"59\":1}}],[\"采用\",{\"1\":{\"6\":1}}],[\"采用原因\",{\"1\":{\"6\":1}}],[\"正六边形\",{\"1\":{\"28\":1}}],[\"正方形\",{\"1\":{\"28\":1}}],[\"正则化来解决\",{\"1\":{\"15\":1}}],[\"正则化\",{\"1\":{\"11\":1}}],[\"正\",{\"1\":{\"6\":1}}],[\"负为\",{\"1\":{\"6\":1}}],[\"激活函数是神经网络的一个重要组成部分\",{\"1\":{\"14\":1}}],[\"激活函数可以加入非线性因素\",{\"1\":{\"14\":1}}],[\"激活函数\",{\"1\":{\"6\":2}}],[\"的平台上\",{\"1\":{\"63\":1}}],[\"的计算\",{\"1\":{\"63\":2}}],[\"的元胞周围空元胞数目\",{\"1\":{\"60\":1}}],[\"的元胞周边的非障碍数目\",{\"1\":{\"60\":1}}],[\"的元胞距出口的距离\",{\"1\":{\"60\":1}}],[\"的格子\",{\"1\":{\"32\":2}}],[\"的维数\",{\"1\":{\"17\":1}}],[\"的维度\",{\"1\":{\"15\":1}}],[\"的缺点\",{\"1\":{\"15\":1}}],[\"的优点\",{\"1\":{\"15\":1}}],[\"的损失函数就自带正则\",{\"1\":{\"15\":1}}],[\"的原理\",{\"1\":{\"15\":1}}],[\"的微分值\",{\"1\":{\"14\":1}}],[\"的一般性质\",{\"1\":{\"11\":1}}],[\"的卷积\",{\"1\":{\"6\":1}}],[\"的想法\",{\"1\":{\"1\":1}}],[\"2×n\",{\"1\":{\"63\":1}}],[\"20\",{\"1\":{\"26\":1,\"62\":2}}],[\"2\",{\"0\":{\"21\":1,\"36\":1,\"41\":1,\"46\":1,\"51\":1,\"68\":1},\"1\":{\"6\":1,\"10\":3,\"11\":6,\"12\":5,\"15\":6,\"16\":1,\"17\":2,\"31\":1,\"32\":1,\"62\":10,\"63\":24,\"79\":1}}],[\"缩小图像\",{\"1\":{\"6\":1}}],[\"转置卷积\",{\"1\":{\"6\":1}}],[\"类似栅格化\",{\"1\":{\"28\":1}}],[\"类似\",{\"1\":{\"6\":1}}],[\"实现非线性\",{\"1\":{\"6\":1}}],[\"在应急响应规划中\",{\"1\":{\"79\":1}}],[\"在复杂环境中做出快速决策的\",{\"1\":{\"79\":1}}],[\"在外围补上固定不变的\",{\"1\":{\"30\":1}}],[\"在二维空间下\",{\"1\":{\"29\":1}}],[\"在处理噪声点时比较鲁棒\",{\"1\":{\"16\":1}}],[\"在对偶问题下\",{\"1\":{\"15\":1}}],[\"在原始问题下\",{\"1\":{\"15\":1}}],[\"在解决非线性问题时\",{\"1\":{\"15\":1}}],[\"在神经网络中\",{\"1\":{\"14\":1}}],[\"在自变量和超参数确定的情况下逻辑回归可看作广义的线性模型在因变量下服从二元分布的一个特殊情况\",{\"1\":{\"12\":1}}],[\"在训练样本上都存在较大的经验误差\",{\"1\":{\"11\":1}}],[\"在实际问题中\",{\"1\":{\"10\":1}}],[\"在实际应用中\",{\"1\":{\"10\":1}}],[\"在数据处理时\",{\"1\":{\"10\":1}}],[\"在非监督学习中\",{\"1\":{\"10\":1}}],[\"在监督学习中\",{\"1\":{\"10\":1}}],[\"在机器学习中\",{\"1\":{\"10\":1}}],[\"在\",{\"1\":{\"6\":1,\"62\":2}}],[\"在一定程度上防止过拟合\",{\"1\":{\"6\":1}}],[\"在此表示十分感谢\",{\"1\":{\"1\":1}}],[\"进而减少计算量和参数个数\",{\"1\":{\"6\":1}}],[\"进入到梦中情组\",{\"1\":{\"3\":1}}],[\"下面将分别做进一步阐述\",{\"1\":{\"26\":1}}],[\"下面将针对这方面详细展开论述\",{\"1\":{\"11\":1}}],[\"下面来\",{\"1\":{\"1\":1}}],[\"下采样\",{\"1\":{\"6\":2}}],[\"后剪枝过程是在生成完全的决策树之后\",{\"1\":{\"13\":1}}],[\"后剪枝\",{\"1\":{\"13\":1}}],[\"后查看模型的训练效果及我们的网络是否出现异常\",{\"1\":{\"10\":1}}],[\"后\",{\"1\":{\"6\":1}}],[\"尺度变换\",{\"1\":{\"6\":1}}],[\"那么经过伸缩\",{\"1\":{\"6\":1}}],[\"输出的结果仍将为\",{\"1\":{\"6\":1}}],[\"输入为\",{\"1\":{\"6\":1}}],[\"0\",{\"0\":{\"67\":1},\"1\":{\"6\":4,\"16\":1,\"27\":1,\"32\":1,\"33\":1,\"59\":1,\"60\":2,\"62\":6}}],[\"3\",{\"0\":{\"22\":1,\"37\":1,\"42\":1,\"47\":1,\"52\":1,\"69\":1},\"1\":{\"6\":1,\"10\":3,\"11\":6,\"12\":4,\"15\":5,\"16\":1,\"17\":2,\"32\":2,\"62\":2,\"63\":14}}],[\"5\",{\"1\":{\"6\":6,\"11\":2,\"15\":1,\"62\":1,\"63\":4}}],[\"1规划模型最短路\",{\"0\":{\"67\":1}}],[\"1e10\",{\"1\":{\"63\":1}}],[\"11\",{\"1\":{\"62\":1}}],[\"12\",{\"1\":{\"62\":1}}],[\"16\",{\"1\":{\"62\":1}}],[\"16×30\",{\"1\":{\"57\":1}}],[\"14\",{\"1\":{\"62\":2}}],[\"13\",{\"1\":{\"62\":1}}],[\"10\",{\"1\":{\"62\":1}}],[\"1×4\",{\"1\":{\"57\":1}}],[\"1×1\",{\"1\":{\"57\":3}}],[\"1970\",{\"1\":{\"32\":1}}],[\"1\",{\"1\":{\"6\":2,\"10\":3,\"11\":6,\"12\":3,\"13\":1,\"15\":6,\"16\":1,\"17\":3,\"26\":1,\"27\":1,\"32\":2,\"33\":1,\"59\":1,\"60\":1,\"62\":29,\"63\":31,\"79\":1}}],[\"例如\",{\"1\":{\"6\":1}}],[\"旋转不变性和尺度不变性\",{\"1\":{\"6\":1}}],[\"池化的作用是什么\",{\"1\":{\"14\":1}}],[\"池化相当于在空间范围内做了维度约减\",{\"1\":{\"6\":1}}],[\"池化操作是模型更加关注是否存在某些特征而不是特征具体的位置\",{\"1\":{\"6\":1}}],[\"池化层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象\",{\"1\":{\"6\":1}}],[\"池化\",{\"1\":{\"6\":1}}],[\"任何全连接层都能被转换为一个等价卷积层\",{\"1\":{\"6\":1}}],[\"其定义如下\",{\"1\":{\"60\":1}}],[\"其他方法还有网络模型\",{\"1\":{\"56\":1}}],[\"其在城市规划\",{\"1\":{\"56\":1}}],[\"其元胞规则为\",{\"1\":{\"32\":1}}],[\"其状态可能是死亡\",{\"1\":{\"32\":1}}],[\"其中\",{\"1\":{\"16\":1,\"60\":2}}],[\"其中不变形性包括\",{\"1\":{\"6\":1}}],[\"其采用的是有放回的随机抽样方法\",{\"1\":{\"11\":1}}],[\"其能更好地捕获图像的空间特征\",{\"1\":{\"6\":1}}],[\"其实很早就萌生过写\",{\"1\":{\"1\":1}}],[\"卷积前后图像尺寸之间的关系是什么\",{\"1\":{\"14\":1}}],[\"卷积本质上也是一种对数据维度的变换\",{\"1\":{\"6\":1}}],[\"卷积核\",{\"1\":{\"6\":1}}],[\"卷积就是用一个可移动的窗口\",{\"1\":{\"6\":1}}],[\"卷积\",{\"0\":{\"5\":1},\"1\":{\"6\":1}}],[\"感谢你看到这里\",{\"1\":{\"4\":1}}],[\"❤️\",{\"1\":{\"4\":2}}],[\"博主的自我介绍\",{\"1\":{\"4\":1}}],[\"总结自己参加数模比赛过程中\",{\"1\":{\"4\":1}}],[\"笔记及代码\",{\"1\":{\"4\":1}}],[\"机器学习三个主要分类是什么\",{\"1\":{\"10\":1}}],[\"机器学习流程\",{\"1\":{\"10\":1}}],[\"机器学习是研究计算机怎样模拟或实现人类的学习行为\",{\"1\":{\"10\":1}}],[\"机器学习是一种实现人工智能的方法\",{\"1\":{\"10\":1}}],[\"机器学习\",{\"0\":{\"8\":1},\"1\":{\"4\":1}}],[\"如预训练\",{\"1\":{\"78\":1}}],[\"如图一所示\",{\"1\":{\"29\":1}}],[\"如\",{\"1\":{\"27\":1,\"56\":1}}],[\"如决策树的扩展分支\",{\"1\":{\"11\":1}}],[\"如池化与步长为\",{\"1\":{\"6\":1}}],[\"如果选择的位置被占\",{\"1\":{\"63\":1}}],[\"如果上下和前面三个位置共\",{\"1\":{\"63\":1}}],[\"如果位置\",{\"1\":{\"63\":1}}],[\"如果你还不了解\",{\"1\":{\"55\":1}}],[\"如果某一步没有很好地选择合并或分裂的决定\",{\"1\":{\"16\":1}}],[\"如果不考虑核函数\",{\"1\":{\"15\":1}}],[\"如果不使用激活函数\",{\"1\":{\"14\":1}}],[\"如果没有设置验证集\",{\"1\":{\"10\":1}}],[\"如果把测试集当验证集\",{\"1\":{\"10\":1}}],[\"如果原先的神经元在最大池化操作后输出\",{\"1\":{\"6\":1}}],[\"如果将输入右移一位得到\",{\"1\":{\"6\":1}}],[\"如果之前有所记录就很便于回忆\",{\"1\":{\"2\":1}}],[\"如常见模型\",{\"1\":{\"4\":1}}],[\"乐评\",{\"1\":{\"4\":1}}],[\"自动驾驶系统所需具良好的泛化能力\",{\"1\":{\"79\":1}}],[\"自然模型\",{\"1\":{\"56\":1}}],[\"自底向上对所有非叶节点逐一考察\",{\"1\":{\"13\":1}}],[\"自助法主要面向数据集同规模的划分问题\",{\"1\":{\"11\":1}}],[\"自助法等\",{\"1\":{\"11\":1}}],[\"自编码器\",{\"1\":{\"10\":1}}],[\"自学内容的整理等\",{\"1\":{\"4\":1}}],[\"自我感觉是一个矛盾体\",{\"1\":{\"3\":1}}],[\"自我评价\",{\"1\":{\"3\":1}}],[\"小研究\",{\"1\":{\"4\":1}}],[\"国足进世界杯\",{\"1\":{\"3\":1}}],[\"国家队比赛\",{\"1\":{\"3\":1}}],[\"统一\",{\"1\":{\"3\":1}}],[\"tasks\",{\"1\":{\"78\":1}}],[\"talk\",{\"1\":{\"1\":1}}],[\"tuning\",{\"1\":{\"78\":1}}],[\"tec\",{\"0\":{\"90\":1}}],[\"techniques\",{\"1\":{\"78\":1}}],[\"technology\",{\"0\":{\"77\":1}}],[\"test\",{\"1\":{\"79\":1}}],[\"text\",{\"1\":{\"79\":1}}],[\"term\",{\"1\":{\"76\":1}}],[\"terminology\",{\"0\":{\"76\":1}}],[\"that\",{\"1\":{\"76\":4,\"79\":1}}],[\"them\",{\"1\":{\"78\":1}}],[\"these\",{\"1\":{\"78\":1}}],[\"thereby\",{\"1\":{\"33\":1}}],[\"their\",{\"1\":{\"33\":1}}],[\"theory\",{\"0\":{\"82\":1,\"93\":1},\"1\":{\"26\":1,\"33\":1}}],[\"the\",{\"1\":{\"21\":1,\"22\":1,\"33\":3,\"36\":1,\"37\":1,\"41\":1,\"42\":1,\"46\":1,\"47\":1,\"51\":1,\"52\":1,\"56\":1,\"68\":1,\"69\":1,\"76\":11,\"79\":2}}],[\"to\",{\"1\":{\"76\":5,\"78\":1,\"79\":2}}],[\"total\",{\"1\":{\"62\":1}}],[\"total=960\",{\"1\":{\"62\":1}}],[\"training\",{\"1\":{\"78\":1,\"79\":1}}],[\"trained\",{\"1\":{\"78\":1}}],[\"transformer\",{\"1\":{\"78\":2}}],[\"transit\",{\"1\":{\"76\":1}}],[\"transportation\",{\"0\":{\"81\":1},\"1\":{\"76\":3}}],[\"transport\",{\"1\":{\"76\":4}}],[\"traffic\",{\"0\":{\"76\":1,\"80\":1,\"82\":1,\"86\":1,\"91\":1,\"92\":1,\"93\":1},\"1\":{\"56\":1,\"76\":2,\"79\":1},\"2\":{\"24\":1,\"39\":1,\"44\":1,\"49\":1,\"54\":1,\"66\":1,\"71\":1,\"74\":1}}],[\"triggering\",{\"1\":{\"33\":1}}],[\"time\",{\"1\":{\"33\":1,\"62\":1}}],[\"t\",{\"1\":{\"11\":1,\"63\":4}}],[\"twin\",{\"1\":{\"3\":1}}],[\"冰岛\",{\"1\":{\"3\":1}}],[\"欧洲游\",{\"1\":{\"3\":1}}],[\"欧洲杯\",{\"1\":{\"3\":1}}],[\"欧冠\",{\"1\":{\"3\":1}}],[\"亚冠\",{\"1\":{\"3\":1}}],[\"现场看一次球赛\",{\"1\":{\"3\":1}}],[\"现场看一场\",{\"1\":{\"3\":1}}],[\"看一次霉妈的演唱会\",{\"1\":{\"3\":1}}],[\"看待问题十分的现实\",{\"1\":{\"3\":1}}],[\"mesoscopic\",{\"1\":{\"56\":1}}],[\"means\",{\"1\":{\"16\":7,\"76\":1}}],[\"microscopic\",{\"1\":{\"56\":1}}],[\"massive\",{\"1\":{\"78\":1}}],[\"machine\",{\"1\":{\"78\":1}}],[\"macroscopic\",{\"1\":{\"56\":1}}],[\"max\",{\"1\":{\"63\":3}}],[\"map\",{\"1\":{\"62\":6,\"63\":8}}],[\"map=ones\",{\"1\":{\"62\":1}}],[\"management\",{\"1\":{\"56\":1}}],[\"many\",{\"1\":{\"33\":1}}],[\"modes\",{\"1\":{\"76\":1}}],[\"models\",{\"1\":{\"78\":3}}],[\"modeling\",{\"1\":{\"56\":1}}],[\"model\",{\"1\":{\"33\":2,\"56\":2,\"78\":1}}],[\"more\",{\"1\":{\"76\":1,\"79\":1}}],[\"moving\",{\"1\":{\"76\":2}}],[\"movement\",{\"1\":{\"56\":1,\"76\":4}}],[\"moore邻居选择示意图\",{\"1\":{\"60\":1}}],[\"moore\",{\"1\":{\"29\":2,\"32\":2,\"59\":1}}],[\"m\",{\"1\":{\"11\":1}}],[\"ml\",{\"0\":{\"84\":1},\"1\":{\"4\":1},\"2\":{\"7\":1,\"18\":1}}],[\"msi\",{\"1\":{\"3\":1}}],[\"myself\",{\"1\":{\"1\":1,\"4\":1}}],[\"赛\",{\"1\":{\"3\":1}}],[\"探究生命的意义\",{\"1\":{\"3\":1}}],[\"却也逐渐看清了生活的本质\",{\"1\":{\"3\":1}}],[\"梦想很多\",{\"1\":{\"3\":1}}],[\"⚽\",{\"1\":{\"3\":1}}],[\"足球\",{\"1\":{\"3\":1}}],[\"吉他\",{\"1\":{\"3\":1}}],[\"唱歌\",{\"1\":{\"3\":1}}],[\"听歌\",{\"1\":{\"3\":1}}],[\"爱好\",{\"1\":{\"3\":1}}],[\"绿老头一枚\",{\"1\":{\"3\":1}}],[\"🎸\",{\"1\":{\"3\":1}}],[\"🎤\",{\"1\":{\"3\":1}}],[\"🎧\",{\"1\":{\"3\":1}}],[\"🍓\",{\"1\":{\"3\":1}}],[\"🏫\",{\"1\":{\"3\":1}}],[\"shuyu\",{\"0\":{\"89\":1}}],[\"shumo\",{\"0\":{\"85\":1}}],[\"short\",{\"1\":{\"62\":1}}],[\"sora有助于提高交通管理系统的准备性和响应能力\",{\"1\":{\"79\":1}}],[\"sora可以用来模拟自然灾害\",{\"1\":{\"79\":1}}],[\"sora可以帮助预测和分析交通模式\",{\"1\":{\"79\":1}}],[\"sora生成的视频可以模拟各种决策场景\",{\"1\":{\"79\":1}}],[\"sora结合了gpt技术\",{\"1\":{\"79\":1}}],[\"sora\",{\"0\":{\"79\":1},\"1\":{\"79\":1}}],[\"social\",{\"1\":{\"56\":1}}],[\"scenarios\",{\"1\":{\"79\":1}}],[\"scheme\",{\"1\":{\"76\":1}}],[\"scnarios\",{\"1\":{\"56\":1,\"79\":1}}],[\"speech\",{\"1\":{\"78\":1}}],[\"specifically\",{\"1\":{\"76\":1}}],[\"space\",{\"1\":{\"33\":1}}],[\"system\",{\"1\":{\"76\":1}}],[\"systems\",{\"1\":{\"76\":4}}],[\"subset\",{\"1\":{\"76\":1}}],[\"subways\",{\"1\":{\"76\":1}}],[\"supports\",{\"1\":{\"76\":1}}],[\"such\",{\"1\":{\"76\":2,\"78\":1}}],[\"sum\",{\"1\":{\"63\":2}}],[\"s=randsrc\",{\"1\":{\"63\":1}}],[\"sm\",{\"1\":{\"62\":6}}],[\"sm=ones\",{\"1\":{\"62\":1}}],[\"similar\",{\"1\":{\"76\":1}}],[\"simulating\",{\"1\":{\"56\":1,\"79\":1}}],[\"simulation\",{\"0\":{\"55\":1},\"1\":{\"33\":1,\"56\":1}}],[\"size\",{\"1\":{\"62\":3,\"63\":5}}],[\"si\",{\"1\":{\"60\":2}}],[\"sigmoid\",{\"1\":{\"6\":3}}],[\"set\",{\"1\":{\"33\":1}}],[\"svm\",{\"0\":{\"15\":1},\"1\":{\"15\":20}}],[\"star\",{\"1\":{\"62\":3}}],[\"state\",{\"1\":{\"3\":1,\"33\":4}}],[\"studies\",{\"1\":{\"56\":1}}],[\"step=1\",{\"1\":{\"62\":1}}],[\"step\",{\"1\":{\"33\":1}}],[\"stopping\",{\"1\":{\"11\":1}}],[\"s\",{\"1\":{\"3\":1,\"63\":6,\"76\":3}}],[\"swiftie\",{\"1\":{\"3\":1}}],[\"成分\",{\"1\":{\"3\":1}}],[\"水瓶座\",{\"1\":{\"3\":1}}],[\"星座\",{\"1\":{\"3\":1}}],[\"understand\",{\"1\":{\"79\":1}}],[\"understanding\",{\"1\":{\"78\":1}}],[\"university\",{\"1\":{\"3\":1}}],[\"using\",{\"1\":{\"78\":1}}],[\"used\",{\"1\":{\"76\":1}}],[\"urban\",{\"1\":{\"56\":1,\"76\":1}}],[\"ulam和john\",{\"1\":{\"26\":1}}],[\"updates\",{\"1\":{\"33\":1}}],[\"up\",{\"1\":{\"2\":1}}],[\"就无法选择\",{\"1\":{\"60\":1}}],[\"就是机器学习的其中一种方法\",{\"1\":{\"10\":1}}],[\"就是那个california\",{\"1\":{\"3\":1}}],[\"就显得非常合适\",{\"1\":{\"2\":1}}],[\"对交通规划\",{\"1\":{\"79\":1}}],[\"对元胞潜能进行归一化\",{\"1\":{\"60\":1}}],[\"对行人流仿真进一步了解可以移步此篇论文\",{\"1\":{\"56\":1}}],[\"对簇形状和密度的适应性\",{\"1\":{\"16\":1}}],[\"对高维数据和不均匀密度数据的处理相对困难\",{\"1\":{\"16\":1}}],[\"对参数的选择敏感\",{\"1\":{\"16\":1}}],[\"对数据集异常点不敏感\",{\"1\":{\"16\":1}}],[\"对象总数\",{\"1\":{\"16\":1}}],[\"对不同形状的簇和噪声具有较好的鲁棒性\",{\"1\":{\"16\":1}}],[\"对偶问题将原始问题中的约束转为了对偶问题中的等式约束\",{\"1\":{\"15\":1}}],[\"对逻辑回归而言\",{\"1\":{\"15\":1}}],[\"对异常点非常敏感\",{\"1\":{\"15\":1}}],[\"对具有同一规律的学习集以外的数据\",{\"1\":{\"10\":1}}],[\"对于自动驾驶\",{\"1\":{\"79\":1}}],[\"对于\",{\"1\":{\"32\":2}}],[\"对于非球形簇或具有不同密度的簇效果较差\",{\"1\":{\"16\":1}}],[\"对于非线性特征\",{\"1\":{\"15\":1}}],[\"对于非线性可分的数据集\",{\"1\":{\"15\":2}}],[\"对于一个新的数据样本\",{\"1\":{\"10\":1}}],[\"对于深层网络\",{\"1\":{\"6\":1}}],[\"对伸缩的不变形\",{\"1\":{\"6\":1}}],[\"对\",{\"1\":{\"3\":1}}],[\"一般常用为固定型和周期型边界条件\",{\"1\":{\"30\":1}}],[\"一般为二维\",{\"1\":{\"27\":1}}],[\"一个完整的元胞自动机模型包含\",{\"1\":{\"26\":1}}],[\"一\",{\"0\":{\"10\":1}}],[\"一种下采样方式\",{\"1\":{\"6\":1}}],[\"一枚\",{\"1\":{\"3\":1}}],[\"一名在读\",{\"1\":{\"3\":1}}],[\"一时难以消化吸收\",{\"1\":{\"1\":1}}],[\"职业\",{\"1\":{\"3\":1}}],[\"我们使用的样本通常是多维数据\",{\"1\":{\"10\":1}}],[\"我们通常得等到测试集才可以知道我们模型真正得实力\",{\"1\":{\"10\":1}}],[\"我\",{\"0\":{\"3\":1}}],[\"我会逐步去完善\",{\"1\":{\"1\":1}}],[\"尝试新的记录生活的方式\",{\"1\":{\"2\":1}}],[\"走出舒适圈\",{\"1\":{\"2\":1}}],[\"写过的很多代码\",{\"1\":{\"2\":1}}],[\"写在前面\",{\"0\":{\"1\":1}}],[\"发现自己之前做过的很多小项目\",{\"1\":{\"2\":1}}],[\"准备夏令营过程中\",{\"1\":{\"2\":1}}],[\"主成分分析\",{\"1\":{\"10\":1}}],[\"主要用来训练神经网络中的参数\",{\"1\":{\"10\":1}}],[\"主要有三个功效\",{\"1\":{\"6\":1}}],[\"主要为自学\",{\"1\":{\"4\":1}}],[\"主要记录本专业一些相关内容\",{\"1\":{\"4\":1}}],[\"主\",{\"1\":{\"2\":1}}],[\"音乐区\",{\"1\":{\"2\":1}}],[\"想当一个知识区博主\",{\"1\":{\"2\":1}}],[\"缘由\",{\"0\":{\"2\":1}}],[\"内容方面有待优化\",{\"1\":{\"1\":1}}],[\"布局\",{\"1\":{\"1\":1}}],[\"📝\",{\"1\":{\"3\":1}}],[\"💭\",{\"1\":{\"3\":1}}],[\"👐\",{\"1\":{\"2\":1}}],[\"💖\",{\"1\":{\"1\":1}}],[\"👋\",{\"1\":{\"0\":1}}],[\"billions\",{\"1\":{\"78\":1}}],[\"broader\",{\"1\":{\"76\":1}}],[\"border\",{\"1\":{\"62\":5,\"63\":3}}],[\"border=ones\",{\"1\":{\"62\":1}}],[\"boundary\",{\"1\":{\"33\":1}}],[\"by\",{\"1\":{\"56\":1,\"76\":1}}],[\"based\",{\"1\":{\"33\":1}}],[\"better\",{\"1\":{\"79\":1}}],[\"between\",{\"1\":{\"76\":1}}],[\"behavioral\",{\"1\":{\"56\":1}}],[\"be\",{\"1\":{\"33\":1}}],[\"b\",{\"1\":{\"14\":1}}],[\"buses\",{\"1\":{\"76\":1}}],[\"bushi\",{\"1\":{\"3\":1}}],[\"but\",{\"1\":{\"76\":1}}],[\"bug\",{\"1\":{\"1\":1}}],[\"blog\",{\"1\":{\"1\":1,\"2\":2}}],[\"很容易就会出现梯度消失的情况\",{\"1\":{\"6\":1}}],[\"很早就有的想法\",{\"1\":{\"2\":1}}],[\"很多新东西从未见过\",{\"1\":{\"1\":1}}],[\"很麻烦\",{\"1\":{\"1\":1}}],[\"刚开始的过程确实很难\",{\"1\":{\"1\":1}}],[\"所以需要分别计算四个出口的元胞潜力大小\",{\"1\":{\"63\":1}}],[\"所以需要对数据先做\",{\"1\":{\"15\":1}}],[\"所以最后\",{\"1\":{\"60\":1}}],[\"所以便有了现在这个页面\",{\"1\":{\"1\":1}}],[\"所以迟迟不肯行动\",{\"1\":{\"1\":1}}],[\"觉得还是要尝试些新东西\",{\"1\":{\"1\":1}}],[\"但在新环境中可能无法适应\",{\"1\":{\"79\":1}}],[\"但在其基础上进行的后续划分有可能使得性能显著提高\",{\"1\":{\"13\":1}}],[\"但训练集\",{\"1\":{\"11\":1}}],[\"但不能作为调参\",{\"1\":{\"10\":1}}],[\"但还是希望自己未来能成为一个有用之人\",{\"1\":{\"3\":1}}],[\"但还好有dream\",{\"1\":{\"1\":1}}],[\"但同时也是一个理想的完美主义者\",{\"1\":{\"3\":1}}],[\"但痛定思痛\",{\"1\":{\"1\":1}}],[\"但总感觉很难\",{\"1\":{\"1\":1}}],[\"欢迎来到我的博客\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
